
001_Hello_FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006f34  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001e  00800060  00006f34  00006fc8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064b  0080007e  0080007e  00006fe6  2**0
                  ALLOC
  3 .stab         0000a65c  00000000  00000000  00006fe8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000677d  00000000  00000000  00011644  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1c 08 	jmp	0x1038	; 0x1038 <__vector_7>
      20:	0c 94 0e 37 	jmp	0x6e1c	; 0x6e1c <__vector_8>
      24:	0c 94 41 37 	jmp	0x6e82	; 0x6e82 <__vector_9>
      28:	0c 94 93 31 	jmp	0x6326	; 0x6326 <__vector_10>
      2c:	0c 94 c6 31 	jmp	0x638c	; 0x638c <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e3       	ldi	r30, 0x34	; 52
      68:	ff e6       	ldi	r31, 0x6F	; 111
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 37       	cpi	r26, 0x7E	; 126
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	ae e7       	ldi	r26, 0x7E	; 126
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 3c       	cpi	r26, 0xC9	; 201
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 6a 00 	call	0xd4	; 0xd4 <main>
      8a:	0c 94 98 37 	jmp	0x6f30	; 0x6f30 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Task_1>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <Task_1+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	9a 83       	std	Y+2, r25	; 0x02
      9e:	89 83       	std	Y+1, r24	; 0x01
      a0:	80 e0       	ldi	r24, 0x00	; 0
      a2:	60 e0       	ldi	r22, 0x00	; 0
      a4:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <DIO_enuTogPin>
      a8:	84 e6       	ldi	r24, 0x64	; 100
      aa:	90 e0       	ldi	r25, 0x00	; 0
      ac:	0e 94 ce 19 	call	0x339c	; 0x339c <vTaskDelay>
      b0:	f7 cf       	rjmp	.-18     	; 0xa0 <Task_1+0xe>

000000b2 <vApplicationTickHook>:
		vTaskDelay(100);
	}
}

void vApplicationTickHook( void )
{
      b2:	df 93       	push	r29
      b4:	cf 93       	push	r28
      b6:	cd b7       	in	r28, 0x3d	; 61
      b8:	de b7       	in	r29, 0x3e	; 62
	DIO_enuSetPinValue(DIO_u8PORTA, DIO_u8PIN7 , DIO_u8PIN_HIGH);
      ba:	80 e0       	ldi	r24, 0x00	; 0
      bc:	67 e0       	ldi	r22, 0x07	; 7
      be:	41 e0       	ldi	r20, 0x01	; 1
      c0:	0e 94 9c 2c 	call	0x5938	; 0x5938 <DIO_enuSetPinValue>
	DIO_enuSetPinValue(DIO_u8PORTA, DIO_u8PIN7 , DIO_u8PIN_LOW);
      c4:	80 e0       	ldi	r24, 0x00	; 0
      c6:	67 e0       	ldi	r22, 0x07	; 7
      c8:	40 e0       	ldi	r20, 0x00	; 0
      ca:	0e 94 9c 2c 	call	0x5938	; 0x5938 <DIO_enuSetPinValue>

}
      ce:	cf 91       	pop	r28
      d0:	df 91       	pop	r29
      d2:	08 95       	ret

000000d4 <main>:

BaseType_t xReturned;

int main(void)
{
      d4:	ef 92       	push	r14
      d6:	ff 92       	push	r15
      d8:	0f 93       	push	r16
      da:	df 93       	push	r29
      dc:	cf 93       	push	r28
      de:	cd b7       	in	r28, 0x3d	; 61
      e0:	de b7       	in	r29, 0x3e	; 62

	DIO_enuInit();
      e2:	0e 94 34 2a 	call	0x5468	; 0x5468 <DIO_enuInit>
	GIE_enuEnable();
      e6:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <GIE_enuEnable>


	xReturned = xTaskCreate(Task_1, "Toggle", 90, (void *) 0 , 2 , &Task1_hn);
      ea:	89 e4       	ldi	r24, 0x49	; 73
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	20 e6       	ldi	r18, 0x60	; 96
      f0:	30 e0       	ldi	r19, 0x00	; 0
      f2:	ee e7       	ldi	r30, 0x7E	; 126
      f4:	f0 e0       	ldi	r31, 0x00	; 0
      f6:	b9 01       	movw	r22, r18
      f8:	4a e5       	ldi	r20, 0x5A	; 90
      fa:	50 e0       	ldi	r21, 0x00	; 0
      fc:	20 e0       	ldi	r18, 0x00	; 0
      fe:	30 e0       	ldi	r19, 0x00	; 0
     100:	02 e0       	ldi	r16, 0x02	; 2
     102:	7f 01       	movw	r14, r30
     104:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <xTaskCreate>
     108:	80 93 c8 06 	sts	0x06C8, r24

	if(xReturned == pdPASS)
     10c:	80 91 c8 06 	lds	r24, 0x06C8
     110:	81 30       	cpi	r24, 0x01	; 1
     112:	29 f4       	brne	.+10     	; 0x11e <main+0x4a>
	{
		/*indicate the task is created successfully*/
		DIO_enuSetPinValue(DIO_u8PORTA, DIO_u8PIN3 , DIO_u8PIN_HIGH);
     114:	80 e0       	ldi	r24, 0x00	; 0
     116:	63 e0       	ldi	r22, 0x03	; 3
     118:	41 e0       	ldi	r20, 0x01	; 1
     11a:	0e 94 9c 2c 	call	0x5938	; 0x5938 <DIO_enuSetPinValue>
	}

	/* Start Scheduler */
	vTaskStartScheduler();
     11e:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <vTaskStartScheduler>
     122:	ff cf       	rjmp	.-2      	; 0x122 <main+0x4e>

00000124 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
     124:	df 93       	push	r29
     126:	cf 93       	push	r28
     128:	00 d0       	rcall	.+0      	; 0x12a <xEventGroupCreate+0x6>
     12a:	cd b7       	in	r28, 0x3d	; 61
     12c:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     12e:	8b e0       	ldi	r24, 0x0B	; 11
     130:	90 e0       	ldi	r25, 0x00	; 0
     132:	0e 94 d7 03 	call	0x7ae	; 0x7ae <pvPortMalloc>
     136:	9a 83       	std	Y+2, r25	; 0x02
     138:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
     13a:	89 81       	ldd	r24, Y+1	; 0x01
     13c:	9a 81       	ldd	r25, Y+2	; 0x02
     13e:	00 97       	sbiw	r24, 0x00	; 0
     140:	49 f0       	breq	.+18     	; 0x154 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
     142:	e9 81       	ldd	r30, Y+1	; 0x01
     144:	fa 81       	ldd	r31, Y+2	; 0x02
     146:	11 82       	std	Z+1, r1	; 0x01
     148:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     14a:	89 81       	ldd	r24, Y+1	; 0x01
     14c:	9a 81       	ldd	r25, Y+2	; 0x02
     14e:	02 96       	adiw	r24, 0x02	; 2
     150:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	9a 81       	ldd	r25, Y+2	; 0x02
    }
     158:	0f 90       	pop	r0
     15a:	0f 90       	pop	r0
     15c:	cf 91       	pop	r28
     15e:	df 91       	pop	r29
     160:	08 95       	ret

00000162 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
     162:	df 93       	push	r29
     164:	cf 93       	push	r28
     166:	cd b7       	in	r28, 0x3d	; 61
     168:	de b7       	in	r29, 0x3e	; 62
     16a:	60 97       	sbiw	r28, 0x10	; 16
     16c:	0f b6       	in	r0, 0x3f	; 63
     16e:	f8 94       	cli
     170:	de bf       	out	0x3e, r29	; 62
     172:	0f be       	out	0x3f, r0	; 63
     174:	cd bf       	out	0x3d, r28	; 61
     176:	9a 87       	std	Y+10, r25	; 0x0a
     178:	89 87       	std	Y+9, r24	; 0x09
     17a:	7c 87       	std	Y+12, r23	; 0x0c
     17c:	6b 87       	std	Y+11, r22	; 0x0b
     17e:	5e 87       	std	Y+14, r21	; 0x0e
     180:	4d 87       	std	Y+13, r20	; 0x0d
     182:	38 8b       	std	Y+16, r19	; 0x10
     184:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
     186:	89 85       	ldd	r24, Y+9	; 0x09
     188:	9a 85       	ldd	r25, Y+10	; 0x0a
     18a:	9c 83       	std	Y+4, r25	; 0x04
     18c:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     18e:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
     190:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
     194:	eb 81       	ldd	r30, Y+3	; 0x03
     196:	fc 81       	ldd	r31, Y+4	; 0x04
     198:	80 81       	ld	r24, Z
     19a:	91 81       	ldd	r25, Z+1	; 0x01
     19c:	98 87       	std	Y+8, r25	; 0x08
     19e:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     1a0:	89 85       	ldd	r24, Y+9	; 0x09
     1a2:	9a 85       	ldd	r25, Y+10	; 0x0a
     1a4:	2b 85       	ldd	r18, Y+11	; 0x0b
     1a6:	3c 85       	ldd	r19, Y+12	; 0x0c
     1a8:	b9 01       	movw	r22, r18
     1aa:	0e 94 88 02 	call	0x510	; 0x510 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     1ae:	2f 81       	ldd	r18, Y+7	; 0x07
     1b0:	38 85       	ldd	r19, Y+8	; 0x08
     1b2:	8b 85       	ldd	r24, Y+11	; 0x0b
     1b4:	9c 85       	ldd	r25, Y+12	; 0x0c
     1b6:	28 2b       	or	r18, r24
     1b8:	39 2b       	or	r19, r25
     1ba:	8d 85       	ldd	r24, Y+13	; 0x0d
     1bc:	9e 85       	ldd	r25, Y+14	; 0x0e
     1be:	28 23       	and	r18, r24
     1c0:	39 23       	and	r19, r25
     1c2:	8d 85       	ldd	r24, Y+13	; 0x0d
     1c4:	9e 85       	ldd	r25, Y+14	; 0x0e
     1c6:	28 17       	cp	r18, r24
     1c8:	39 07       	cpc	r19, r25
     1ca:	c9 f4       	brne	.+50     	; 0x1fe <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     1cc:	2f 81       	ldd	r18, Y+7	; 0x07
     1ce:	38 85       	ldd	r19, Y+8	; 0x08
     1d0:	8b 85       	ldd	r24, Y+11	; 0x0b
     1d2:	9c 85       	ldd	r25, Y+12	; 0x0c
     1d4:	82 2b       	or	r24, r18
     1d6:	93 2b       	or	r25, r19
     1d8:	9e 83       	std	Y+6, r25	; 0x06
     1da:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     1dc:	eb 81       	ldd	r30, Y+3	; 0x03
     1de:	fc 81       	ldd	r31, Y+4	; 0x04
     1e0:	20 81       	ld	r18, Z
     1e2:	31 81       	ldd	r19, Z+1	; 0x01
     1e4:	8d 85       	ldd	r24, Y+13	; 0x0d
     1e6:	9e 85       	ldd	r25, Y+14	; 0x0e
     1e8:	80 95       	com	r24
     1ea:	90 95       	com	r25
     1ec:	82 23       	and	r24, r18
     1ee:	93 23       	and	r25, r19
     1f0:	eb 81       	ldd	r30, Y+3	; 0x03
     1f2:	fc 81       	ldd	r31, Y+4	; 0x04
     1f4:	91 83       	std	Z+1, r25	; 0x01
     1f6:	80 83       	st	Z, r24

            xTicksToWait = 0;
     1f8:	18 8a       	std	Y+16, r1	; 0x10
     1fa:	1f 86       	std	Y+15, r1	; 0x0f
     1fc:	1e c0       	rjmp	.+60     	; 0x23a <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
     1fe:	8f 85       	ldd	r24, Y+15	; 0x0f
     200:	98 89       	ldd	r25, Y+16	; 0x10
     202:	00 97       	sbiw	r24, 0x00	; 0
     204:	91 f0       	breq	.+36     	; 0x22a <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     206:	8b 81       	ldd	r24, Y+3	; 0x03
     208:	9c 81       	ldd	r25, Y+4	; 0x04
     20a:	bc 01       	movw	r22, r24
     20c:	6e 5f       	subi	r22, 0xFE	; 254
     20e:	7f 4f       	sbci	r23, 0xFF	; 255
     210:	8d 85       	ldd	r24, Y+13	; 0x0d
     212:	9e 85       	ldd	r25, Y+14	; 0x0e
     214:	9c 01       	movw	r18, r24
     216:	35 60       	ori	r19, 0x05	; 5
     218:	4f 85       	ldd	r20, Y+15	; 0x0f
     21a:	58 89       	ldd	r21, Y+16	; 0x10
     21c:	cb 01       	movw	r24, r22
     21e:	b9 01       	movw	r22, r18
     220:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
     224:	1e 82       	std	Y+6, r1	; 0x06
     226:	1d 82       	std	Y+5, r1	; 0x05
     228:	08 c0       	rjmp	.+16     	; 0x23a <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     22a:	eb 81       	ldd	r30, Y+3	; 0x03
     22c:	fc 81       	ldd	r31, Y+4	; 0x04
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	9e 83       	std	Y+6, r25	; 0x06
     234:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
     236:	81 e0       	ldi	r24, 0x01	; 1
     238:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     23a:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
     23e:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
     240:	8f 85       	ldd	r24, Y+15	; 0x0f
     242:	98 89       	ldd	r25, Y+16	; 0x10
     244:	00 97       	sbiw	r24, 0x00	; 0
     246:	09 f4       	brne	.+2      	; 0x24a <xEventGroupSync+0xe8>
     248:	3a c0       	rjmp	.+116    	; 0x2be <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
     24a:	8a 81       	ldd	r24, Y+2	; 0x02
     24c:	88 23       	and	r24, r24
     24e:	11 f4       	brne	.+4      	; 0x254 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
     250:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     254:	0e 94 2a 22 	call	0x4454	; 0x4454 <uxTaskResetEventItemValue>
     258:	9e 83       	std	Y+6, r25	; 0x06
     25a:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     25c:	8d 81       	ldd	r24, Y+5	; 0x05
     25e:	9e 81       	ldd	r25, Y+6	; 0x06
     260:	80 70       	andi	r24, 0x00	; 0
     262:	92 70       	andi	r25, 0x02	; 2
     264:	00 97       	sbiw	r24, 0x00	; 0
     266:	31 f5       	brne	.+76     	; 0x2b4 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
     268:	0f b6       	in	r0, 0x3f	; 63
     26a:	f8 94       	cli
     26c:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
     26e:	eb 81       	ldd	r30, Y+3	; 0x03
     270:	fc 81       	ldd	r31, Y+4	; 0x04
     272:	80 81       	ld	r24, Z
     274:	91 81       	ldd	r25, Z+1	; 0x01
     276:	9e 83       	std	Y+6, r25	; 0x06
     278:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     27a:	2d 81       	ldd	r18, Y+5	; 0x05
     27c:	3e 81       	ldd	r19, Y+6	; 0x06
     27e:	8d 85       	ldd	r24, Y+13	; 0x0d
     280:	9e 85       	ldd	r25, Y+14	; 0x0e
     282:	28 23       	and	r18, r24
     284:	39 23       	and	r19, r25
     286:	8d 85       	ldd	r24, Y+13	; 0x0d
     288:	9e 85       	ldd	r25, Y+14	; 0x0e
     28a:	28 17       	cp	r18, r24
     28c:	39 07       	cpc	r19, r25
     28e:	71 f4       	brne	.+28     	; 0x2ac <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     290:	eb 81       	ldd	r30, Y+3	; 0x03
     292:	fc 81       	ldd	r31, Y+4	; 0x04
     294:	20 81       	ld	r18, Z
     296:	31 81       	ldd	r19, Z+1	; 0x01
     298:	8d 85       	ldd	r24, Y+13	; 0x0d
     29a:	9e 85       	ldd	r25, Y+14	; 0x0e
     29c:	80 95       	com	r24
     29e:	90 95       	com	r25
     2a0:	82 23       	and	r24, r18
     2a2:	93 23       	and	r25, r19
     2a4:	eb 81       	ldd	r30, Y+3	; 0x03
     2a6:	fc 81       	ldd	r31, Y+4	; 0x04
     2a8:	91 83       	std	Z+1, r25	; 0x01
     2aa:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
     2ac:	0f 90       	pop	r0
     2ae:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
     2b0:	81 e0       	ldi	r24, 0x01	; 1
     2b2:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     2b4:	8d 81       	ldd	r24, Y+5	; 0x05
     2b6:	9e 81       	ldd	r25, Y+6	; 0x06
     2b8:	90 70       	andi	r25, 0x00	; 0
     2ba:	9e 83       	std	Y+6, r25	; 0x06
     2bc:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
     2be:	8d 81       	ldd	r24, Y+5	; 0x05
     2c0:	9e 81       	ldd	r25, Y+6	; 0x06
}
     2c2:	60 96       	adiw	r28, 0x10	; 16
     2c4:	0f b6       	in	r0, 0x3f	; 63
     2c6:	f8 94       	cli
     2c8:	de bf       	out	0x3e, r29	; 62
     2ca:	0f be       	out	0x3f, r0	; 63
     2cc:	cd bf       	out	0x3d, r28	; 61
     2ce:	cf 91       	pop	r28
     2d0:	df 91       	pop	r29
     2d2:	08 95       	ret

000002d4 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
     2d4:	0f 93       	push	r16
     2d6:	1f 93       	push	r17
     2d8:	df 93       	push	r29
     2da:	cf 93       	push	r28
     2dc:	cd b7       	in	r28, 0x3d	; 61
     2de:	de b7       	in	r29, 0x3e	; 62
     2e0:	63 97       	sbiw	r28, 0x13	; 19
     2e2:	0f b6       	in	r0, 0x3f	; 63
     2e4:	f8 94       	cli
     2e6:	de bf       	out	0x3e, r29	; 62
     2e8:	0f be       	out	0x3f, r0	; 63
     2ea:	cd bf       	out	0x3d, r28	; 61
     2ec:	9d 87       	std	Y+13, r25	; 0x0d
     2ee:	8c 87       	std	Y+12, r24	; 0x0c
     2f0:	7f 87       	std	Y+15, r23	; 0x0f
     2f2:	6e 87       	std	Y+14, r22	; 0x0e
     2f4:	48 8b       	std	Y+16, r20	; 0x10
     2f6:	29 8b       	std	Y+17, r18	; 0x11
     2f8:	1b 8b       	std	Y+19, r17	; 0x13
     2fa:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
     2fc:	8c 85       	ldd	r24, Y+12	; 0x0c
     2fe:	9d 85       	ldd	r25, Y+13	; 0x0d
     300:	9b 87       	std	Y+11, r25	; 0x0b
     302:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
     304:	1f 82       	std	Y+7, r1	; 0x07
     306:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     308:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
     30a:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     30e:	ea 85       	ldd	r30, Y+10	; 0x0a
     310:	fb 85       	ldd	r31, Y+11	; 0x0b
     312:	80 81       	ld	r24, Z
     314:	91 81       	ldd	r25, Z+1	; 0x01
     316:	9a 83       	std	Y+2, r25	; 0x02
     318:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     31a:	89 81       	ldd	r24, Y+1	; 0x01
     31c:	9a 81       	ldd	r25, Y+2	; 0x02
     31e:	2e 85       	ldd	r18, Y+14	; 0x0e
     320:	3f 85       	ldd	r19, Y+15	; 0x0f
     322:	b9 01       	movw	r22, r18
     324:	49 89       	ldd	r20, Y+17	; 0x11
     326:	0e 94 a5 03 	call	0x74a	; 0x74a <prvTestWaitCondition>
     32a:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
     32c:	8d 81       	ldd	r24, Y+5	; 0x05
     32e:	88 23       	and	r24, r24
     330:	c1 f0       	breq	.+48     	; 0x362 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
     332:	89 81       	ldd	r24, Y+1	; 0x01
     334:	9a 81       	ldd	r25, Y+2	; 0x02
     336:	99 87       	std	Y+9, r25	; 0x09
     338:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
     33a:	1b 8a       	std	Y+19, r1	; 0x13
     33c:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
     33e:	88 89       	ldd	r24, Y+16	; 0x10
     340:	88 23       	and	r24, r24
     342:	e9 f1       	breq	.+122    	; 0x3be <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     344:	ea 85       	ldd	r30, Y+10	; 0x0a
     346:	fb 85       	ldd	r31, Y+11	; 0x0b
     348:	20 81       	ld	r18, Z
     34a:	31 81       	ldd	r19, Z+1	; 0x01
     34c:	8e 85       	ldd	r24, Y+14	; 0x0e
     34e:	9f 85       	ldd	r25, Y+15	; 0x0f
     350:	80 95       	com	r24
     352:	90 95       	com	r25
     354:	82 23       	and	r24, r18
     356:	93 23       	and	r25, r19
     358:	ea 85       	ldd	r30, Y+10	; 0x0a
     35a:	fb 85       	ldd	r31, Y+11	; 0x0b
     35c:	91 83       	std	Z+1, r25	; 0x01
     35e:	80 83       	st	Z, r24
     360:	2e c0       	rjmp	.+92     	; 0x3be <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
     362:	8a 89       	ldd	r24, Y+18	; 0x12
     364:	9b 89       	ldd	r25, Y+19	; 0x13
     366:	00 97       	sbiw	r24, 0x00	; 0
     368:	39 f4       	brne	.+14     	; 0x378 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	9a 81       	ldd	r25, Y+2	; 0x02
     36e:	99 87       	std	Y+9, r25	; 0x09
     370:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
     372:	81 e0       	ldi	r24, 0x01	; 1
     374:	8b 83       	std	Y+3, r24	; 0x03
     376:	23 c0       	rjmp	.+70     	; 0x3be <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
     378:	88 89       	ldd	r24, Y+16	; 0x10
     37a:	88 23       	and	r24, r24
     37c:	29 f0       	breq	.+10     	; 0x388 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     37e:	8e 81       	ldd	r24, Y+6	; 0x06
     380:	9f 81       	ldd	r25, Y+7	; 0x07
     382:	91 60       	ori	r25, 0x01	; 1
     384:	9f 83       	std	Y+7, r25	; 0x07
     386:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
     388:	89 89       	ldd	r24, Y+17	; 0x11
     38a:	88 23       	and	r24, r24
     38c:	29 f0       	breq	.+10     	; 0x398 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
     38e:	8e 81       	ldd	r24, Y+6	; 0x06
     390:	9f 81       	ldd	r25, Y+7	; 0x07
     392:	94 60       	ori	r25, 0x04	; 4
     394:	9f 83       	std	Y+7, r25	; 0x07
     396:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     398:	8a 85       	ldd	r24, Y+10	; 0x0a
     39a:	9b 85       	ldd	r25, Y+11	; 0x0b
     39c:	bc 01       	movw	r22, r24
     39e:	6e 5f       	subi	r22, 0xFE	; 254
     3a0:	7f 4f       	sbci	r23, 0xFF	; 255
     3a2:	2e 85       	ldd	r18, Y+14	; 0x0e
     3a4:	3f 85       	ldd	r19, Y+15	; 0x0f
     3a6:	8e 81       	ldd	r24, Y+6	; 0x06
     3a8:	9f 81       	ldd	r25, Y+7	; 0x07
     3aa:	28 2b       	or	r18, r24
     3ac:	39 2b       	or	r19, r25
     3ae:	4a 89       	ldd	r20, Y+18	; 0x12
     3b0:	5b 89       	ldd	r21, Y+19	; 0x13
     3b2:	cb 01       	movw	r24, r22
     3b4:	b9 01       	movw	r22, r18
     3b6:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
     3ba:	19 86       	std	Y+9, r1	; 0x09
     3bc:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     3be:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
     3c2:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
     3c4:	8a 89       	ldd	r24, Y+18	; 0x12
     3c6:	9b 89       	ldd	r25, Y+19	; 0x13
     3c8:	00 97       	sbiw	r24, 0x00	; 0
     3ca:	09 f4       	brne	.+2      	; 0x3ce <xEventGroupWaitBits+0xfa>
     3cc:	3c c0       	rjmp	.+120    	; 0x446 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
     3ce:	8c 81       	ldd	r24, Y+4	; 0x04
     3d0:	88 23       	and	r24, r24
     3d2:	11 f4       	brne	.+4      	; 0x3d8 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
     3d4:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     3d8:	0e 94 2a 22 	call	0x4454	; 0x4454 <uxTaskResetEventItemValue>
     3dc:	99 87       	std	Y+9, r25	; 0x09
     3de:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     3e0:	88 85       	ldd	r24, Y+8	; 0x08
     3e2:	99 85       	ldd	r25, Y+9	; 0x09
     3e4:	80 70       	andi	r24, 0x00	; 0
     3e6:	92 70       	andi	r25, 0x02	; 2
     3e8:	00 97       	sbiw	r24, 0x00	; 0
     3ea:	41 f5       	brne	.+80     	; 0x43c <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
     3ec:	0f b6       	in	r0, 0x3f	; 63
     3ee:	f8 94       	cli
     3f0:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     3f2:	ea 85       	ldd	r30, Y+10	; 0x0a
     3f4:	fb 85       	ldd	r31, Y+11	; 0x0b
     3f6:	80 81       	ld	r24, Z
     3f8:	91 81       	ldd	r25, Z+1	; 0x01
     3fa:	99 87       	std	Y+9, r25	; 0x09
     3fc:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     3fe:	88 85       	ldd	r24, Y+8	; 0x08
     400:	99 85       	ldd	r25, Y+9	; 0x09
     402:	2e 85       	ldd	r18, Y+14	; 0x0e
     404:	3f 85       	ldd	r19, Y+15	; 0x0f
     406:	b9 01       	movw	r22, r18
     408:	49 89       	ldd	r20, Y+17	; 0x11
     40a:	0e 94 a5 03 	call	0x74a	; 0x74a <prvTestWaitCondition>
     40e:	88 23       	and	r24, r24
     410:	89 f0       	breq	.+34     	; 0x434 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
     412:	88 89       	ldd	r24, Y+16	; 0x10
     414:	88 23       	and	r24, r24
     416:	71 f0       	breq	.+28     	; 0x434 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     418:	ea 85       	ldd	r30, Y+10	; 0x0a
     41a:	fb 85       	ldd	r31, Y+11	; 0x0b
     41c:	20 81       	ld	r18, Z
     41e:	31 81       	ldd	r19, Z+1	; 0x01
     420:	8e 85       	ldd	r24, Y+14	; 0x0e
     422:	9f 85       	ldd	r25, Y+15	; 0x0f
     424:	80 95       	com	r24
     426:	90 95       	com	r25
     428:	82 23       	and	r24, r18
     42a:	93 23       	and	r25, r19
     42c:	ea 85       	ldd	r30, Y+10	; 0x0a
     42e:	fb 85       	ldd	r31, Y+11	; 0x0b
     430:	91 83       	std	Z+1, r25	; 0x01
     432:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
     438:	0f 90       	pop	r0
     43a:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     43c:	88 85       	ldd	r24, Y+8	; 0x08
     43e:	99 85       	ldd	r25, Y+9	; 0x09
     440:	90 70       	andi	r25, 0x00	; 0
     442:	99 87       	std	Y+9, r25	; 0x09
     444:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
     446:	88 85       	ldd	r24, Y+8	; 0x08
     448:	99 85       	ldd	r25, Y+9	; 0x09
}
     44a:	63 96       	adiw	r28, 0x13	; 19
     44c:	0f b6       	in	r0, 0x3f	; 63
     44e:	f8 94       	cli
     450:	de bf       	out	0x3e, r29	; 62
     452:	0f be       	out	0x3f, r0	; 63
     454:	cd bf       	out	0x3d, r28	; 61
     456:	cf 91       	pop	r28
     458:	df 91       	pop	r29
     45a:	1f 91       	pop	r17
     45c:	0f 91       	pop	r16
     45e:	08 95       	ret

00000460 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
     460:	df 93       	push	r29
     462:	cf 93       	push	r28
     464:	cd b7       	in	r28, 0x3d	; 61
     466:	de b7       	in	r29, 0x3e	; 62
     468:	28 97       	sbiw	r28, 0x08	; 8
     46a:	0f b6       	in	r0, 0x3f	; 63
     46c:	f8 94       	cli
     46e:	de bf       	out	0x3e, r29	; 62
     470:	0f be       	out	0x3f, r0	; 63
     472:	cd bf       	out	0x3d, r28	; 61
     474:	9e 83       	std	Y+6, r25	; 0x06
     476:	8d 83       	std	Y+5, r24	; 0x05
     478:	78 87       	std	Y+8, r23	; 0x08
     47a:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
     47c:	8d 81       	ldd	r24, Y+5	; 0x05
     47e:	9e 81       	ldd	r25, Y+6	; 0x06
     480:	9c 83       	std	Y+4, r25	; 0x04
     482:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
     484:	0f b6       	in	r0, 0x3f	; 63
     486:	f8 94       	cli
     488:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
     48a:	eb 81       	ldd	r30, Y+3	; 0x03
     48c:	fc 81       	ldd	r31, Y+4	; 0x04
     48e:	80 81       	ld	r24, Z
     490:	91 81       	ldd	r25, Z+1	; 0x01
     492:	9a 83       	std	Y+2, r25	; 0x02
     494:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
     496:	eb 81       	ldd	r30, Y+3	; 0x03
     498:	fc 81       	ldd	r31, Y+4	; 0x04
     49a:	20 81       	ld	r18, Z
     49c:	31 81       	ldd	r19, Z+1	; 0x01
     49e:	8f 81       	ldd	r24, Y+7	; 0x07
     4a0:	98 85       	ldd	r25, Y+8	; 0x08
     4a2:	80 95       	com	r24
     4a4:	90 95       	com	r25
     4a6:	82 23       	and	r24, r18
     4a8:	93 23       	and	r25, r19
     4aa:	eb 81       	ldd	r30, Y+3	; 0x03
     4ac:	fc 81       	ldd	r31, Y+4	; 0x04
     4ae:	91 83       	std	Z+1, r25	; 0x01
     4b0:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
     4b2:	0f 90       	pop	r0
     4b4:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
     4b6:	89 81       	ldd	r24, Y+1	; 0x01
     4b8:	9a 81       	ldd	r25, Y+2	; 0x02
}
     4ba:	28 96       	adiw	r28, 0x08	; 8
     4bc:	0f b6       	in	r0, 0x3f	; 63
     4be:	f8 94       	cli
     4c0:	de bf       	out	0x3e, r29	; 62
     4c2:	0f be       	out	0x3f, r0	; 63
     4c4:	cd bf       	out	0x3d, r28	; 61
     4c6:	cf 91       	pop	r28
     4c8:	df 91       	pop	r29
     4ca:	08 95       	ret

000004cc <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     4cc:	df 93       	push	r29
     4ce:	cf 93       	push	r28
     4d0:	cd b7       	in	r28, 0x3d	; 61
     4d2:	de b7       	in	r29, 0x3e	; 62
     4d4:	27 97       	sbiw	r28, 0x07	; 7
     4d6:	0f b6       	in	r0, 0x3f	; 63
     4d8:	f8 94       	cli
     4da:	de bf       	out	0x3e, r29	; 62
     4dc:	0f be       	out	0x3f, r0	; 63
     4de:	cd bf       	out	0x3d, r28	; 61
     4e0:	9f 83       	std	Y+7, r25	; 0x07
     4e2:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
     4e4:	8e 81       	ldd	r24, Y+6	; 0x06
     4e6:	9f 81       	ldd	r25, Y+7	; 0x07
     4e8:	9c 83       	std	Y+4, r25	; 0x04
     4ea:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     4ec:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
     4ee:	eb 81       	ldd	r30, Y+3	; 0x03
     4f0:	fc 81       	ldd	r31, Y+4	; 0x04
     4f2:	80 81       	ld	r24, Z
     4f4:	91 81       	ldd	r25, Z+1	; 0x01
     4f6:	9a 83       	std	Y+2, r25	; 0x02
     4f8:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
     4fa:	89 81       	ldd	r24, Y+1	; 0x01
     4fc:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     4fe:	27 96       	adiw	r28, 0x07	; 7
     500:	0f b6       	in	r0, 0x3f	; 63
     502:	f8 94       	cli
     504:	de bf       	out	0x3e, r29	; 62
     506:	0f be       	out	0x3f, r0	; 63
     508:	cd bf       	out	0x3d, r28	; 61
     50a:	cf 91       	pop	r28
     50c:	df 91       	pop	r29
     50e:	08 95       	ret

00000510 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
     510:	df 93       	push	r29
     512:	cf 93       	push	r28
     514:	cd b7       	in	r28, 0x3d	; 61
     516:	de b7       	in	r29, 0x3e	; 62
     518:	65 97       	sbiw	r28, 0x15	; 21
     51a:	0f b6       	in	r0, 0x3f	; 63
     51c:	f8 94       	cli
     51e:	de bf       	out	0x3e, r29	; 62
     520:	0f be       	out	0x3f, r0	; 63
     522:	cd bf       	out	0x3d, r28	; 61
     524:	9b 8b       	std	Y+19, r25	; 0x13
     526:	8a 8b       	std	Y+18, r24	; 0x12
     528:	7d 8b       	std	Y+21, r23	; 0x15
     52a:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     52c:	19 86       	std	Y+9, r1	; 0x09
     52e:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
     530:	8a 89       	ldd	r24, Y+18	; 0x12
     532:	9b 89       	ldd	r25, Y+19	; 0x13
     534:	9b 83       	std	Y+3, r25	; 0x03
     536:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
     538:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
     53a:	8a 81       	ldd	r24, Y+2	; 0x02
     53c:	9b 81       	ldd	r25, Y+3	; 0x03
     53e:	02 96       	adiw	r24, 0x02	; 2
     540:	9b 87       	std	Y+11, r25	; 0x0b
     542:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     544:	8a 85       	ldd	r24, Y+10	; 0x0a
     546:	9b 85       	ldd	r25, Y+11	; 0x0b
     548:	03 96       	adiw	r24, 0x03	; 3
     54a:	9d 87       	std	Y+13, r25	; 0x0d
     54c:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
     54e:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
     552:	ea 85       	ldd	r30, Y+10	; 0x0a
     554:	fb 85       	ldd	r31, Y+11	; 0x0b
     556:	85 81       	ldd	r24, Z+5	; 0x05
     558:	96 81       	ldd	r25, Z+6	; 0x06
     55a:	99 8b       	std	Y+17, r25	; 0x11
     55c:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
     55e:	ea 81       	ldd	r30, Y+2	; 0x02
     560:	fb 81       	ldd	r31, Y+3	; 0x03
     562:	20 81       	ld	r18, Z
     564:	31 81       	ldd	r19, Z+1	; 0x01
     566:	8c 89       	ldd	r24, Y+20	; 0x14
     568:	9d 89       	ldd	r25, Y+21	; 0x15
     56a:	82 2b       	or	r24, r18
     56c:	93 2b       	or	r25, r19
     56e:	ea 81       	ldd	r30, Y+2	; 0x02
     570:	fb 81       	ldd	r31, Y+3	; 0x03
     572:	91 83       	std	Z+1, r25	; 0x01
     574:	80 83       	st	Z, r24
     576:	59 c0       	rjmp	.+178    	; 0x62a <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
     578:	e8 89       	ldd	r30, Y+16	; 0x10
     57a:	f9 89       	ldd	r31, Y+17	; 0x11
     57c:	82 81       	ldd	r24, Z+2	; 0x02
     57e:	93 81       	ldd	r25, Z+3	; 0x03
     580:	9f 87       	std	Y+15, r25	; 0x0f
     582:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     584:	e8 89       	ldd	r30, Y+16	; 0x10
     586:	f9 89       	ldd	r31, Y+17	; 0x11
     588:	80 81       	ld	r24, Z
     58a:	91 81       	ldd	r25, Z+1	; 0x01
     58c:	9f 83       	std	Y+7, r25	; 0x07
     58e:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
     590:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     592:	8e 81       	ldd	r24, Y+6	; 0x06
     594:	9f 81       	ldd	r25, Y+7	; 0x07
     596:	80 70       	andi	r24, 0x00	; 0
     598:	9d 83       	std	Y+5, r25	; 0x05
     59a:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     59c:	8e 81       	ldd	r24, Y+6	; 0x06
     59e:	9f 81       	ldd	r25, Y+7	; 0x07
     5a0:	90 70       	andi	r25, 0x00	; 0
     5a2:	9f 83       	std	Y+7, r25	; 0x07
     5a4:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     5a6:	8c 81       	ldd	r24, Y+4	; 0x04
     5a8:	9d 81       	ldd	r25, Y+5	; 0x05
     5aa:	80 70       	andi	r24, 0x00	; 0
     5ac:	94 70       	andi	r25, 0x04	; 4
     5ae:	00 97       	sbiw	r24, 0x00	; 0
     5b0:	69 f4       	brne	.+26     	; 0x5cc <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     5b2:	ea 81       	ldd	r30, Y+2	; 0x02
     5b4:	fb 81       	ldd	r31, Y+3	; 0x03
     5b6:	20 81       	ld	r18, Z
     5b8:	31 81       	ldd	r19, Z+1	; 0x01
     5ba:	8e 81       	ldd	r24, Y+6	; 0x06
     5bc:	9f 81       	ldd	r25, Y+7	; 0x07
     5be:	82 23       	and	r24, r18
     5c0:	93 23       	and	r25, r19
     5c2:	00 97       	sbiw	r24, 0x00	; 0
     5c4:	91 f0       	breq	.+36     	; 0x5ea <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
     5c6:	81 e0       	ldi	r24, 0x01	; 1
     5c8:	89 83       	std	Y+1, r24	; 0x01
     5ca:	0f c0       	rjmp	.+30     	; 0x5ea <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     5cc:	ea 81       	ldd	r30, Y+2	; 0x02
     5ce:	fb 81       	ldd	r31, Y+3	; 0x03
     5d0:	20 81       	ld	r18, Z
     5d2:	31 81       	ldd	r19, Z+1	; 0x01
     5d4:	8e 81       	ldd	r24, Y+6	; 0x06
     5d6:	9f 81       	ldd	r25, Y+7	; 0x07
     5d8:	28 23       	and	r18, r24
     5da:	39 23       	and	r19, r25
     5dc:	8e 81       	ldd	r24, Y+6	; 0x06
     5de:	9f 81       	ldd	r25, Y+7	; 0x07
     5e0:	28 17       	cp	r18, r24
     5e2:	39 07       	cpc	r19, r25
     5e4:	11 f4       	brne	.+4      	; 0x5ea <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
     5e6:	81 e0       	ldi	r24, 0x01	; 1
     5e8:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
     5ea:	89 81       	ldd	r24, Y+1	; 0x01
     5ec:	88 23       	and	r24, r24
     5ee:	c9 f0       	breq	.+50     	; 0x622 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     5f0:	8c 81       	ldd	r24, Y+4	; 0x04
     5f2:	9d 81       	ldd	r25, Y+5	; 0x05
     5f4:	80 70       	andi	r24, 0x00	; 0
     5f6:	91 70       	andi	r25, 0x01	; 1
     5f8:	00 97       	sbiw	r24, 0x00	; 0
     5fa:	41 f0       	breq	.+16     	; 0x60c <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
     5fc:	88 85       	ldd	r24, Y+8	; 0x08
     5fe:	99 85       	ldd	r25, Y+9	; 0x09
     600:	2e 81       	ldd	r18, Y+6	; 0x06
     602:	3f 81       	ldd	r19, Y+7	; 0x07
     604:	82 2b       	or	r24, r18
     606:	93 2b       	or	r25, r19
     608:	99 87       	std	Y+9, r25	; 0x09
     60a:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     60c:	ea 81       	ldd	r30, Y+2	; 0x02
     60e:	fb 81       	ldd	r31, Y+3	; 0x03
     610:	80 81       	ld	r24, Z
     612:	91 81       	ldd	r25, Z+1	; 0x01
     614:	9c 01       	movw	r18, r24
     616:	32 60       	ori	r19, 0x02	; 2
     618:	88 89       	ldd	r24, Y+16	; 0x10
     61a:	99 89       	ldd	r25, Y+17	; 0x11
     61c:	b9 01       	movw	r22, r18
     61e:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
     622:	8e 85       	ldd	r24, Y+14	; 0x0e
     624:	9f 85       	ldd	r25, Y+15	; 0x0f
     626:	99 8b       	std	Y+17, r25	; 0x11
     628:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
     62a:	28 89       	ldd	r18, Y+16	; 0x10
     62c:	39 89       	ldd	r19, Y+17	; 0x11
     62e:	8c 85       	ldd	r24, Y+12	; 0x0c
     630:	9d 85       	ldd	r25, Y+13	; 0x0d
     632:	28 17       	cp	r18, r24
     634:	39 07       	cpc	r19, r25
     636:	09 f0       	breq	.+2      	; 0x63a <xEventGroupSetBits+0x12a>
     638:	9f cf       	rjmp	.-194    	; 0x578 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
     63a:	ea 81       	ldd	r30, Y+2	; 0x02
     63c:	fb 81       	ldd	r31, Y+3	; 0x03
     63e:	20 81       	ld	r18, Z
     640:	31 81       	ldd	r19, Z+1	; 0x01
     642:	88 85       	ldd	r24, Y+8	; 0x08
     644:	99 85       	ldd	r25, Y+9	; 0x09
     646:	80 95       	com	r24
     648:	90 95       	com	r25
     64a:	82 23       	and	r24, r18
     64c:	93 23       	and	r25, r19
     64e:	ea 81       	ldd	r30, Y+2	; 0x02
     650:	fb 81       	ldd	r31, Y+3	; 0x03
     652:	91 83       	std	Z+1, r25	; 0x01
     654:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
     656:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>

    return pxEventBits->uxEventBits;
     65a:	ea 81       	ldd	r30, Y+2	; 0x02
     65c:	fb 81       	ldd	r31, Y+3	; 0x03
     65e:	80 81       	ld	r24, Z
     660:	91 81       	ldd	r25, Z+1	; 0x01
}
     662:	65 96       	adiw	r28, 0x15	; 21
     664:	0f b6       	in	r0, 0x3f	; 63
     666:	f8 94       	cli
     668:	de bf       	out	0x3e, r29	; 62
     66a:	0f be       	out	0x3f, r0	; 63
     66c:	cd bf       	out	0x3d, r28	; 61
     66e:	cf 91       	pop	r28
     670:	df 91       	pop	r29
     672:	08 95       	ret

00000674 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     674:	df 93       	push	r29
     676:	cf 93       	push	r28
     678:	00 d0       	rcall	.+0      	; 0x67a <vEventGroupDelete+0x6>
     67a:	00 d0       	rcall	.+0      	; 0x67c <vEventGroupDelete+0x8>
     67c:	00 d0       	rcall	.+0      	; 0x67e <vEventGroupDelete+0xa>
     67e:	cd b7       	in	r28, 0x3d	; 61
     680:	de b7       	in	r29, 0x3e	; 62
     682:	9e 83       	std	Y+6, r25	; 0x06
     684:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
     686:	8d 81       	ldd	r24, Y+5	; 0x05
     688:	9e 81       	ldd	r25, Y+6	; 0x06
     68a:	9c 83       	std	Y+4, r25	; 0x04
     68c:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     68e:	8b 81       	ldd	r24, Y+3	; 0x03
     690:	9c 81       	ldd	r25, Y+4	; 0x04
     692:	02 96       	adiw	r24, 0x02	; 2
     694:	9a 83       	std	Y+2, r25	; 0x02
     696:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
     698:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
     69c:	08 c0       	rjmp	.+16     	; 0x6ae <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     69e:	e9 81       	ldd	r30, Y+1	; 0x01
     6a0:	fa 81       	ldd	r31, Y+2	; 0x02
     6a2:	85 81       	ldd	r24, Z+5	; 0x05
     6a4:	96 81       	ldd	r25, Z+6	; 0x06
     6a6:	60 e0       	ldi	r22, 0x00	; 0
     6a8:	72 e0       	ldi	r23, 0x02	; 2
     6aa:	0e 94 b2 1f 	call	0x3f64	; 0x3f64 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     6ae:	e9 81       	ldd	r30, Y+1	; 0x01
     6b0:	fa 81       	ldd	r31, Y+2	; 0x02
     6b2:	80 81       	ld	r24, Z
     6b4:	88 23       	and	r24, r24
     6b6:	99 f7       	brne	.-26     	; 0x69e <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
     6b8:	8b 81       	ldd	r24, Y+3	; 0x03
     6ba:	9c 81       	ldd	r25, Y+4	; 0x04
     6bc:	0e 94 31 04 	call	0x862	; 0x862 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
     6c0:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
}
     6c4:	26 96       	adiw	r28, 0x06	; 6
     6c6:	0f b6       	in	r0, 0x3f	; 63
     6c8:	f8 94       	cli
     6ca:	de bf       	out	0x3e, r29	; 62
     6cc:	0f be       	out	0x3f, r0	; 63
     6ce:	cd bf       	out	0x3d, r28	; 61
     6d0:	cf 91       	pop	r28
     6d2:	df 91       	pop	r29
     6d4:	08 95       	ret

000006d6 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
     6d6:	df 93       	push	r29
     6d8:	cf 93       	push	r28
     6da:	00 d0       	rcall	.+0      	; 0x6dc <vEventGroupSetBitsCallback+0x6>
     6dc:	00 d0       	rcall	.+0      	; 0x6de <vEventGroupSetBitsCallback+0x8>
     6de:	00 d0       	rcall	.+0      	; 0x6e0 <vEventGroupSetBitsCallback+0xa>
     6e0:	cd b7       	in	r28, 0x3d	; 61
     6e2:	de b7       	in	r29, 0x3e	; 62
     6e4:	9a 83       	std	Y+2, r25	; 0x02
     6e6:	89 83       	std	Y+1, r24	; 0x01
     6e8:	4b 83       	std	Y+3, r20	; 0x03
     6ea:	5c 83       	std	Y+4, r21	; 0x04
     6ec:	6d 83       	std	Y+5, r22	; 0x05
     6ee:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     6f0:	89 81       	ldd	r24, Y+1	; 0x01
     6f2:	9a 81       	ldd	r25, Y+2	; 0x02
     6f4:	2b 81       	ldd	r18, Y+3	; 0x03
     6f6:	3c 81       	ldd	r19, Y+4	; 0x04
     6f8:	b9 01       	movw	r22, r18
     6fa:	0e 94 88 02 	call	0x510	; 0x510 <xEventGroupSetBits>
}
     6fe:	26 96       	adiw	r28, 0x06	; 6
     700:	0f b6       	in	r0, 0x3f	; 63
     702:	f8 94       	cli
     704:	de bf       	out	0x3e, r29	; 62
     706:	0f be       	out	0x3f, r0	; 63
     708:	cd bf       	out	0x3d, r28	; 61
     70a:	cf 91       	pop	r28
     70c:	df 91       	pop	r29
     70e:	08 95       	ret

00000710 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
     710:	df 93       	push	r29
     712:	cf 93       	push	r28
     714:	00 d0       	rcall	.+0      	; 0x716 <vEventGroupClearBitsCallback+0x6>
     716:	00 d0       	rcall	.+0      	; 0x718 <vEventGroupClearBitsCallback+0x8>
     718:	00 d0       	rcall	.+0      	; 0x71a <vEventGroupClearBitsCallback+0xa>
     71a:	cd b7       	in	r28, 0x3d	; 61
     71c:	de b7       	in	r29, 0x3e	; 62
     71e:	9a 83       	std	Y+2, r25	; 0x02
     720:	89 83       	std	Y+1, r24	; 0x01
     722:	4b 83       	std	Y+3, r20	; 0x03
     724:	5c 83       	std	Y+4, r21	; 0x04
     726:	6d 83       	std	Y+5, r22	; 0x05
     728:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     72a:	89 81       	ldd	r24, Y+1	; 0x01
     72c:	9a 81       	ldd	r25, Y+2	; 0x02
     72e:	2b 81       	ldd	r18, Y+3	; 0x03
     730:	3c 81       	ldd	r19, Y+4	; 0x04
     732:	b9 01       	movw	r22, r18
     734:	0e 94 30 02 	call	0x460	; 0x460 <xEventGroupClearBits>
}
     738:	26 96       	adiw	r28, 0x06	; 6
     73a:	0f b6       	in	r0, 0x3f	; 63
     73c:	f8 94       	cli
     73e:	de bf       	out	0x3e, r29	; 62
     740:	0f be       	out	0x3f, r0	; 63
     742:	cd bf       	out	0x3d, r28	; 61
     744:	cf 91       	pop	r28
     746:	df 91       	pop	r29
     748:	08 95       	ret

0000074a <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
     74a:	df 93       	push	r29
     74c:	cf 93       	push	r28
     74e:	00 d0       	rcall	.+0      	; 0x750 <prvTestWaitCondition+0x6>
     750:	00 d0       	rcall	.+0      	; 0x752 <prvTestWaitCondition+0x8>
     752:	00 d0       	rcall	.+0      	; 0x754 <prvTestWaitCondition+0xa>
     754:	cd b7       	in	r28, 0x3d	; 61
     756:	de b7       	in	r29, 0x3e	; 62
     758:	9b 83       	std	Y+3, r25	; 0x03
     75a:	8a 83       	std	Y+2, r24	; 0x02
     75c:	7d 83       	std	Y+5, r23	; 0x05
     75e:	6c 83       	std	Y+4, r22	; 0x04
     760:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
     762:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
     764:	8e 81       	ldd	r24, Y+6	; 0x06
     766:	88 23       	and	r24, r24
     768:	59 f4       	brne	.+22     	; 0x780 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     76a:	8a 81       	ldd	r24, Y+2	; 0x02
     76c:	9b 81       	ldd	r25, Y+3	; 0x03
     76e:	2c 81       	ldd	r18, Y+4	; 0x04
     770:	3d 81       	ldd	r19, Y+5	; 0x05
     772:	82 23       	and	r24, r18
     774:	93 23       	and	r25, r19
     776:	00 97       	sbiw	r24, 0x00	; 0
     778:	81 f0       	breq	.+32     	; 0x79a <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
     77a:	81 e0       	ldi	r24, 0x01	; 1
     77c:	89 83       	std	Y+1, r24	; 0x01
     77e:	0d c0       	rjmp	.+26     	; 0x79a <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     780:	2a 81       	ldd	r18, Y+2	; 0x02
     782:	3b 81       	ldd	r19, Y+3	; 0x03
     784:	8c 81       	ldd	r24, Y+4	; 0x04
     786:	9d 81       	ldd	r25, Y+5	; 0x05
     788:	28 23       	and	r18, r24
     78a:	39 23       	and	r19, r25
     78c:	8c 81       	ldd	r24, Y+4	; 0x04
     78e:	9d 81       	ldd	r25, Y+5	; 0x05
     790:	28 17       	cp	r18, r24
     792:	39 07       	cpc	r19, r25
     794:	11 f4       	brne	.+4      	; 0x79a <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
     796:	81 e0       	ldi	r24, 0x01	; 1
     798:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
     79a:	89 81       	ldd	r24, Y+1	; 0x01
}
     79c:	26 96       	adiw	r28, 0x06	; 6
     79e:	0f b6       	in	r0, 0x3f	; 63
     7a0:	f8 94       	cli
     7a2:	de bf       	out	0x3e, r29	; 62
     7a4:	0f be       	out	0x3f, r0	; 63
     7a6:	cd bf       	out	0x3d, r28	; 61
     7a8:	cf 91       	pop	r28
     7aa:	df 91       	pop	r29
     7ac:	08 95       	ret

000007ae <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
     7ae:	df 93       	push	r29
     7b0:	cf 93       	push	r28
     7b2:	00 d0       	rcall	.+0      	; 0x7b4 <pvPortMalloc+0x6>
     7b4:	00 d0       	rcall	.+0      	; 0x7b6 <pvPortMalloc+0x8>
     7b6:	cd b7       	in	r28, 0x3d	; 61
     7b8:	de b7       	in	r29, 0x3e	; 62
     7ba:	9c 83       	std	Y+4, r25	; 0x04
     7bc:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
     7be:	1a 82       	std	Y+2, r1	; 0x02
     7c0:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
     7c2:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
     7c6:	80 91 82 00 	lds	r24, 0x0082
     7ca:	90 91 83 00 	lds	r25, 0x0083
     7ce:	00 97       	sbiw	r24, 0x00	; 0
     7d0:	31 f4       	brne	.+12     	; 0x7de <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     7d2:	84 e8       	ldi	r24, 0x84	; 132
     7d4:	90 e0       	ldi	r25, 0x00	; 0
     7d6:	90 93 83 00 	sts	0x0083, r25
     7da:	80 93 82 00 	sts	0x0082, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
     7de:	8b 81       	ldd	r24, Y+3	; 0x03
     7e0:	9c 81       	ldd	r25, Y+4	; 0x04
     7e2:	00 97       	sbiw	r24, 0x00	; 0
     7e4:	99 f1       	breq	.+102    	; 0x84c <pvPortMalloc+0x9e>
     7e6:	80 91 80 00 	lds	r24, 0x0080
     7ea:	90 91 81 00 	lds	r25, 0x0081
     7ee:	2b 81       	ldd	r18, Y+3	; 0x03
     7f0:	3c 81       	ldd	r19, Y+4	; 0x04
     7f2:	82 0f       	add	r24, r18
     7f4:	93 1f       	adc	r25, r19
     7f6:	25 e0       	ldi	r18, 0x05	; 5
     7f8:	8b 3d       	cpi	r24, 0xDB	; 219
     7fa:	92 07       	cpc	r25, r18
     7fc:	38 f5       	brcc	.+78     	; 0x84c <pvPortMalloc+0x9e>
     7fe:	20 91 80 00 	lds	r18, 0x0080
     802:	30 91 81 00 	lds	r19, 0x0081
     806:	8b 81       	ldd	r24, Y+3	; 0x03
     808:	9c 81       	ldd	r25, Y+4	; 0x04
     80a:	28 0f       	add	r18, r24
     80c:	39 1f       	adc	r19, r25
     80e:	80 91 80 00 	lds	r24, 0x0080
     812:	90 91 81 00 	lds	r25, 0x0081
     816:	82 17       	cp	r24, r18
     818:	93 07       	cpc	r25, r19
     81a:	c0 f4       	brcc	.+48     	; 0x84c <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     81c:	20 91 82 00 	lds	r18, 0x0082
     820:	30 91 83 00 	lds	r19, 0x0083
     824:	80 91 80 00 	lds	r24, 0x0080
     828:	90 91 81 00 	lds	r25, 0x0081
     82c:	82 0f       	add	r24, r18
     82e:	93 1f       	adc	r25, r19
     830:	9a 83       	std	Y+2, r25	; 0x02
     832:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     834:	20 91 80 00 	lds	r18, 0x0080
     838:	30 91 81 00 	lds	r19, 0x0081
     83c:	8b 81       	ldd	r24, Y+3	; 0x03
     83e:	9c 81       	ldd	r25, Y+4	; 0x04
     840:	82 0f       	add	r24, r18
     842:	93 1f       	adc	r25, r19
     844:	90 93 81 00 	sts	0x0081, r25
     848:	80 93 80 00 	sts	0x0080, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     84c:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     850:	89 81       	ldd	r24, Y+1	; 0x01
     852:	9a 81       	ldd	r25, Y+2	; 0x02
}
     854:	0f 90       	pop	r0
     856:	0f 90       	pop	r0
     858:	0f 90       	pop	r0
     85a:	0f 90       	pop	r0
     85c:	cf 91       	pop	r28
     85e:	df 91       	pop	r29
     860:	08 95       	ret

00000862 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     862:	df 93       	push	r29
     864:	cf 93       	push	r28
     866:	00 d0       	rcall	.+0      	; 0x868 <vPortFree+0x6>
     868:	cd b7       	in	r28, 0x3d	; 61
     86a:	de b7       	in	r29, 0x3e	; 62
     86c:	9a 83       	std	Y+2, r25	; 0x02
     86e:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     870:	0f 90       	pop	r0
     872:	0f 90       	pop	r0
     874:	cf 91       	pop	r28
     876:	df 91       	pop	r29
     878:	08 95       	ret

0000087a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     87a:	df 93       	push	r29
     87c:	cf 93       	push	r28
     87e:	cd b7       	in	r28, 0x3d	; 61
     880:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     882:	10 92 81 00 	sts	0x0081, r1
     886:	10 92 80 00 	sts	0x0080, r1
}
     88a:	cf 91       	pop	r28
     88c:	df 91       	pop	r29
     88e:	08 95       	ret

00000890 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     890:	df 93       	push	r29
     892:	cf 93       	push	r28
     894:	cd b7       	in	r28, 0x3d	; 61
     896:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     898:	20 91 80 00 	lds	r18, 0x0080
     89c:	30 91 81 00 	lds	r19, 0x0081
     8a0:	8b ed       	ldi	r24, 0xDB	; 219
     8a2:	95 e0       	ldi	r25, 0x05	; 5
     8a4:	82 1b       	sub	r24, r18
     8a6:	93 0b       	sbc	r25, r19
}
     8a8:	cf 91       	pop	r28
     8aa:	df 91       	pop	r29
     8ac:	08 95       	ret

000008ae <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     8ae:	df 93       	push	r29
     8b0:	cf 93       	push	r28
     8b2:	00 d0       	rcall	.+0      	; 0x8b4 <vListInitialise+0x6>
     8b4:	cd b7       	in	r28, 0x3d	; 61
     8b6:	de b7       	in	r29, 0x3e	; 62
     8b8:	9a 83       	std	Y+2, r25	; 0x02
     8ba:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8bc:	89 81       	ldd	r24, Y+1	; 0x01
     8be:	9a 81       	ldd	r25, Y+2	; 0x02
     8c0:	03 96       	adiw	r24, 0x03	; 3
     8c2:	e9 81       	ldd	r30, Y+1	; 0x01
     8c4:	fa 81       	ldd	r31, Y+2	; 0x02
     8c6:	92 83       	std	Z+2, r25	; 0x02
     8c8:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
     8ca:	e9 81       	ldd	r30, Y+1	; 0x01
     8cc:	fa 81       	ldd	r31, Y+2	; 0x02
     8ce:	8f ef       	ldi	r24, 0xFF	; 255
     8d0:	9f ef       	ldi	r25, 0xFF	; 255
     8d2:	94 83       	std	Z+4, r25	; 0x04
     8d4:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8d6:	89 81       	ldd	r24, Y+1	; 0x01
     8d8:	9a 81       	ldd	r25, Y+2	; 0x02
     8da:	03 96       	adiw	r24, 0x03	; 3
     8dc:	e9 81       	ldd	r30, Y+1	; 0x01
     8de:	fa 81       	ldd	r31, Y+2	; 0x02
     8e0:	96 83       	std	Z+6, r25	; 0x06
     8e2:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     8e4:	89 81       	ldd	r24, Y+1	; 0x01
     8e6:	9a 81       	ldd	r25, Y+2	; 0x02
     8e8:	03 96       	adiw	r24, 0x03	; 3
     8ea:	e9 81       	ldd	r30, Y+1	; 0x01
     8ec:	fa 81       	ldd	r31, Y+2	; 0x02
     8ee:	90 87       	std	Z+8, r25	; 0x08
     8f0:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     8f2:	e9 81       	ldd	r30, Y+1	; 0x01
     8f4:	fa 81       	ldd	r31, Y+2	; 0x02
     8f6:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     8f8:	0f 90       	pop	r0
     8fa:	0f 90       	pop	r0
     8fc:	cf 91       	pop	r28
     8fe:	df 91       	pop	r29
     900:	08 95       	ret

00000902 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     902:	df 93       	push	r29
     904:	cf 93       	push	r28
     906:	00 d0       	rcall	.+0      	; 0x908 <vListInitialiseItem+0x6>
     908:	cd b7       	in	r28, 0x3d	; 61
     90a:	de b7       	in	r29, 0x3e	; 62
     90c:	9a 83       	std	Y+2, r25	; 0x02
     90e:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
     910:	e9 81       	ldd	r30, Y+1	; 0x01
     912:	fa 81       	ldd	r31, Y+2	; 0x02
     914:	11 86       	std	Z+9, r1	; 0x09
     916:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     918:	0f 90       	pop	r0
     91a:	0f 90       	pop	r0
     91c:	cf 91       	pop	r28
     91e:	df 91       	pop	r29
     920:	08 95       	ret

00000922 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
     922:	df 93       	push	r29
     924:	cf 93       	push	r28
     926:	00 d0       	rcall	.+0      	; 0x928 <vListInsertEnd+0x6>
     928:	00 d0       	rcall	.+0      	; 0x92a <vListInsertEnd+0x8>
     92a:	00 d0       	rcall	.+0      	; 0x92c <vListInsertEnd+0xa>
     92c:	cd b7       	in	r28, 0x3d	; 61
     92e:	de b7       	in	r29, 0x3e	; 62
     930:	9c 83       	std	Y+4, r25	; 0x04
     932:	8b 83       	std	Y+3, r24	; 0x03
     934:	7e 83       	std	Y+6, r23	; 0x06
     936:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
     938:	eb 81       	ldd	r30, Y+3	; 0x03
     93a:	fc 81       	ldd	r31, Y+4	; 0x04
     93c:	81 81       	ldd	r24, Z+1	; 0x01
     93e:	92 81       	ldd	r25, Z+2	; 0x02
     940:	9a 83       	std	Y+2, r25	; 0x02
     942:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
     944:	ed 81       	ldd	r30, Y+5	; 0x05
     946:	fe 81       	ldd	r31, Y+6	; 0x06
     948:	89 81       	ldd	r24, Y+1	; 0x01
     94a:	9a 81       	ldd	r25, Y+2	; 0x02
     94c:	93 83       	std	Z+3, r25	; 0x03
     94e:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     950:	e9 81       	ldd	r30, Y+1	; 0x01
     952:	fa 81       	ldd	r31, Y+2	; 0x02
     954:	84 81       	ldd	r24, Z+4	; 0x04
     956:	95 81       	ldd	r25, Z+5	; 0x05
     958:	ed 81       	ldd	r30, Y+5	; 0x05
     95a:	fe 81       	ldd	r31, Y+6	; 0x06
     95c:	95 83       	std	Z+5, r25	; 0x05
     95e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
     960:	e9 81       	ldd	r30, Y+1	; 0x01
     962:	fa 81       	ldd	r31, Y+2	; 0x02
     964:	04 80       	ldd	r0, Z+4	; 0x04
     966:	f5 81       	ldd	r31, Z+5	; 0x05
     968:	e0 2d       	mov	r30, r0
     96a:	8d 81       	ldd	r24, Y+5	; 0x05
     96c:	9e 81       	ldd	r25, Y+6	; 0x06
     96e:	93 83       	std	Z+3, r25	; 0x03
     970:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
     972:	e9 81       	ldd	r30, Y+1	; 0x01
     974:	fa 81       	ldd	r31, Y+2	; 0x02
     976:	8d 81       	ldd	r24, Y+5	; 0x05
     978:	9e 81       	ldd	r25, Y+6	; 0x06
     97a:	95 83       	std	Z+5, r25	; 0x05
     97c:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
     97e:	ed 81       	ldd	r30, Y+5	; 0x05
     980:	fe 81       	ldd	r31, Y+6	; 0x06
     982:	8b 81       	ldd	r24, Y+3	; 0x03
     984:	9c 81       	ldd	r25, Y+4	; 0x04
     986:	91 87       	std	Z+9, r25	; 0x09
     988:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     98a:	eb 81       	ldd	r30, Y+3	; 0x03
     98c:	fc 81       	ldd	r31, Y+4	; 0x04
     98e:	80 81       	ld	r24, Z
     990:	8f 5f       	subi	r24, 0xFF	; 255
     992:	eb 81       	ldd	r30, Y+3	; 0x03
     994:	fc 81       	ldd	r31, Y+4	; 0x04
     996:	80 83       	st	Z, r24
}
     998:	26 96       	adiw	r28, 0x06	; 6
     99a:	0f b6       	in	r0, 0x3f	; 63
     99c:	f8 94       	cli
     99e:	de bf       	out	0x3e, r29	; 62
     9a0:	0f be       	out	0x3f, r0	; 63
     9a2:	cd bf       	out	0x3d, r28	; 61
     9a4:	cf 91       	pop	r28
     9a6:	df 91       	pop	r29
     9a8:	08 95       	ret

000009aa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
     9aa:	df 93       	push	r29
     9ac:	cf 93       	push	r28
     9ae:	cd b7       	in	r28, 0x3d	; 61
     9b0:	de b7       	in	r29, 0x3e	; 62
     9b2:	28 97       	sbiw	r28, 0x08	; 8
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	de bf       	out	0x3e, r29	; 62
     9ba:	0f be       	out	0x3f, r0	; 63
     9bc:	cd bf       	out	0x3d, r28	; 61
     9be:	9e 83       	std	Y+6, r25	; 0x06
     9c0:	8d 83       	std	Y+5, r24	; 0x05
     9c2:	78 87       	std	Y+8, r23	; 0x08
     9c4:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     9c6:	ef 81       	ldd	r30, Y+7	; 0x07
     9c8:	f8 85       	ldd	r31, Y+8	; 0x08
     9ca:	80 81       	ld	r24, Z
     9cc:	91 81       	ldd	r25, Z+1	; 0x01
     9ce:	9a 83       	std	Y+2, r25	; 0x02
     9d0:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
     9d2:	89 81       	ldd	r24, Y+1	; 0x01
     9d4:	9a 81       	ldd	r25, Y+2	; 0x02
     9d6:	2f ef       	ldi	r18, 0xFF	; 255
     9d8:	8f 3f       	cpi	r24, 0xFF	; 255
     9da:	92 07       	cpc	r25, r18
     9dc:	39 f4       	brne	.+14     	; 0x9ec <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
     9de:	ed 81       	ldd	r30, Y+5	; 0x05
     9e0:	fe 81       	ldd	r31, Y+6	; 0x06
     9e2:	87 81       	ldd	r24, Z+7	; 0x07
     9e4:	90 85       	ldd	r25, Z+8	; 0x08
     9e6:	9c 83       	std	Y+4, r25	; 0x04
     9e8:	8b 83       	std	Y+3, r24	; 0x03
     9ea:	18 c0       	rjmp	.+48     	; 0xa1c <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     9ec:	8d 81       	ldd	r24, Y+5	; 0x05
     9ee:	9e 81       	ldd	r25, Y+6	; 0x06
     9f0:	03 96       	adiw	r24, 0x03	; 3
     9f2:	9c 83       	std	Y+4, r25	; 0x04
     9f4:	8b 83       	std	Y+3, r24	; 0x03
     9f6:	06 c0       	rjmp	.+12     	; 0xa04 <vListInsert+0x5a>
     9f8:	eb 81       	ldd	r30, Y+3	; 0x03
     9fa:	fc 81       	ldd	r31, Y+4	; 0x04
     9fc:	82 81       	ldd	r24, Z+2	; 0x02
     9fe:	93 81       	ldd	r25, Z+3	; 0x03
     a00:	9c 83       	std	Y+4, r25	; 0x04
     a02:	8b 83       	std	Y+3, r24	; 0x03
     a04:	eb 81       	ldd	r30, Y+3	; 0x03
     a06:	fc 81       	ldd	r31, Y+4	; 0x04
     a08:	02 80       	ldd	r0, Z+2	; 0x02
     a0a:	f3 81       	ldd	r31, Z+3	; 0x03
     a0c:	e0 2d       	mov	r30, r0
     a0e:	20 81       	ld	r18, Z
     a10:	31 81       	ldd	r19, Z+1	; 0x01
     a12:	89 81       	ldd	r24, Y+1	; 0x01
     a14:	9a 81       	ldd	r25, Y+2	; 0x02
     a16:	82 17       	cp	r24, r18
     a18:	93 07       	cpc	r25, r19
     a1a:	70 f7       	brcc	.-36     	; 0x9f8 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
     a1c:	eb 81       	ldd	r30, Y+3	; 0x03
     a1e:	fc 81       	ldd	r31, Y+4	; 0x04
     a20:	82 81       	ldd	r24, Z+2	; 0x02
     a22:	93 81       	ldd	r25, Z+3	; 0x03
     a24:	ef 81       	ldd	r30, Y+7	; 0x07
     a26:	f8 85       	ldd	r31, Y+8	; 0x08
     a28:	93 83       	std	Z+3, r25	; 0x03
     a2a:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a2c:	ef 81       	ldd	r30, Y+7	; 0x07
     a2e:	f8 85       	ldd	r31, Y+8	; 0x08
     a30:	02 80       	ldd	r0, Z+2	; 0x02
     a32:	f3 81       	ldd	r31, Z+3	; 0x03
     a34:	e0 2d       	mov	r30, r0
     a36:	8f 81       	ldd	r24, Y+7	; 0x07
     a38:	98 85       	ldd	r25, Y+8	; 0x08
     a3a:	95 83       	std	Z+5, r25	; 0x05
     a3c:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
     a3e:	ef 81       	ldd	r30, Y+7	; 0x07
     a40:	f8 85       	ldd	r31, Y+8	; 0x08
     a42:	8b 81       	ldd	r24, Y+3	; 0x03
     a44:	9c 81       	ldd	r25, Y+4	; 0x04
     a46:	95 83       	std	Z+5, r25	; 0x05
     a48:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
     a4a:	eb 81       	ldd	r30, Y+3	; 0x03
     a4c:	fc 81       	ldd	r31, Y+4	; 0x04
     a4e:	8f 81       	ldd	r24, Y+7	; 0x07
     a50:	98 85       	ldd	r25, Y+8	; 0x08
     a52:	93 83       	std	Z+3, r25	; 0x03
     a54:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
     a56:	ef 81       	ldd	r30, Y+7	; 0x07
     a58:	f8 85       	ldd	r31, Y+8	; 0x08
     a5a:	8d 81       	ldd	r24, Y+5	; 0x05
     a5c:	9e 81       	ldd	r25, Y+6	; 0x06
     a5e:	91 87       	std	Z+9, r25	; 0x09
     a60:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
     a62:	ed 81       	ldd	r30, Y+5	; 0x05
     a64:	fe 81       	ldd	r31, Y+6	; 0x06
     a66:	80 81       	ld	r24, Z
     a68:	8f 5f       	subi	r24, 0xFF	; 255
     a6a:	ed 81       	ldd	r30, Y+5	; 0x05
     a6c:	fe 81       	ldd	r31, Y+6	; 0x06
     a6e:	80 83       	st	Z, r24
}
     a70:	28 96       	adiw	r28, 0x08	; 8
     a72:	0f b6       	in	r0, 0x3f	; 63
     a74:	f8 94       	cli
     a76:	de bf       	out	0x3e, r29	; 62
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	cd bf       	out	0x3d, r28	; 61
     a7c:	cf 91       	pop	r28
     a7e:	df 91       	pop	r29
     a80:	08 95       	ret

00000a82 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a82:	df 93       	push	r29
     a84:	cf 93       	push	r28
     a86:	00 d0       	rcall	.+0      	; 0xa88 <uxListRemove+0x6>
     a88:	00 d0       	rcall	.+0      	; 0xa8a <uxListRemove+0x8>
     a8a:	cd b7       	in	r28, 0x3d	; 61
     a8c:	de b7       	in	r29, 0x3e	; 62
     a8e:	9c 83       	std	Y+4, r25	; 0x04
     a90:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
     a92:	eb 81       	ldd	r30, Y+3	; 0x03
     a94:	fc 81       	ldd	r31, Y+4	; 0x04
     a96:	80 85       	ldd	r24, Z+8	; 0x08
     a98:	91 85       	ldd	r25, Z+9	; 0x09
     a9a:	9a 83       	std	Y+2, r25	; 0x02
     a9c:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a9e:	eb 81       	ldd	r30, Y+3	; 0x03
     aa0:	fc 81       	ldd	r31, Y+4	; 0x04
     aa2:	a2 81       	ldd	r26, Z+2	; 0x02
     aa4:	b3 81       	ldd	r27, Z+3	; 0x03
     aa6:	eb 81       	ldd	r30, Y+3	; 0x03
     aa8:	fc 81       	ldd	r31, Y+4	; 0x04
     aaa:	84 81       	ldd	r24, Z+4	; 0x04
     aac:	95 81       	ldd	r25, Z+5	; 0x05
     aae:	15 96       	adiw	r26, 0x05	; 5
     ab0:	9c 93       	st	X, r25
     ab2:	8e 93       	st	-X, r24
     ab4:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ab6:	eb 81       	ldd	r30, Y+3	; 0x03
     ab8:	fc 81       	ldd	r31, Y+4	; 0x04
     aba:	a4 81       	ldd	r26, Z+4	; 0x04
     abc:	b5 81       	ldd	r27, Z+5	; 0x05
     abe:	eb 81       	ldd	r30, Y+3	; 0x03
     ac0:	fc 81       	ldd	r31, Y+4	; 0x04
     ac2:	82 81       	ldd	r24, Z+2	; 0x02
     ac4:	93 81       	ldd	r25, Z+3	; 0x03
     ac6:	13 96       	adiw	r26, 0x03	; 3
     ac8:	9c 93       	st	X, r25
     aca:	8e 93       	st	-X, r24
     acc:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
     ace:	e9 81       	ldd	r30, Y+1	; 0x01
     ad0:	fa 81       	ldd	r31, Y+2	; 0x02
     ad2:	21 81       	ldd	r18, Z+1	; 0x01
     ad4:	32 81       	ldd	r19, Z+2	; 0x02
     ad6:	8b 81       	ldd	r24, Y+3	; 0x03
     ad8:	9c 81       	ldd	r25, Y+4	; 0x04
     ada:	28 17       	cp	r18, r24
     adc:	39 07       	cpc	r19, r25
     ade:	41 f4       	brne	.+16     	; 0xaf0 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
     ae0:	eb 81       	ldd	r30, Y+3	; 0x03
     ae2:	fc 81       	ldd	r31, Y+4	; 0x04
     ae4:	84 81       	ldd	r24, Z+4	; 0x04
     ae6:	95 81       	ldd	r25, Z+5	; 0x05
     ae8:	e9 81       	ldd	r30, Y+1	; 0x01
     aea:	fa 81       	ldd	r31, Y+2	; 0x02
     aec:	92 83       	std	Z+2, r25	; 0x02
     aee:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
     af0:	eb 81       	ldd	r30, Y+3	; 0x03
     af2:	fc 81       	ldd	r31, Y+4	; 0x04
     af4:	11 86       	std	Z+9, r1	; 0x09
     af6:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
     af8:	e9 81       	ldd	r30, Y+1	; 0x01
     afa:	fa 81       	ldd	r31, Y+2	; 0x02
     afc:	80 81       	ld	r24, Z
     afe:	81 50       	subi	r24, 0x01	; 1
     b00:	e9 81       	ldd	r30, Y+1	; 0x01
     b02:	fa 81       	ldd	r31, Y+2	; 0x02
     b04:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
     b06:	e9 81       	ldd	r30, Y+1	; 0x01
     b08:	fa 81       	ldd	r31, Y+2	; 0x02
     b0a:	80 81       	ld	r24, Z
}
     b0c:	0f 90       	pop	r0
     b0e:	0f 90       	pop	r0
     b10:	0f 90       	pop	r0
     b12:	0f 90       	pop	r0
     b14:	cf 91       	pop	r28
     b16:	df 91       	pop	r29
     b18:	08 95       	ret

00000b1a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     b1a:	df 93       	push	r29
     b1c:	cf 93       	push	r28
     b1e:	cd b7       	in	r28, 0x3d	; 61
     b20:	de b7       	in	r29, 0x3e	; 62
     b22:	28 97       	sbiw	r28, 0x08	; 8
     b24:	0f b6       	in	r0, 0x3f	; 63
     b26:	f8 94       	cli
     b28:	de bf       	out	0x3e, r29	; 62
     b2a:	0f be       	out	0x3f, r0	; 63
     b2c:	cd bf       	out	0x3d, r28	; 61
     b2e:	9c 83       	std	Y+4, r25	; 0x04
     b30:	8b 83       	std	Y+3, r24	; 0x03
     b32:	7e 83       	std	Y+6, r23	; 0x06
     b34:	6d 83       	std	Y+5, r22	; 0x05
     b36:	58 87       	std	Y+8, r21	; 0x08
     b38:	4f 83       	std	Y+7, r20	; 0x07
	uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     b3a:	eb 81       	ldd	r30, Y+3	; 0x03
     b3c:	fc 81       	ldd	r31, Y+4	; 0x04
     b3e:	81 e1       	ldi	r24, 0x11	; 17
     b40:	80 83       	st	Z, r24
	pxTopOfStack--;
     b42:	8b 81       	ldd	r24, Y+3	; 0x03
     b44:	9c 81       	ldd	r25, Y+4	; 0x04
     b46:	01 97       	sbiw	r24, 0x01	; 1
     b48:	9c 83       	std	Y+4, r25	; 0x04
     b4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     b4c:	eb 81       	ldd	r30, Y+3	; 0x03
     b4e:	fc 81       	ldd	r31, Y+4	; 0x04
     b50:	82 e2       	ldi	r24, 0x22	; 34
     b52:	80 83       	st	Z, r24
	pxTopOfStack--;
     b54:	8b 81       	ldd	r24, Y+3	; 0x03
     b56:	9c 81       	ldd	r25, Y+4	; 0x04
     b58:	01 97       	sbiw	r24, 0x01	; 1
     b5a:	9c 83       	std	Y+4, r25	; 0x04
     b5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     b5e:	eb 81       	ldd	r30, Y+3	; 0x03
     b60:	fc 81       	ldd	r31, Y+4	; 0x04
     b62:	83 e3       	ldi	r24, 0x33	; 51
     b64:	80 83       	st	Z, r24
	pxTopOfStack--;
     b66:	8b 81       	ldd	r24, Y+3	; 0x03
     b68:	9c 81       	ldd	r25, Y+4	; 0x04
     b6a:	01 97       	sbiw	r24, 0x01	; 1
     b6c:	9c 83       	std	Y+4, r25	; 0x04
     b6e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     b70:	8d 81       	ldd	r24, Y+5	; 0x05
     b72:	9e 81       	ldd	r25, Y+6	; 0x06
     b74:	9a 83       	std	Y+2, r25	; 0x02
     b76:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     b78:	89 81       	ldd	r24, Y+1	; 0x01
     b7a:	eb 81       	ldd	r30, Y+3	; 0x03
     b7c:	fc 81       	ldd	r31, Y+4	; 0x04
     b7e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b80:	8b 81       	ldd	r24, Y+3	; 0x03
     b82:	9c 81       	ldd	r25, Y+4	; 0x04
     b84:	01 97       	sbiw	r24, 0x01	; 1
     b86:	9c 83       	std	Y+4, r25	; 0x04
     b88:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     b8a:	89 81       	ldd	r24, Y+1	; 0x01
     b8c:	9a 81       	ldd	r25, Y+2	; 0x02
     b8e:	89 2f       	mov	r24, r25
     b90:	99 27       	eor	r25, r25
     b92:	9a 83       	std	Y+2, r25	; 0x02
     b94:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     b96:	89 81       	ldd	r24, Y+1	; 0x01
     b98:	eb 81       	ldd	r30, Y+3	; 0x03
     b9a:	fc 81       	ldd	r31, Y+4	; 0x04
     b9c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ba0:	9c 81       	ldd	r25, Y+4	; 0x04
     ba2:	01 97       	sbiw	r24, 0x01	; 1
     ba4:	9c 83       	std	Y+4, r25	; 0x04
     ba6:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     ba8:	eb 81       	ldd	r30, Y+3	; 0x03
     baa:	fc 81       	ldd	r31, Y+4	; 0x04
     bac:	10 82       	st	Z, r1
	pxTopOfStack--;
     bae:	8b 81       	ldd	r24, Y+3	; 0x03
     bb0:	9c 81       	ldd	r25, Y+4	; 0x04
     bb2:	01 97       	sbiw	r24, 0x01	; 1
     bb4:	9c 83       	std	Y+4, r25	; 0x04
     bb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     bb8:	eb 81       	ldd	r30, Y+3	; 0x03
     bba:	fc 81       	ldd	r31, Y+4	; 0x04
     bbc:	80 e8       	ldi	r24, 0x80	; 128
     bbe:	80 83       	st	Z, r24
	pxTopOfStack--;
     bc0:	8b 81       	ldd	r24, Y+3	; 0x03
     bc2:	9c 81       	ldd	r25, Y+4	; 0x04
     bc4:	01 97       	sbiw	r24, 0x01	; 1
     bc6:	9c 83       	std	Y+4, r25	; 0x04
     bc8:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     bca:	eb 81       	ldd	r30, Y+3	; 0x03
     bcc:	fc 81       	ldd	r31, Y+4	; 0x04
     bce:	10 82       	st	Z, r1
	pxTopOfStack--;
     bd0:	8b 81       	ldd	r24, Y+3	; 0x03
     bd2:	9c 81       	ldd	r25, Y+4	; 0x04
     bd4:	01 97       	sbiw	r24, 0x01	; 1
     bd6:	9c 83       	std	Y+4, r25	; 0x04
     bd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     bda:	eb 81       	ldd	r30, Y+3	; 0x03
     bdc:	fc 81       	ldd	r31, Y+4	; 0x04
     bde:	82 e0       	ldi	r24, 0x02	; 2
     be0:	80 83       	st	Z, r24
	pxTopOfStack--;
     be2:	8b 81       	ldd	r24, Y+3	; 0x03
     be4:	9c 81       	ldd	r25, Y+4	; 0x04
     be6:	01 97       	sbiw	r24, 0x01	; 1
     be8:	9c 83       	std	Y+4, r25	; 0x04
     bea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     bec:	eb 81       	ldd	r30, Y+3	; 0x03
     bee:	fc 81       	ldd	r31, Y+4	; 0x04
     bf0:	83 e0       	ldi	r24, 0x03	; 3
     bf2:	80 83       	st	Z, r24
	pxTopOfStack--;
     bf4:	8b 81       	ldd	r24, Y+3	; 0x03
     bf6:	9c 81       	ldd	r25, Y+4	; 0x04
     bf8:	01 97       	sbiw	r24, 0x01	; 1
     bfa:	9c 83       	std	Y+4, r25	; 0x04
     bfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     bfe:	eb 81       	ldd	r30, Y+3	; 0x03
     c00:	fc 81       	ldd	r31, Y+4	; 0x04
     c02:	84 e0       	ldi	r24, 0x04	; 4
     c04:	80 83       	st	Z, r24
	pxTopOfStack--;
     c06:	8b 81       	ldd	r24, Y+3	; 0x03
     c08:	9c 81       	ldd	r25, Y+4	; 0x04
     c0a:	01 97       	sbiw	r24, 0x01	; 1
     c0c:	9c 83       	std	Y+4, r25	; 0x04
     c0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     c10:	eb 81       	ldd	r30, Y+3	; 0x03
     c12:	fc 81       	ldd	r31, Y+4	; 0x04
     c14:	85 e0       	ldi	r24, 0x05	; 5
     c16:	80 83       	st	Z, r24
	pxTopOfStack--;
     c18:	8b 81       	ldd	r24, Y+3	; 0x03
     c1a:	9c 81       	ldd	r25, Y+4	; 0x04
     c1c:	01 97       	sbiw	r24, 0x01	; 1
     c1e:	9c 83       	std	Y+4, r25	; 0x04
     c20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     c22:	eb 81       	ldd	r30, Y+3	; 0x03
     c24:	fc 81       	ldd	r31, Y+4	; 0x04
     c26:	86 e0       	ldi	r24, 0x06	; 6
     c28:	80 83       	st	Z, r24
	pxTopOfStack--;
     c2a:	8b 81       	ldd	r24, Y+3	; 0x03
     c2c:	9c 81       	ldd	r25, Y+4	; 0x04
     c2e:	01 97       	sbiw	r24, 0x01	; 1
     c30:	9c 83       	std	Y+4, r25	; 0x04
     c32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     c34:	eb 81       	ldd	r30, Y+3	; 0x03
     c36:	fc 81       	ldd	r31, Y+4	; 0x04
     c38:	87 e0       	ldi	r24, 0x07	; 7
     c3a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c3c:	8b 81       	ldd	r24, Y+3	; 0x03
     c3e:	9c 81       	ldd	r25, Y+4	; 0x04
     c40:	01 97       	sbiw	r24, 0x01	; 1
     c42:	9c 83       	std	Y+4, r25	; 0x04
     c44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     c46:	eb 81       	ldd	r30, Y+3	; 0x03
     c48:	fc 81       	ldd	r31, Y+4	; 0x04
     c4a:	88 e0       	ldi	r24, 0x08	; 8
     c4c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c4e:	8b 81       	ldd	r24, Y+3	; 0x03
     c50:	9c 81       	ldd	r25, Y+4	; 0x04
     c52:	01 97       	sbiw	r24, 0x01	; 1
     c54:	9c 83       	std	Y+4, r25	; 0x04
     c56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     c58:	eb 81       	ldd	r30, Y+3	; 0x03
     c5a:	fc 81       	ldd	r31, Y+4	; 0x04
     c5c:	89 e0       	ldi	r24, 0x09	; 9
     c5e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c60:	8b 81       	ldd	r24, Y+3	; 0x03
     c62:	9c 81       	ldd	r25, Y+4	; 0x04
     c64:	01 97       	sbiw	r24, 0x01	; 1
     c66:	9c 83       	std	Y+4, r25	; 0x04
     c68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     c6a:	eb 81       	ldd	r30, Y+3	; 0x03
     c6c:	fc 81       	ldd	r31, Y+4	; 0x04
     c6e:	80 e1       	ldi	r24, 0x10	; 16
     c70:	80 83       	st	Z, r24
	pxTopOfStack--;
     c72:	8b 81       	ldd	r24, Y+3	; 0x03
     c74:	9c 81       	ldd	r25, Y+4	; 0x04
     c76:	01 97       	sbiw	r24, 0x01	; 1
     c78:	9c 83       	std	Y+4, r25	; 0x04
     c7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     c7c:	eb 81       	ldd	r30, Y+3	; 0x03
     c7e:	fc 81       	ldd	r31, Y+4	; 0x04
     c80:	81 e1       	ldi	r24, 0x11	; 17
     c82:	80 83       	st	Z, r24
	pxTopOfStack--;
     c84:	8b 81       	ldd	r24, Y+3	; 0x03
     c86:	9c 81       	ldd	r25, Y+4	; 0x04
     c88:	01 97       	sbiw	r24, 0x01	; 1
     c8a:	9c 83       	std	Y+4, r25	; 0x04
     c8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     c8e:	eb 81       	ldd	r30, Y+3	; 0x03
     c90:	fc 81       	ldd	r31, Y+4	; 0x04
     c92:	82 e1       	ldi	r24, 0x12	; 18
     c94:	80 83       	st	Z, r24
	pxTopOfStack--;
     c96:	8b 81       	ldd	r24, Y+3	; 0x03
     c98:	9c 81       	ldd	r25, Y+4	; 0x04
     c9a:	01 97       	sbiw	r24, 0x01	; 1
     c9c:	9c 83       	std	Y+4, r25	; 0x04
     c9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     ca0:	eb 81       	ldd	r30, Y+3	; 0x03
     ca2:	fc 81       	ldd	r31, Y+4	; 0x04
     ca4:	83 e1       	ldi	r24, 0x13	; 19
     ca6:	80 83       	st	Z, r24
	pxTopOfStack--;
     ca8:	8b 81       	ldd	r24, Y+3	; 0x03
     caa:	9c 81       	ldd	r25, Y+4	; 0x04
     cac:	01 97       	sbiw	r24, 0x01	; 1
     cae:	9c 83       	std	Y+4, r25	; 0x04
     cb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     cb2:	eb 81       	ldd	r30, Y+3	; 0x03
     cb4:	fc 81       	ldd	r31, Y+4	; 0x04
     cb6:	84 e1       	ldi	r24, 0x14	; 20
     cb8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cba:	8b 81       	ldd	r24, Y+3	; 0x03
     cbc:	9c 81       	ldd	r25, Y+4	; 0x04
     cbe:	01 97       	sbiw	r24, 0x01	; 1
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     cc4:	eb 81       	ldd	r30, Y+3	; 0x03
     cc6:	fc 81       	ldd	r31, Y+4	; 0x04
     cc8:	85 e1       	ldi	r24, 0x15	; 21
     cca:	80 83       	st	Z, r24
	pxTopOfStack--;
     ccc:	8b 81       	ldd	r24, Y+3	; 0x03
     cce:	9c 81       	ldd	r25, Y+4	; 0x04
     cd0:	01 97       	sbiw	r24, 0x01	; 1
     cd2:	9c 83       	std	Y+4, r25	; 0x04
     cd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     cd6:	eb 81       	ldd	r30, Y+3	; 0x03
     cd8:	fc 81       	ldd	r31, Y+4	; 0x04
     cda:	86 e1       	ldi	r24, 0x16	; 22
     cdc:	80 83       	st	Z, r24
	pxTopOfStack--;
     cde:	8b 81       	ldd	r24, Y+3	; 0x03
     ce0:	9c 81       	ldd	r25, Y+4	; 0x04
     ce2:	01 97       	sbiw	r24, 0x01	; 1
     ce4:	9c 83       	std	Y+4, r25	; 0x04
     ce6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     ce8:	eb 81       	ldd	r30, Y+3	; 0x03
     cea:	fc 81       	ldd	r31, Y+4	; 0x04
     cec:	87 e1       	ldi	r24, 0x17	; 23
     cee:	80 83       	st	Z, r24
	pxTopOfStack--;
     cf0:	8b 81       	ldd	r24, Y+3	; 0x03
     cf2:	9c 81       	ldd	r25, Y+4	; 0x04
     cf4:	01 97       	sbiw	r24, 0x01	; 1
     cf6:	9c 83       	std	Y+4, r25	; 0x04
     cf8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     cfa:	eb 81       	ldd	r30, Y+3	; 0x03
     cfc:	fc 81       	ldd	r31, Y+4	; 0x04
     cfe:	88 e1       	ldi	r24, 0x18	; 24
     d00:	80 83       	st	Z, r24
	pxTopOfStack--;
     d02:	8b 81       	ldd	r24, Y+3	; 0x03
     d04:	9c 81       	ldd	r25, Y+4	; 0x04
     d06:	01 97       	sbiw	r24, 0x01	; 1
     d08:	9c 83       	std	Y+4, r25	; 0x04
     d0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     d0c:	eb 81       	ldd	r30, Y+3	; 0x03
     d0e:	fc 81       	ldd	r31, Y+4	; 0x04
     d10:	89 e1       	ldi	r24, 0x19	; 25
     d12:	80 83       	st	Z, r24
	pxTopOfStack--;
     d14:	8b 81       	ldd	r24, Y+3	; 0x03
     d16:	9c 81       	ldd	r25, Y+4	; 0x04
     d18:	01 97       	sbiw	r24, 0x01	; 1
     d1a:	9c 83       	std	Y+4, r25	; 0x04
     d1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     d1e:	eb 81       	ldd	r30, Y+3	; 0x03
     d20:	fc 81       	ldd	r31, Y+4	; 0x04
     d22:	80 e2       	ldi	r24, 0x20	; 32
     d24:	80 83       	st	Z, r24
	pxTopOfStack--;
     d26:	8b 81       	ldd	r24, Y+3	; 0x03
     d28:	9c 81       	ldd	r25, Y+4	; 0x04
     d2a:	01 97       	sbiw	r24, 0x01	; 1
     d2c:	9c 83       	std	Y+4, r25	; 0x04
     d2e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     d30:	eb 81       	ldd	r30, Y+3	; 0x03
     d32:	fc 81       	ldd	r31, Y+4	; 0x04
     d34:	81 e2       	ldi	r24, 0x21	; 33
     d36:	80 83       	st	Z, r24
	pxTopOfStack--;
     d38:	8b 81       	ldd	r24, Y+3	; 0x03
     d3a:	9c 81       	ldd	r25, Y+4	; 0x04
     d3c:	01 97       	sbiw	r24, 0x01	; 1
     d3e:	9c 83       	std	Y+4, r25	; 0x04
     d40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     d42:	eb 81       	ldd	r30, Y+3	; 0x03
     d44:	fc 81       	ldd	r31, Y+4	; 0x04
     d46:	82 e2       	ldi	r24, 0x22	; 34
     d48:	80 83       	st	Z, r24
	pxTopOfStack--;
     d4a:	8b 81       	ldd	r24, Y+3	; 0x03
     d4c:	9c 81       	ldd	r25, Y+4	; 0x04
     d4e:	01 97       	sbiw	r24, 0x01	; 1
     d50:	9c 83       	std	Y+4, r25	; 0x04
     d52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     d54:	eb 81       	ldd	r30, Y+3	; 0x03
     d56:	fc 81       	ldd	r31, Y+4	; 0x04
     d58:	83 e2       	ldi	r24, 0x23	; 35
     d5a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d5c:	8b 81       	ldd	r24, Y+3	; 0x03
     d5e:	9c 81       	ldd	r25, Y+4	; 0x04
     d60:	01 97       	sbiw	r24, 0x01	; 1
     d62:	9c 83       	std	Y+4, r25	; 0x04
     d64:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     d66:	8f 81       	ldd	r24, Y+7	; 0x07
     d68:	98 85       	ldd	r25, Y+8	; 0x08
     d6a:	9a 83       	std	Y+2, r25	; 0x02
     d6c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d6e:	89 81       	ldd	r24, Y+1	; 0x01
     d70:	eb 81       	ldd	r30, Y+3	; 0x03
     d72:	fc 81       	ldd	r31, Y+4	; 0x04
     d74:	80 83       	st	Z, r24
	pxTopOfStack--;
     d76:	8b 81       	ldd	r24, Y+3	; 0x03
     d78:	9c 81       	ldd	r25, Y+4	; 0x04
     d7a:	01 97       	sbiw	r24, 0x01	; 1
     d7c:	9c 83       	std	Y+4, r25	; 0x04
     d7e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     d80:	89 81       	ldd	r24, Y+1	; 0x01
     d82:	9a 81       	ldd	r25, Y+2	; 0x02
     d84:	89 2f       	mov	r24, r25
     d86:	99 27       	eor	r25, r25
     d88:	9a 83       	std	Y+2, r25	; 0x02
     d8a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     d8c:	89 81       	ldd	r24, Y+1	; 0x01
     d8e:	eb 81       	ldd	r30, Y+3	; 0x03
     d90:	fc 81       	ldd	r31, Y+4	; 0x04
     d92:	80 83       	st	Z, r24
	pxTopOfStack--;
     d94:	8b 81       	ldd	r24, Y+3	; 0x03
     d96:	9c 81       	ldd	r25, Y+4	; 0x04
     d98:	01 97       	sbiw	r24, 0x01	; 1
     d9a:	9c 83       	std	Y+4, r25	; 0x04
     d9c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     d9e:	eb 81       	ldd	r30, Y+3	; 0x03
     da0:	fc 81       	ldd	r31, Y+4	; 0x04
     da2:	86 e2       	ldi	r24, 0x26	; 38
     da4:	80 83       	st	Z, r24
	pxTopOfStack--;
     da6:	8b 81       	ldd	r24, Y+3	; 0x03
     da8:	9c 81       	ldd	r25, Y+4	; 0x04
     daa:	01 97       	sbiw	r24, 0x01	; 1
     dac:	9c 83       	std	Y+4, r25	; 0x04
     dae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     db0:	eb 81       	ldd	r30, Y+3	; 0x03
     db2:	fc 81       	ldd	r31, Y+4	; 0x04
     db4:	87 e2       	ldi	r24, 0x27	; 39
     db6:	80 83       	st	Z, r24
	pxTopOfStack--;
     db8:	8b 81       	ldd	r24, Y+3	; 0x03
     dba:	9c 81       	ldd	r25, Y+4	; 0x04
     dbc:	01 97       	sbiw	r24, 0x01	; 1
     dbe:	9c 83       	std	Y+4, r25	; 0x04
     dc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     dc2:	eb 81       	ldd	r30, Y+3	; 0x03
     dc4:	fc 81       	ldd	r31, Y+4	; 0x04
     dc6:	88 e2       	ldi	r24, 0x28	; 40
     dc8:	80 83       	st	Z, r24
	pxTopOfStack--;
     dca:	8b 81       	ldd	r24, Y+3	; 0x03
     dcc:	9c 81       	ldd	r25, Y+4	; 0x04
     dce:	01 97       	sbiw	r24, 0x01	; 1
     dd0:	9c 83       	std	Y+4, r25	; 0x04
     dd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     dd4:	eb 81       	ldd	r30, Y+3	; 0x03
     dd6:	fc 81       	ldd	r31, Y+4	; 0x04
     dd8:	89 e2       	ldi	r24, 0x29	; 41
     dda:	80 83       	st	Z, r24
	pxTopOfStack--;
     ddc:	8b 81       	ldd	r24, Y+3	; 0x03
     dde:	9c 81       	ldd	r25, Y+4	; 0x04
     de0:	01 97       	sbiw	r24, 0x01	; 1
     de2:	9c 83       	std	Y+4, r25	; 0x04
     de4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     de6:	eb 81       	ldd	r30, Y+3	; 0x03
     de8:	fc 81       	ldd	r31, Y+4	; 0x04
     dea:	80 e3       	ldi	r24, 0x30	; 48
     dec:	80 83       	st	Z, r24
	pxTopOfStack--;
     dee:	8b 81       	ldd	r24, Y+3	; 0x03
     df0:	9c 81       	ldd	r25, Y+4	; 0x04
     df2:	01 97       	sbiw	r24, 0x01	; 1
     df4:	9c 83       	std	Y+4, r25	; 0x04
     df6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     df8:	eb 81       	ldd	r30, Y+3	; 0x03
     dfa:	fc 81       	ldd	r31, Y+4	; 0x04
     dfc:	81 e3       	ldi	r24, 0x31	; 49
     dfe:	80 83       	st	Z, r24
	pxTopOfStack--;
     e00:	8b 81       	ldd	r24, Y+3	; 0x03
     e02:	9c 81       	ldd	r25, Y+4	; 0x04
     e04:	01 97       	sbiw	r24, 0x01	; 1
     e06:	9c 83       	std	Y+4, r25	; 0x04
     e08:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     e0a:	8b 81       	ldd	r24, Y+3	; 0x03
     e0c:	9c 81       	ldd	r25, Y+4	; 0x04
}
     e0e:	28 96       	adiw	r28, 0x08	; 8
     e10:	0f b6       	in	r0, 0x3f	; 63
     e12:	f8 94       	cli
     e14:	de bf       	out	0x3e, r29	; 62
     e16:	0f be       	out	0x3f, r0	; 63
     e18:	cd bf       	out	0x3d, r28	; 61
     e1a:	cf 91       	pop	r28
     e1c:	df 91       	pop	r29
     e1e:	08 95       	ret

00000e20 <xPortStartScheduler>:
/*-----------------------------------------------------------*/
void setupTimer1Interrupt(void);

BaseType_t xPortStartScheduler( void )
{
     e20:	df 93       	push	r29
     e22:	cf 93       	push	r28
     e24:	cd b7       	in	r28, 0x3d	; 61
     e26:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	//prvSetupTimerInterrupt();

	setupTimer1Interrupt();
     e28:	0e 94 45 07 	call	0xe8a	; 0xe8a <setupTimer1Interrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     e2c:	a0 91 60 06 	lds	r26, 0x0660
     e30:	b0 91 61 06 	lds	r27, 0x0661
     e34:	cd 91       	ld	r28, X+
     e36:	cd bf       	out	0x3d, r28	; 61
     e38:	dd 91       	ld	r29, X+
     e3a:	de bf       	out	0x3e, r29	; 62
     e3c:	ff 91       	pop	r31
     e3e:	ef 91       	pop	r30
     e40:	df 91       	pop	r29
     e42:	cf 91       	pop	r28
     e44:	bf 91       	pop	r27
     e46:	af 91       	pop	r26
     e48:	9f 91       	pop	r25
     e4a:	8f 91       	pop	r24
     e4c:	7f 91       	pop	r23
     e4e:	6f 91       	pop	r22
     e50:	5f 91       	pop	r21
     e52:	4f 91       	pop	r20
     e54:	3f 91       	pop	r19
     e56:	2f 91       	pop	r18
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	ff 90       	pop	r15
     e5e:	ef 90       	pop	r14
     e60:	df 90       	pop	r13
     e62:	cf 90       	pop	r12
     e64:	bf 90       	pop	r11
     e66:	af 90       	pop	r10
     e68:	9f 90       	pop	r9
     e6a:	8f 90       	pop	r8
     e6c:	7f 90       	pop	r7
     e6e:	6f 90       	pop	r6
     e70:	5f 90       	pop	r5
     e72:	4f 90       	pop	r4
     e74:	3f 90       	pop	r3
     e76:	2f 90       	pop	r2
     e78:	1f 90       	pop	r1
     e7a:	0f 90       	pop	r0
     e7c:	0f be       	out	0x3f, r0	; 63
     e7e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     e80:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     e82:	81 e0       	ldi	r24, 0x01	; 1
}
     e84:	cf 91       	pop	r28
     e86:	df 91       	pop	r29
     e88:	08 95       	ret

00000e8a <setupTimer1Interrupt>:
/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */

void setupTimer1Interrupt(void)
{
     e8a:	df 93       	push	r29
     e8c:	cf 93       	push	r28
     e8e:	cd b7       	in	r28, 0x3d	; 61
     e90:	de b7       	in	r29, 0x3e	; 62
	Timer1_enuSetMode(Timer1_enuCTC);
     e92:	85 e0       	ldi	r24, 0x05	; 5
     e94:	0e 94 df 33 	call	0x67be	; 0x67be <Timer1_enuSetMode>
	Timer1_enuSetCounter(0);
     e98:	80 e0       	ldi	r24, 0x00	; 0
     e9a:	90 e0       	ldi	r25, 0x00	; 0
     e9c:	0e 94 82 34 	call	0x6904	; 0x6904 <Timer1_enuSetCounter>
	Timer1_enuSetPrescaler(configTIMER1_PRESCALER);
     ea0:	82 e0       	ldi	r24, 0x02	; 2
     ea2:	0e 94 62 34 	call	0x68c4	; 0x68c4 <Timer1_enuSetPrescaler>
	Timer1_enuSetCmpareMatchRegA(configTICK_RATE_HZ);
     ea6:	88 ee       	ldi	r24, 0xE8	; 232
     ea8:	93 e0       	ldi	r25, 0x03	; 3
     eaa:	0e 94 b4 34 	call	0x6968	; 0x6968 <Timer1_enuSetCmpareMatchRegA>
	Timer1_enuSet_OC1A_Action(Disconnect);
     eae:	80 e0       	ldi	r24, 0x00	; 0
     eb0:	0e 94 fc 34 	call	0x69f8	; 0x69f8 <Timer1_enuSet_OC1A_Action>
	Timer1_enuCTCA_INT_Enable();
     eb4:	0e 94 62 36 	call	0x6cc4	; 0x6cc4 <Timer1_enuCTCA_INT_Enable>
}
     eb8:	cf 91       	pop	r28
     eba:	df 91       	pop	r29
     ebc:	08 95       	ret

00000ebe <vPortEndScheduler>:


void vPortEndScheduler( void )
{
     ebe:	df 93       	push	r29
     ec0:	cf 93       	push	r28
     ec2:	cd b7       	in	r28, 0x3d	; 61
     ec4:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     ec6:	cf 91       	pop	r28
     ec8:	df 91       	pop	r29
     eca:	08 95       	ret

00000ecc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     ecc:	0f 92       	push	r0
     ece:	0f b6       	in	r0, 0x3f	; 63
     ed0:	f8 94       	cli
     ed2:	0f 92       	push	r0
     ed4:	1f 92       	push	r1
     ed6:	11 24       	eor	r1, r1
     ed8:	2f 92       	push	r2
     eda:	3f 92       	push	r3
     edc:	4f 92       	push	r4
     ede:	5f 92       	push	r5
     ee0:	6f 92       	push	r6
     ee2:	7f 92       	push	r7
     ee4:	8f 92       	push	r8
     ee6:	9f 92       	push	r9
     ee8:	af 92       	push	r10
     eea:	bf 92       	push	r11
     eec:	cf 92       	push	r12
     eee:	df 92       	push	r13
     ef0:	ef 92       	push	r14
     ef2:	ff 92       	push	r15
     ef4:	0f 93       	push	r16
     ef6:	1f 93       	push	r17
     ef8:	2f 93       	push	r18
     efa:	3f 93       	push	r19
     efc:	4f 93       	push	r20
     efe:	5f 93       	push	r21
     f00:	6f 93       	push	r22
     f02:	7f 93       	push	r23
     f04:	8f 93       	push	r24
     f06:	9f 93       	push	r25
     f08:	af 93       	push	r26
     f0a:	bf 93       	push	r27
     f0c:	cf 93       	push	r28
     f0e:	df 93       	push	r29
     f10:	ef 93       	push	r30
     f12:	ff 93       	push	r31
     f14:	a0 91 60 06 	lds	r26, 0x0660
     f18:	b0 91 61 06 	lds	r27, 0x0661
     f1c:	0d b6       	in	r0, 0x3d	; 61
     f1e:	0d 92       	st	X+, r0
     f20:	0e b6       	in	r0, 0x3e	; 62
     f22:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f24:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f28:	a0 91 60 06 	lds	r26, 0x0660
     f2c:	b0 91 61 06 	lds	r27, 0x0661
     f30:	cd 91       	ld	r28, X+
     f32:	cd bf       	out	0x3d, r28	; 61
     f34:	dd 91       	ld	r29, X+
     f36:	de bf       	out	0x3e, r29	; 62
     f38:	ff 91       	pop	r31
     f3a:	ef 91       	pop	r30
     f3c:	df 91       	pop	r29
     f3e:	cf 91       	pop	r28
     f40:	bf 91       	pop	r27
     f42:	af 91       	pop	r26
     f44:	9f 91       	pop	r25
     f46:	8f 91       	pop	r24
     f48:	7f 91       	pop	r23
     f4a:	6f 91       	pop	r22
     f4c:	5f 91       	pop	r21
     f4e:	4f 91       	pop	r20
     f50:	3f 91       	pop	r19
     f52:	2f 91       	pop	r18
     f54:	1f 91       	pop	r17
     f56:	0f 91       	pop	r16
     f58:	ff 90       	pop	r15
     f5a:	ef 90       	pop	r14
     f5c:	df 90       	pop	r13
     f5e:	cf 90       	pop	r12
     f60:	bf 90       	pop	r11
     f62:	af 90       	pop	r10
     f64:	9f 90       	pop	r9
     f66:	8f 90       	pop	r8
     f68:	7f 90       	pop	r7
     f6a:	6f 90       	pop	r6
     f6c:	5f 90       	pop	r5
     f6e:	4f 90       	pop	r4
     f70:	3f 90       	pop	r3
     f72:	2f 90       	pop	r2
     f74:	1f 90       	pop	r1
     f76:	0f 90       	pop	r0
     f78:	0f be       	out	0x3f, r0	; 63
     f7a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f7c:	08 95       	ret

00000f7e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f7e:	0f 92       	push	r0
     f80:	0f b6       	in	r0, 0x3f	; 63
     f82:	f8 94       	cli
     f84:	0f 92       	push	r0
     f86:	1f 92       	push	r1
     f88:	11 24       	eor	r1, r1
     f8a:	2f 92       	push	r2
     f8c:	3f 92       	push	r3
     f8e:	4f 92       	push	r4
     f90:	5f 92       	push	r5
     f92:	6f 92       	push	r6
     f94:	7f 92       	push	r7
     f96:	8f 92       	push	r8
     f98:	9f 92       	push	r9
     f9a:	af 92       	push	r10
     f9c:	bf 92       	push	r11
     f9e:	cf 92       	push	r12
     fa0:	df 92       	push	r13
     fa2:	ef 92       	push	r14
     fa4:	ff 92       	push	r15
     fa6:	0f 93       	push	r16
     fa8:	1f 93       	push	r17
     faa:	2f 93       	push	r18
     fac:	3f 93       	push	r19
     fae:	4f 93       	push	r20
     fb0:	5f 93       	push	r21
     fb2:	6f 93       	push	r22
     fb4:	7f 93       	push	r23
     fb6:	8f 93       	push	r24
     fb8:	9f 93       	push	r25
     fba:	af 93       	push	r26
     fbc:	bf 93       	push	r27
     fbe:	cf 93       	push	r28
     fc0:	df 93       	push	r29
     fc2:	ef 93       	push	r30
     fc4:	ff 93       	push	r31
     fc6:	a0 91 60 06 	lds	r26, 0x0660
     fca:	b0 91 61 06 	lds	r27, 0x0661
     fce:	0d b6       	in	r0, 0x3d	; 61
     fd0:	0d 92       	st	X+, r0
     fd2:	0e b6       	in	r0, 0x3e	; 62
     fd4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     fd6:	0e 94 04 1c 	call	0x3808	; 0x3808 <xTaskIncrementTick>
     fda:	88 23       	and	r24, r24
     fdc:	11 f0       	breq	.+4      	; 0xfe2 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     fde:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     fe2:	a0 91 60 06 	lds	r26, 0x0660
     fe6:	b0 91 61 06 	lds	r27, 0x0661
     fea:	cd 91       	ld	r28, X+
     fec:	cd bf       	out	0x3d, r28	; 61
     fee:	dd 91       	ld	r29, X+
     ff0:	de bf       	out	0x3e, r29	; 62
     ff2:	ff 91       	pop	r31
     ff4:	ef 91       	pop	r30
     ff6:	df 91       	pop	r29
     ff8:	cf 91       	pop	r28
     ffa:	bf 91       	pop	r27
     ffc:	af 91       	pop	r26
     ffe:	9f 91       	pop	r25
    1000:	8f 91       	pop	r24
    1002:	7f 91       	pop	r23
    1004:	6f 91       	pop	r22
    1006:	5f 91       	pop	r21
    1008:	4f 91       	pop	r20
    100a:	3f 91       	pop	r19
    100c:	2f 91       	pop	r18
    100e:	1f 91       	pop	r17
    1010:	0f 91       	pop	r16
    1012:	ff 90       	pop	r15
    1014:	ef 90       	pop	r14
    1016:	df 90       	pop	r13
    1018:	cf 90       	pop	r12
    101a:	bf 90       	pop	r11
    101c:	af 90       	pop	r10
    101e:	9f 90       	pop	r9
    1020:	8f 90       	pop	r8
    1022:	7f 90       	pop	r7
    1024:	6f 90       	pop	r6
    1026:	5f 90       	pop	r5
    1028:	4f 90       	pop	r4
    102a:	3f 90       	pop	r3
    102c:	2f 90       	pop	r2
    102e:	1f 90       	pop	r1
    1030:	0f 90       	pop	r0
    1032:	0f be       	out	0x3f, r0	; 63
    1034:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1036:	08 95       	ret

00001038 <__vector_7>:
 * tick count.  We don't need to switch context, this can only be done by
 * manual calls to taskYIELD();
 */
void __vector_7(void) __attribute__((signal));
void __vector_7 (void)
{
    1038:	1f 92       	push	r1
    103a:	0f 92       	push	r0
    103c:	0f b6       	in	r0, 0x3f	; 63
    103e:	0f 92       	push	r0
    1040:	11 24       	eor	r1, r1
    1042:	2f 93       	push	r18
    1044:	3f 93       	push	r19
    1046:	4f 93       	push	r20
    1048:	5f 93       	push	r21
    104a:	6f 93       	push	r22
    104c:	7f 93       	push	r23
    104e:	8f 93       	push	r24
    1050:	9f 93       	push	r25
    1052:	af 93       	push	r26
    1054:	bf 93       	push	r27
    1056:	ef 93       	push	r30
    1058:	ff 93       	push	r31
    105a:	df 93       	push	r29
    105c:	cf 93       	push	r28
    105e:	cd b7       	in	r28, 0x3d	; 61
    1060:	de b7       	in	r29, 0x3e	; 62
	xTaskIncrementTick();
    1062:	0e 94 04 1c 	call	0x3808	; 0x3808 <xTaskIncrementTick>
}
    1066:	cf 91       	pop	r28
    1068:	df 91       	pop	r29
    106a:	ff 91       	pop	r31
    106c:	ef 91       	pop	r30
    106e:	bf 91       	pop	r27
    1070:	af 91       	pop	r26
    1072:	9f 91       	pop	r25
    1074:	8f 91       	pop	r24
    1076:	7f 91       	pop	r23
    1078:	6f 91       	pop	r22
    107a:	5f 91       	pop	r21
    107c:	4f 91       	pop	r20
    107e:	3f 91       	pop	r19
    1080:	2f 91       	pop	r18
    1082:	0f 90       	pop	r0
    1084:	0f be       	out	0x3f, r0	; 63
    1086:	0f 90       	pop	r0
    1088:	1f 90       	pop	r1
    108a:	18 95       	reti

0000108c <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    108c:	df 93       	push	r29
    108e:	cf 93       	push	r28
    1090:	00 d0       	rcall	.+0      	; 0x1092 <xQueueGenericReset+0x6>
    1092:	00 d0       	rcall	.+0      	; 0x1094 <xQueueGenericReset+0x8>
    1094:	00 d0       	rcall	.+0      	; 0x1096 <xQueueGenericReset+0xa>
    1096:	cd b7       	in	r28, 0x3d	; 61
    1098:	de b7       	in	r29, 0x3e	; 62
    109a:	9d 83       	std	Y+5, r25	; 0x05
    109c:	8c 83       	std	Y+4, r24	; 0x04
    109e:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    10a0:	81 e0       	ldi	r24, 0x01	; 1
    10a2:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    10a4:	8c 81       	ldd	r24, Y+4	; 0x04
    10a6:	9d 81       	ldd	r25, Y+5	; 0x05
    10a8:	9a 83       	std	Y+2, r25	; 0x02
    10aa:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    10ac:	89 81       	ldd	r24, Y+1	; 0x01
    10ae:	9a 81       	ldd	r25, Y+2	; 0x02
    10b0:	00 97       	sbiw	r24, 0x00	; 0
    10b2:	09 f4       	brne	.+2      	; 0x10b6 <xQueueGenericReset+0x2a>
    10b4:	87 c0       	rjmp	.+270    	; 0x11c4 <xQueueGenericReset+0x138>
    10b6:	e9 81       	ldd	r30, Y+1	; 0x01
    10b8:	fa 81       	ldd	r31, Y+2	; 0x02
    10ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    10bc:	88 23       	and	r24, r24
    10be:	09 f4       	brne	.+2      	; 0x10c2 <xQueueGenericReset+0x36>
    10c0:	81 c0       	rjmp	.+258    	; 0x11c4 <xQueueGenericReset+0x138>
    10c2:	e9 81       	ldd	r30, Y+1	; 0x01
    10c4:	fa 81       	ldd	r31, Y+2	; 0x02
    10c6:	83 8d       	ldd	r24, Z+27	; 0x1b
    10c8:	28 2f       	mov	r18, r24
    10ca:	30 e0       	ldi	r19, 0x00	; 0
    10cc:	8f ef       	ldi	r24, 0xFF	; 255
    10ce:	9f e7       	ldi	r25, 0x7F	; 127
    10d0:	b9 01       	movw	r22, r18
    10d2:	0e 94 74 37 	call	0x6ee8	; 0x6ee8 <__udivmodhi4>
    10d6:	cb 01       	movw	r24, r22
    10d8:	9c 01       	movw	r18, r24
    10da:	e9 81       	ldd	r30, Y+1	; 0x01
    10dc:	fa 81       	ldd	r31, Y+2	; 0x02
    10de:	84 8d       	ldd	r24, Z+28	; 0x1c
    10e0:	88 2f       	mov	r24, r24
    10e2:	90 e0       	ldi	r25, 0x00	; 0
    10e4:	28 17       	cp	r18, r24
    10e6:	39 07       	cpc	r19, r25
    10e8:	08 f4       	brcc	.+2      	; 0x10ec <xQueueGenericReset+0x60>
    10ea:	6c c0       	rjmp	.+216    	; 0x11c4 <xQueueGenericReset+0x138>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    10ec:	0f b6       	in	r0, 0x3f	; 63
    10ee:	f8 94       	cli
    10f0:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    10f2:	e9 81       	ldd	r30, Y+1	; 0x01
    10f4:	fa 81       	ldd	r31, Y+2	; 0x02
    10f6:	40 81       	ld	r20, Z
    10f8:	51 81       	ldd	r21, Z+1	; 0x01
    10fa:	e9 81       	ldd	r30, Y+1	; 0x01
    10fc:	fa 81       	ldd	r31, Y+2	; 0x02
    10fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1100:	28 2f       	mov	r18, r24
    1102:	30 e0       	ldi	r19, 0x00	; 0
    1104:	e9 81       	ldd	r30, Y+1	; 0x01
    1106:	fa 81       	ldd	r31, Y+2	; 0x02
    1108:	84 8d       	ldd	r24, Z+28	; 0x1c
    110a:	88 2f       	mov	r24, r24
    110c:	90 e0       	ldi	r25, 0x00	; 0
    110e:	bc 01       	movw	r22, r24
    1110:	26 9f       	mul	r18, r22
    1112:	c0 01       	movw	r24, r0
    1114:	27 9f       	mul	r18, r23
    1116:	90 0d       	add	r25, r0
    1118:	36 9f       	mul	r19, r22
    111a:	90 0d       	add	r25, r0
    111c:	11 24       	eor	r1, r1
    111e:	84 0f       	add	r24, r20
    1120:	95 1f       	adc	r25, r21
    1122:	e9 81       	ldd	r30, Y+1	; 0x01
    1124:	fa 81       	ldd	r31, Y+2	; 0x02
    1126:	95 83       	std	Z+5, r25	; 0x05
    1128:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    112a:	e9 81       	ldd	r30, Y+1	; 0x01
    112c:	fa 81       	ldd	r31, Y+2	; 0x02
    112e:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1130:	e9 81       	ldd	r30, Y+1	; 0x01
    1132:	fa 81       	ldd	r31, Y+2	; 0x02
    1134:	80 81       	ld	r24, Z
    1136:	91 81       	ldd	r25, Z+1	; 0x01
    1138:	e9 81       	ldd	r30, Y+1	; 0x01
    113a:	fa 81       	ldd	r31, Y+2	; 0x02
    113c:	93 83       	std	Z+3, r25	; 0x03
    113e:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1140:	e9 81       	ldd	r30, Y+1	; 0x01
    1142:	fa 81       	ldd	r31, Y+2	; 0x02
    1144:	40 81       	ld	r20, Z
    1146:	51 81       	ldd	r21, Z+1	; 0x01
    1148:	e9 81       	ldd	r30, Y+1	; 0x01
    114a:	fa 81       	ldd	r31, Y+2	; 0x02
    114c:	83 8d       	ldd	r24, Z+27	; 0x1b
    114e:	88 2f       	mov	r24, r24
    1150:	90 e0       	ldi	r25, 0x00	; 0
    1152:	9c 01       	movw	r18, r24
    1154:	21 50       	subi	r18, 0x01	; 1
    1156:	30 40       	sbci	r19, 0x00	; 0
    1158:	e9 81       	ldd	r30, Y+1	; 0x01
    115a:	fa 81       	ldd	r31, Y+2	; 0x02
    115c:	84 8d       	ldd	r24, Z+28	; 0x1c
    115e:	88 2f       	mov	r24, r24
    1160:	90 e0       	ldi	r25, 0x00	; 0
    1162:	bc 01       	movw	r22, r24
    1164:	26 9f       	mul	r18, r22
    1166:	c0 01       	movw	r24, r0
    1168:	27 9f       	mul	r18, r23
    116a:	90 0d       	add	r25, r0
    116c:	36 9f       	mul	r19, r22
    116e:	90 0d       	add	r25, r0
    1170:	11 24       	eor	r1, r1
    1172:	84 0f       	add	r24, r20
    1174:	95 1f       	adc	r25, r21
    1176:	e9 81       	ldd	r30, Y+1	; 0x01
    1178:	fa 81       	ldd	r31, Y+2	; 0x02
    117a:	97 83       	std	Z+7, r25	; 0x07
    117c:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    117e:	e9 81       	ldd	r30, Y+1	; 0x01
    1180:	fa 81       	ldd	r31, Y+2	; 0x02
    1182:	8f ef       	ldi	r24, 0xFF	; 255
    1184:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1186:	e9 81       	ldd	r30, Y+1	; 0x01
    1188:	fa 81       	ldd	r31, Y+2	; 0x02
    118a:	8f ef       	ldi	r24, 0xFF	; 255
    118c:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    118e:	8e 81       	ldd	r24, Y+6	; 0x06
    1190:	88 23       	and	r24, r24
    1192:	59 f4       	brne	.+22     	; 0x11aa <xQueueGenericReset+0x11e>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1194:	e9 81       	ldd	r30, Y+1	; 0x01
    1196:	fa 81       	ldd	r31, Y+2	; 0x02
    1198:	80 85       	ldd	r24, Z+8	; 0x08
    119a:	88 23       	and	r24, r24
    119c:	81 f0       	breq	.+32     	; 0x11be <xQueueGenericReset+0x132>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    119e:	89 81       	ldd	r24, Y+1	; 0x01
    11a0:	9a 81       	ldd	r25, Y+2	; 0x02
    11a2:	08 96       	adiw	r24, 0x08	; 8
    11a4:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
    11a8:	0a c0       	rjmp	.+20     	; 0x11be <xQueueGenericReset+0x132>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    11aa:	89 81       	ldd	r24, Y+1	; 0x01
    11ac:	9a 81       	ldd	r25, Y+2	; 0x02
    11ae:	08 96       	adiw	r24, 0x08	; 8
    11b0:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    11b4:	89 81       	ldd	r24, Y+1	; 0x01
    11b6:	9a 81       	ldd	r25, Y+2	; 0x02
    11b8:	41 96       	adiw	r24, 0x11	; 17
    11ba:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    11be:	0f 90       	pop	r0
    11c0:	0f be       	out	0x3f, r0	; 63
    11c2:	01 c0       	rjmp	.+2      	; 0x11c6 <xQueueGenericReset+0x13a>
    }
    else
    {
        xReturn = pdFAIL;
    11c4:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    11c6:	8b 81       	ldd	r24, Y+3	; 0x03
}
    11c8:	26 96       	adiw	r28, 0x06	; 6
    11ca:	0f b6       	in	r0, 0x3f	; 63
    11cc:	f8 94       	cli
    11ce:	de bf       	out	0x3e, r29	; 62
    11d0:	0f be       	out	0x3f, r0	; 63
    11d2:	cd bf       	out	0x3d, r28	; 61
    11d4:	cf 91       	pop	r28
    11d6:	df 91       	pop	r29
    11d8:	08 95       	ret

000011da <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    11da:	0f 93       	push	r16
    11dc:	1f 93       	push	r17
    11de:	df 93       	push	r29
    11e0:	cf 93       	push	r28
    11e2:	cd b7       	in	r28, 0x3d	; 61
    11e4:	de b7       	in	r29, 0x3e	; 62
    11e6:	29 97       	sbiw	r28, 0x09	; 9
    11e8:	0f b6       	in	r0, 0x3f	; 63
    11ea:	f8 94       	cli
    11ec:	de bf       	out	0x3e, r29	; 62
    11ee:	0f be       	out	0x3f, r0	; 63
    11f0:	cd bf       	out	0x3d, r28	; 61
    11f2:	8f 83       	std	Y+7, r24	; 0x07
    11f4:	68 87       	std	Y+8, r22	; 0x08
    11f6:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    11f8:	1e 82       	std	Y+6, r1	; 0x06
    11fa:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    11fc:	8f 81       	ldd	r24, Y+7	; 0x07
    11fe:	88 23       	and	r24, r24
    1200:	09 f4       	brne	.+2      	; 0x1204 <xQueueGenericCreate+0x2a>
    1202:	52 c0       	rjmp	.+164    	; 0x12a8 <xQueueGenericCreate+0xce>
    1204:	8f 81       	ldd	r24, Y+7	; 0x07
    1206:	28 2f       	mov	r18, r24
    1208:	30 e0       	ldi	r19, 0x00	; 0
    120a:	8f ef       	ldi	r24, 0xFF	; 255
    120c:	9f e7       	ldi	r25, 0x7F	; 127
    120e:	b9 01       	movw	r22, r18
    1210:	0e 94 74 37 	call	0x6ee8	; 0x6ee8 <__udivmodhi4>
    1214:	cb 01       	movw	r24, r22
    1216:	9c 01       	movw	r18, r24
    1218:	88 85       	ldd	r24, Y+8	; 0x08
    121a:	88 2f       	mov	r24, r24
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	28 17       	cp	r18, r24
    1220:	39 07       	cpc	r19, r25
    1222:	08 f4       	brcc	.+2      	; 0x1226 <xQueueGenericCreate+0x4c>
    1224:	41 c0       	rjmp	.+130    	; 0x12a8 <xQueueGenericCreate+0xce>
    1226:	8f 81       	ldd	r24, Y+7	; 0x07
    1228:	28 2f       	mov	r18, r24
    122a:	30 e0       	ldi	r19, 0x00	; 0
    122c:	88 85       	ldd	r24, Y+8	; 0x08
    122e:	88 2f       	mov	r24, r24
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	ac 01       	movw	r20, r24
    1234:	24 9f       	mul	r18, r20
    1236:	c0 01       	movw	r24, r0
    1238:	25 9f       	mul	r18, r21
    123a:	90 0d       	add	r25, r0
    123c:	34 9f       	mul	r19, r20
    123e:	90 0d       	add	r25, r0
    1240:	11 24       	eor	r1, r1
    1242:	5f e7       	ldi	r21, 0x7F	; 127
    1244:	81 3e       	cpi	r24, 0xE1	; 225
    1246:	95 07       	cpc	r25, r21
    1248:	78 f5       	brcc	.+94     	; 0x12a8 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    124a:	8f 81       	ldd	r24, Y+7	; 0x07
    124c:	28 2f       	mov	r18, r24
    124e:	30 e0       	ldi	r19, 0x00	; 0
    1250:	88 85       	ldd	r24, Y+8	; 0x08
    1252:	88 2f       	mov	r24, r24
    1254:	90 e0       	ldi	r25, 0x00	; 0
    1256:	ac 01       	movw	r20, r24
    1258:	24 9f       	mul	r18, r20
    125a:	c0 01       	movw	r24, r0
    125c:	25 9f       	mul	r18, r21
    125e:	90 0d       	add	r25, r0
    1260:	34 9f       	mul	r19, r20
    1262:	90 0d       	add	r25, r0
    1264:	11 24       	eor	r1, r1
    1266:	9c 83       	std	Y+4, r25	; 0x04
    1268:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    126a:	8b 81       	ldd	r24, Y+3	; 0x03
    126c:	9c 81       	ldd	r25, Y+4	; 0x04
    126e:	4f 96       	adiw	r24, 0x1f	; 31
    1270:	0e 94 d7 03 	call	0x7ae	; 0x7ae <pvPortMalloc>
    1274:	9e 83       	std	Y+6, r25	; 0x06
    1276:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    1278:	8d 81       	ldd	r24, Y+5	; 0x05
    127a:	9e 81       	ldd	r25, Y+6	; 0x06
    127c:	00 97       	sbiw	r24, 0x00	; 0
    127e:	a1 f0       	breq	.+40     	; 0x12a8 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1280:	8d 81       	ldd	r24, Y+5	; 0x05
    1282:	9e 81       	ldd	r25, Y+6	; 0x06
    1284:	9a 83       	std	Y+2, r25	; 0x02
    1286:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1288:	89 81       	ldd	r24, Y+1	; 0x01
    128a:	9a 81       	ldd	r25, Y+2	; 0x02
    128c:	4f 96       	adiw	r24, 0x1f	; 31
    128e:	9a 83       	std	Y+2, r25	; 0x02
    1290:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1292:	29 81       	ldd	r18, Y+1	; 0x01
    1294:	3a 81       	ldd	r19, Y+2	; 0x02
    1296:	ed 81       	ldd	r30, Y+5	; 0x05
    1298:	fe 81       	ldd	r31, Y+6	; 0x06
    129a:	8f 81       	ldd	r24, Y+7	; 0x07
    129c:	68 85       	ldd	r22, Y+8	; 0x08
    129e:	a9 01       	movw	r20, r18
    12a0:	29 85       	ldd	r18, Y+9	; 0x09
    12a2:	8f 01       	movw	r16, r30
    12a4:	0e 94 61 09 	call	0x12c2	; 0x12c2 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    12a8:	8d 81       	ldd	r24, Y+5	; 0x05
    12aa:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    12ac:	29 96       	adiw	r28, 0x09	; 9
    12ae:	0f b6       	in	r0, 0x3f	; 63
    12b0:	f8 94       	cli
    12b2:	de bf       	out	0x3e, r29	; 62
    12b4:	0f be       	out	0x3f, r0	; 63
    12b6:	cd bf       	out	0x3d, r28	; 61
    12b8:	cf 91       	pop	r28
    12ba:	df 91       	pop	r29
    12bc:	1f 91       	pop	r17
    12be:	0f 91       	pop	r16
    12c0:	08 95       	ret

000012c2 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    12c2:	0f 93       	push	r16
    12c4:	1f 93       	push	r17
    12c6:	df 93       	push	r29
    12c8:	cf 93       	push	r28
    12ca:	cd b7       	in	r28, 0x3d	; 61
    12cc:	de b7       	in	r29, 0x3e	; 62
    12ce:	27 97       	sbiw	r28, 0x07	; 7
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	cd bf       	out	0x3d, r28	; 61
    12da:	89 83       	std	Y+1, r24	; 0x01
    12dc:	6a 83       	std	Y+2, r22	; 0x02
    12de:	5c 83       	std	Y+4, r21	; 0x04
    12e0:	4b 83       	std	Y+3, r20	; 0x03
    12e2:	2d 83       	std	Y+5, r18	; 0x05
    12e4:	1f 83       	std	Y+7, r17	; 0x07
    12e6:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    12e8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ea:	88 23       	and	r24, r24
    12ec:	39 f4       	brne	.+14     	; 0x12fc <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    12ee:	8e 81       	ldd	r24, Y+6	; 0x06
    12f0:	9f 81       	ldd	r25, Y+7	; 0x07
    12f2:	ee 81       	ldd	r30, Y+6	; 0x06
    12f4:	ff 81       	ldd	r31, Y+7	; 0x07
    12f6:	91 83       	std	Z+1, r25	; 0x01
    12f8:	80 83       	st	Z, r24
    12fa:	06 c0       	rjmp	.+12     	; 0x1308 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    12fc:	8b 81       	ldd	r24, Y+3	; 0x03
    12fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1300:	ee 81       	ldd	r30, Y+6	; 0x06
    1302:	ff 81       	ldd	r31, Y+7	; 0x07
    1304:	91 83       	std	Z+1, r25	; 0x01
    1306:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    1308:	ee 81       	ldd	r30, Y+6	; 0x06
    130a:	ff 81       	ldd	r31, Y+7	; 0x07
    130c:	89 81       	ldd	r24, Y+1	; 0x01
    130e:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    1310:	ee 81       	ldd	r30, Y+6	; 0x06
    1312:	ff 81       	ldd	r31, Y+7	; 0x07
    1314:	8a 81       	ldd	r24, Y+2	; 0x02
    1316:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1318:	8e 81       	ldd	r24, Y+6	; 0x06
    131a:	9f 81       	ldd	r25, Y+7	; 0x07
    131c:	61 e0       	ldi	r22, 0x01	; 1
    131e:	0e 94 46 08 	call	0x108c	; 0x108c <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    1322:	27 96       	adiw	r28, 0x07	; 7
    1324:	0f b6       	in	r0, 0x3f	; 63
    1326:	f8 94       	cli
    1328:	de bf       	out	0x3e, r29	; 62
    132a:	0f be       	out	0x3f, r0	; 63
    132c:	cd bf       	out	0x3d, r28	; 61
    132e:	cf 91       	pop	r28
    1330:	df 91       	pop	r29
    1332:	1f 91       	pop	r17
    1334:	0f 91       	pop	r16
    1336:	08 95       	ret

00001338 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    1338:	df 93       	push	r29
    133a:	cf 93       	push	r28
    133c:	cd b7       	in	r28, 0x3d	; 61
    133e:	de b7       	in	r29, 0x3e	; 62
    1340:	2f 97       	sbiw	r28, 0x0f	; 15
    1342:	0f b6       	in	r0, 0x3f	; 63
    1344:	f8 94       	cli
    1346:	de bf       	out	0x3e, r29	; 62
    1348:	0f be       	out	0x3f, r0	; 63
    134a:	cd bf       	out	0x3d, r28	; 61
    134c:	99 87       	std	Y+9, r25	; 0x09
    134e:	88 87       	std	Y+8, r24	; 0x08
    1350:	7b 87       	std	Y+11, r23	; 0x0b
    1352:	6a 87       	std	Y+10, r22	; 0x0a
    1354:	5d 87       	std	Y+13, r21	; 0x0d
    1356:	4c 87       	std	Y+12, r20	; 0x0c
    1358:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    135a:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    135c:	88 85       	ldd	r24, Y+8	; 0x08
    135e:	99 85       	ldd	r25, Y+9	; 0x09
    1360:	9a 83       	std	Y+2, r25	; 0x02
    1362:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1364:	0f b6       	in	r0, 0x3f	; 63
    1366:	f8 94       	cli
    1368:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    136a:	e9 81       	ldd	r30, Y+1	; 0x01
    136c:	fa 81       	ldd	r31, Y+2	; 0x02
    136e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1370:	e9 81       	ldd	r30, Y+1	; 0x01
    1372:	fa 81       	ldd	r31, Y+2	; 0x02
    1374:	83 8d       	ldd	r24, Z+27	; 0x1b
    1376:	98 17       	cp	r25, r24
    1378:	18 f0       	brcs	.+6      	; 0x1380 <xQueueGenericSend+0x48>
    137a:	8e 85       	ldd	r24, Y+14	; 0x0e
    137c:	82 30       	cpi	r24, 0x02	; 2
    137e:	c1 f4       	brne	.+48     	; 0x13b0 <xQueueGenericSend+0x78>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	9a 81       	ldd	r25, Y+2	; 0x02
    1384:	2a 85       	ldd	r18, Y+10	; 0x0a
    1386:	3b 85       	ldd	r19, Y+11	; 0x0b
    1388:	b9 01       	movw	r22, r18
    138a:	4e 85       	ldd	r20, Y+14	; 0x0e
    138c:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <prvCopyDataToQueue>
    1390:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1392:	e9 81       	ldd	r30, Y+1	; 0x01
    1394:	fa 81       	ldd	r31, Y+2	; 0x02
    1396:	81 89       	ldd	r24, Z+17	; 0x11
    1398:	88 23       	and	r24, r24
    139a:	29 f0       	breq	.+10     	; 0x13a6 <xQueueGenericSend+0x6e>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    139c:	89 81       	ldd	r24, Y+1	; 0x01
    139e:	9a 81       	ldd	r25, Y+2	; 0x02
    13a0:	41 96       	adiw	r24, 0x11	; 17
    13a2:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    13a6:	0f 90       	pop	r0
    13a8:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    13aa:	81 e0       	ldi	r24, 0x01	; 1
    13ac:	8f 87       	std	Y+15, r24	; 0x0f
    13ae:	5c c0       	rjmp	.+184    	; 0x1468 <xQueueGenericSend+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    13b0:	8c 85       	ldd	r24, Y+12	; 0x0c
    13b2:	9d 85       	ldd	r25, Y+13	; 0x0d
    13b4:	00 97       	sbiw	r24, 0x00	; 0
    13b6:	21 f4       	brne	.+8      	; 0x13c0 <xQueueGenericSend+0x88>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    13b8:	0f 90       	pop	r0
    13ba:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    13bc:	1f 86       	std	Y+15, r1	; 0x0f
    13be:	54 c0       	rjmp	.+168    	; 0x1468 <xQueueGenericSend+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    13c0:	8c 81       	ldd	r24, Y+4	; 0x04
    13c2:	88 23       	and	r24, r24
    13c4:	31 f4       	brne	.+12     	; 0x13d2 <xQueueGenericSend+0x9a>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    13c6:	ce 01       	movw	r24, r28
    13c8:	05 96       	adiw	r24, 0x05	; 5
    13ca:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    13ce:	81 e0       	ldi	r24, 0x01	; 1
    13d0:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    13d2:	0f 90       	pop	r0
    13d4:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    13d6:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    13da:	0f b6       	in	r0, 0x3f	; 63
    13dc:	f8 94       	cli
    13de:	0f 92       	push	r0
    13e0:	e9 81       	ldd	r30, Y+1	; 0x01
    13e2:	fa 81       	ldd	r31, Y+2	; 0x02
    13e4:	85 8d       	ldd	r24, Z+29	; 0x1d
    13e6:	8f 3f       	cpi	r24, 0xFF	; 255
    13e8:	19 f4       	brne	.+6      	; 0x13f0 <xQueueGenericSend+0xb8>
    13ea:	e9 81       	ldd	r30, Y+1	; 0x01
    13ec:	fa 81       	ldd	r31, Y+2	; 0x02
    13ee:	15 8e       	std	Z+29, r1	; 0x1d
    13f0:	e9 81       	ldd	r30, Y+1	; 0x01
    13f2:	fa 81       	ldd	r31, Y+2	; 0x02
    13f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    13f6:	8f 3f       	cpi	r24, 0xFF	; 255
    13f8:	19 f4       	brne	.+6      	; 0x1400 <xQueueGenericSend+0xc8>
    13fa:	e9 81       	ldd	r30, Y+1	; 0x01
    13fc:	fa 81       	ldd	r31, Y+2	; 0x02
    13fe:	16 8e       	std	Z+30, r1	; 0x1e
    1400:	0f 90       	pop	r0
    1402:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1404:	ce 01       	movw	r24, r28
    1406:	05 96       	adiw	r24, 0x05	; 5
    1408:	9e 01       	movw	r18, r28
    140a:	24 5f       	subi	r18, 0xF4	; 244
    140c:	3f 4f       	sbci	r19, 0xFF	; 255
    140e:	b9 01       	movw	r22, r18
    1410:	0e 94 f7 20 	call	0x41ee	; 0x41ee <xTaskCheckForTimeOut>
    1414:	88 23       	and	r24, r24
    1416:	09 f5       	brne	.+66     	; 0x145a <xQueueGenericSend+0x122>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1418:	89 81       	ldd	r24, Y+1	; 0x01
    141a:	9a 81       	ldd	r25, Y+2	; 0x02
    141c:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <prvIsQueueFull>
    1420:	88 23       	and	r24, r24
    1422:	a1 f0       	breq	.+40     	; 0x144c <xQueueGenericSend+0x114>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1424:	89 81       	ldd	r24, Y+1	; 0x01
    1426:	9a 81       	ldd	r25, Y+2	; 0x02
    1428:	08 96       	adiw	r24, 0x08	; 8
    142a:	2c 85       	ldd	r18, Y+12	; 0x0c
    142c:	3d 85       	ldd	r19, Y+13	; 0x0d
    142e:	b9 01       	movw	r22, r18
    1430:	0e 94 e7 1d 	call	0x3bce	; 0x3bce <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    1434:	89 81       	ldd	r24, Y+1	; 0x01
    1436:	9a 81       	ldd	r25, Y+2	; 0x02
    1438:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    143c:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    1440:	88 23       	and	r24, r24
    1442:	09 f0       	breq	.+2      	; 0x1446 <xQueueGenericSend+0x10e>
    1444:	8f cf       	rjmp	.-226    	; 0x1364 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    1446:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>
    144a:	8c cf       	rjmp	.-232    	; 0x1364 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    144c:	89 81       	ldd	r24, Y+1	; 0x01
    144e:	9a 81       	ldd	r25, Y+2	; 0x02
    1450:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1454:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    1458:	85 cf       	rjmp	.-246    	; 0x1364 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    145a:	89 81       	ldd	r24, Y+1	; 0x01
    145c:	9a 81       	ldd	r25, Y+2	; 0x02
    145e:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1462:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    1466:	1f 86       	std	Y+15, r1	; 0x0f
    1468:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    146a:	2f 96       	adiw	r28, 0x0f	; 15
    146c:	0f b6       	in	r0, 0x3f	; 63
    146e:	f8 94       	cli
    1470:	de bf       	out	0x3e, r29	; 62
    1472:	0f be       	out	0x3f, r0	; 63
    1474:	cd bf       	out	0x3d, r28	; 61
    1476:	cf 91       	pop	r28
    1478:	df 91       	pop	r29
    147a:	08 95       	ret

0000147c <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    147c:	df 93       	push	r29
    147e:	cf 93       	push	r28
    1480:	cd b7       	in	r28, 0x3d	; 61
    1482:	de b7       	in	r29, 0x3e	; 62
    1484:	2d 97       	sbiw	r28, 0x0d	; 13
    1486:	0f b6       	in	r0, 0x3f	; 63
    1488:	f8 94       	cli
    148a:	de bf       	out	0x3e, r29	; 62
    148c:	0f be       	out	0x3f, r0	; 63
    148e:	cd bf       	out	0x3d, r28	; 61
    1490:	98 87       	std	Y+8, r25	; 0x08
    1492:	8f 83       	std	Y+7, r24	; 0x07
    1494:	7a 87       	std	Y+10, r23	; 0x0a
    1496:	69 87       	std	Y+9, r22	; 0x09
    1498:	5c 87       	std	Y+12, r21	; 0x0c
    149a:	4b 87       	std	Y+11, r20	; 0x0b
    149c:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    149e:	8f 81       	ldd	r24, Y+7	; 0x07
    14a0:	98 85       	ldd	r25, Y+8	; 0x08
    14a2:	9c 83       	std	Y+4, r25	; 0x04
    14a4:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    14a6:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    14a8:	eb 81       	ldd	r30, Y+3	; 0x03
    14aa:	fc 81       	ldd	r31, Y+4	; 0x04
    14ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    14ae:	eb 81       	ldd	r30, Y+3	; 0x03
    14b0:	fc 81       	ldd	r31, Y+4	; 0x04
    14b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    14b4:	98 17       	cp	r25, r24
    14b6:	18 f0       	brcs	.+6      	; 0x14be <xQueueGenericSendFromISR+0x42>
    14b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    14ba:	82 30       	cpi	r24, 0x02	; 2
    14bc:	81 f5       	brne	.+96     	; 0x151e <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    14be:	eb 81       	ldd	r30, Y+3	; 0x03
    14c0:	fc 81       	ldd	r31, Y+4	; 0x04
    14c2:	86 8d       	ldd	r24, Z+30	; 0x1e
    14c4:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    14c6:	eb 81       	ldd	r30, Y+3	; 0x03
    14c8:	fc 81       	ldd	r31, Y+4	; 0x04
    14ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    14cc:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    14ce:	8b 81       	ldd	r24, Y+3	; 0x03
    14d0:	9c 81       	ldd	r25, Y+4	; 0x04
    14d2:	29 85       	ldd	r18, Y+9	; 0x09
    14d4:	3a 85       	ldd	r19, Y+10	; 0x0a
    14d6:	b9 01       	movw	r22, r18
    14d8:	4d 85       	ldd	r20, Y+13	; 0x0d
    14da:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    14de:	8a 81       	ldd	r24, Y+2	; 0x02
    14e0:	8f 3f       	cpi	r24, 0xFF	; 255
    14e2:	a9 f4       	brne	.+42     	; 0x150e <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14e4:	eb 81       	ldd	r30, Y+3	; 0x03
    14e6:	fc 81       	ldd	r31, Y+4	; 0x04
    14e8:	81 89       	ldd	r24, Z+17	; 0x11
    14ea:	88 23       	and	r24, r24
    14ec:	a9 f0       	breq	.+42     	; 0x1518 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14ee:	8b 81       	ldd	r24, Y+3	; 0x03
    14f0:	9c 81       	ldd	r25, Y+4	; 0x04
    14f2:	41 96       	adiw	r24, 0x11	; 17
    14f4:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
    14f8:	88 23       	and	r24, r24
    14fa:	71 f0       	breq	.+28     	; 0x1518 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    14fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    14fe:	9c 85       	ldd	r25, Y+12	; 0x0c
    1500:	00 97       	sbiw	r24, 0x00	; 0
    1502:	51 f0       	breq	.+20     	; 0x1518 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    1504:	eb 85       	ldd	r30, Y+11	; 0x0b
    1506:	fc 85       	ldd	r31, Y+12	; 0x0c
    1508:	81 e0       	ldi	r24, 0x01	; 1
    150a:	80 83       	st	Z, r24
    150c:	05 c0       	rjmp	.+10     	; 0x1518 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    150e:	8a 81       	ldd	r24, Y+2	; 0x02
    1510:	8f 5f       	subi	r24, 0xFF	; 255
    1512:	eb 81       	ldd	r30, Y+3	; 0x03
    1514:	fc 81       	ldd	r31, Y+4	; 0x04
    1516:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	8e 83       	std	Y+6, r24	; 0x06
    151c:	01 c0       	rjmp	.+2      	; 0x1520 <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    151e:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1520:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1522:	2d 96       	adiw	r28, 0x0d	; 13
    1524:	0f b6       	in	r0, 0x3f	; 63
    1526:	f8 94       	cli
    1528:	de bf       	out	0x3e, r29	; 62
    152a:	0f be       	out	0x3f, r0	; 63
    152c:	cd bf       	out	0x3d, r28	; 61
    152e:	cf 91       	pop	r28
    1530:	df 91       	pop	r29
    1532:	08 95       	ret

00001534 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    1534:	df 93       	push	r29
    1536:	cf 93       	push	r28
    1538:	cd b7       	in	r28, 0x3d	; 61
    153a:	de b7       	in	r29, 0x3e	; 62
    153c:	2a 97       	sbiw	r28, 0x0a	; 10
    153e:	0f b6       	in	r0, 0x3f	; 63
    1540:	f8 94       	cli
    1542:	de bf       	out	0x3e, r29	; 62
    1544:	0f be       	out	0x3f, r0	; 63
    1546:	cd bf       	out	0x3d, r28	; 61
    1548:	98 87       	std	Y+8, r25	; 0x08
    154a:	8f 83       	std	Y+7, r24	; 0x07
    154c:	7a 87       	std	Y+10, r23	; 0x0a
    154e:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    1550:	8f 81       	ldd	r24, Y+7	; 0x07
    1552:	98 85       	ldd	r25, Y+8	; 0x08
    1554:	9c 83       	std	Y+4, r25	; 0x04
    1556:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1558:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    155a:	eb 81       	ldd	r30, Y+3	; 0x03
    155c:	fc 81       	ldd	r31, Y+4	; 0x04
    155e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1560:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    1562:	eb 81       	ldd	r30, Y+3	; 0x03
    1564:	fc 81       	ldd	r31, Y+4	; 0x04
    1566:	93 8d       	ldd	r25, Z+27	; 0x1b
    1568:	8a 81       	ldd	r24, Y+2	; 0x02
    156a:	89 17       	cp	r24, r25
    156c:	48 f5       	brcc	.+82     	; 0x15c0 <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    156e:	eb 81       	ldd	r30, Y+3	; 0x03
    1570:	fc 81       	ldd	r31, Y+4	; 0x04
    1572:	86 8d       	ldd	r24, Z+30	; 0x1e
    1574:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1576:	8a 81       	ldd	r24, Y+2	; 0x02
    1578:	8f 5f       	subi	r24, 0xFF	; 255
    157a:	eb 81       	ldd	r30, Y+3	; 0x03
    157c:	fc 81       	ldd	r31, Y+4	; 0x04
    157e:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    1580:	89 81       	ldd	r24, Y+1	; 0x01
    1582:	8f 3f       	cpi	r24, 0xFF	; 255
    1584:	a9 f4       	brne	.+42     	; 0x15b0 <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1586:	eb 81       	ldd	r30, Y+3	; 0x03
    1588:	fc 81       	ldd	r31, Y+4	; 0x04
    158a:	81 89       	ldd	r24, Z+17	; 0x11
    158c:	88 23       	and	r24, r24
    158e:	a9 f0       	breq	.+42     	; 0x15ba <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1590:	8b 81       	ldd	r24, Y+3	; 0x03
    1592:	9c 81       	ldd	r25, Y+4	; 0x04
    1594:	41 96       	adiw	r24, 0x11	; 17
    1596:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
    159a:	88 23       	and	r24, r24
    159c:	71 f0       	breq	.+28     	; 0x15ba <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    159e:	89 85       	ldd	r24, Y+9	; 0x09
    15a0:	9a 85       	ldd	r25, Y+10	; 0x0a
    15a2:	00 97       	sbiw	r24, 0x00	; 0
    15a4:	51 f0       	breq	.+20     	; 0x15ba <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    15a6:	e9 85       	ldd	r30, Y+9	; 0x09
    15a8:	fa 85       	ldd	r31, Y+10	; 0x0a
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	80 83       	st	Z, r24
    15ae:	05 c0       	rjmp	.+10     	; 0x15ba <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    15b0:	89 81       	ldd	r24, Y+1	; 0x01
    15b2:	8f 5f       	subi	r24, 0xFF	; 255
    15b4:	eb 81       	ldd	r30, Y+3	; 0x03
    15b6:	fc 81       	ldd	r31, Y+4	; 0x04
    15b8:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    15ba:	81 e0       	ldi	r24, 0x01	; 1
    15bc:	8e 83       	std	Y+6, r24	; 0x06
    15be:	01 c0       	rjmp	.+2      	; 0x15c2 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    15c0:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    15c2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    15c4:	2a 96       	adiw	r28, 0x0a	; 10
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	de bf       	out	0x3e, r29	; 62
    15cc:	0f be       	out	0x3f, r0	; 63
    15ce:	cd bf       	out	0x3d, r28	; 61
    15d0:	cf 91       	pop	r28
    15d2:	df 91       	pop	r29
    15d4:	08 95       	ret

000015d6 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    15d6:	df 93       	push	r29
    15d8:	cf 93       	push	r28
    15da:	cd b7       	in	r28, 0x3d	; 61
    15dc:	de b7       	in	r29, 0x3e	; 62
    15de:	2e 97       	sbiw	r28, 0x0e	; 14
    15e0:	0f b6       	in	r0, 0x3f	; 63
    15e2:	f8 94       	cli
    15e4:	de bf       	out	0x3e, r29	; 62
    15e6:	0f be       	out	0x3f, r0	; 63
    15e8:	cd bf       	out	0x3d, r28	; 61
    15ea:	99 87       	std	Y+9, r25	; 0x09
    15ec:	88 87       	std	Y+8, r24	; 0x08
    15ee:	7b 87       	std	Y+11, r23	; 0x0b
    15f0:	6a 87       	std	Y+10, r22	; 0x0a
    15f2:	5d 87       	std	Y+13, r21	; 0x0d
    15f4:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    15f6:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    15f8:	88 85       	ldd	r24, Y+8	; 0x08
    15fa:	99 85       	ldd	r25, Y+9	; 0x09
    15fc:	9b 83       	std	Y+3, r25	; 0x03
    15fe:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1600:	0f b6       	in	r0, 0x3f	; 63
    1602:	f8 94       	cli
    1604:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1606:	ea 81       	ldd	r30, Y+2	; 0x02
    1608:	fb 81       	ldd	r31, Y+3	; 0x03
    160a:	82 8d       	ldd	r24, Z+26	; 0x1a
    160c:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    160e:	89 81       	ldd	r24, Y+1	; 0x01
    1610:	88 23       	and	r24, r24
    1612:	d9 f0       	breq	.+54     	; 0x164a <xQueueReceive+0x74>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1614:	8a 81       	ldd	r24, Y+2	; 0x02
    1616:	9b 81       	ldd	r25, Y+3	; 0x03
    1618:	2a 85       	ldd	r18, Y+10	; 0x0a
    161a:	3b 85       	ldd	r19, Y+11	; 0x0b
    161c:	b9 01       	movw	r22, r18
    161e:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1622:	89 81       	ldd	r24, Y+1	; 0x01
    1624:	81 50       	subi	r24, 0x01	; 1
    1626:	ea 81       	ldd	r30, Y+2	; 0x02
    1628:	fb 81       	ldd	r31, Y+3	; 0x03
    162a:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    162c:	ea 81       	ldd	r30, Y+2	; 0x02
    162e:	fb 81       	ldd	r31, Y+3	; 0x03
    1630:	80 85       	ldd	r24, Z+8	; 0x08
    1632:	88 23       	and	r24, r24
    1634:	29 f0       	breq	.+10     	; 0x1640 <xQueueReceive+0x6a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1636:	8a 81       	ldd	r24, Y+2	; 0x02
    1638:	9b 81       	ldd	r25, Y+3	; 0x03
    163a:	08 96       	adiw	r24, 0x08	; 8
    163c:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1640:	0f 90       	pop	r0
    1642:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1644:	81 e0       	ldi	r24, 0x01	; 1
    1646:	8e 87       	std	Y+14, r24	; 0x0e
    1648:	63 c0       	rjmp	.+198    	; 0x1710 <xQueueReceive+0x13a>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    164a:	8c 85       	ldd	r24, Y+12	; 0x0c
    164c:	9d 85       	ldd	r25, Y+13	; 0x0d
    164e:	00 97       	sbiw	r24, 0x00	; 0
    1650:	21 f4       	brne	.+8      	; 0x165a <xQueueReceive+0x84>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1652:	0f 90       	pop	r0
    1654:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    1656:	1e 86       	std	Y+14, r1	; 0x0e
    1658:	5b c0       	rjmp	.+182    	; 0x1710 <xQueueReceive+0x13a>
                }
                else if( xEntryTimeSet == pdFALSE )
    165a:	8c 81       	ldd	r24, Y+4	; 0x04
    165c:	88 23       	and	r24, r24
    165e:	31 f4       	brne	.+12     	; 0x166c <xQueueReceive+0x96>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1660:	ce 01       	movw	r24, r28
    1662:	05 96       	adiw	r24, 0x05	; 5
    1664:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1668:	81 e0       	ldi	r24, 0x01	; 1
    166a:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    166c:	0f 90       	pop	r0
    166e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1670:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1674:	0f b6       	in	r0, 0x3f	; 63
    1676:	f8 94       	cli
    1678:	0f 92       	push	r0
    167a:	ea 81       	ldd	r30, Y+2	; 0x02
    167c:	fb 81       	ldd	r31, Y+3	; 0x03
    167e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1680:	8f 3f       	cpi	r24, 0xFF	; 255
    1682:	19 f4       	brne	.+6      	; 0x168a <xQueueReceive+0xb4>
    1684:	ea 81       	ldd	r30, Y+2	; 0x02
    1686:	fb 81       	ldd	r31, Y+3	; 0x03
    1688:	15 8e       	std	Z+29, r1	; 0x1d
    168a:	ea 81       	ldd	r30, Y+2	; 0x02
    168c:	fb 81       	ldd	r31, Y+3	; 0x03
    168e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1690:	8f 3f       	cpi	r24, 0xFF	; 255
    1692:	19 f4       	brne	.+6      	; 0x169a <xQueueReceive+0xc4>
    1694:	ea 81       	ldd	r30, Y+2	; 0x02
    1696:	fb 81       	ldd	r31, Y+3	; 0x03
    1698:	16 8e       	std	Z+30, r1	; 0x1e
    169a:	0f 90       	pop	r0
    169c:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    169e:	ce 01       	movw	r24, r28
    16a0:	05 96       	adiw	r24, 0x05	; 5
    16a2:	9e 01       	movw	r18, r28
    16a4:	24 5f       	subi	r18, 0xF4	; 244
    16a6:	3f 4f       	sbci	r19, 0xFF	; 255
    16a8:	b9 01       	movw	r22, r18
    16aa:	0e 94 f7 20 	call	0x41ee	; 0x41ee <xTaskCheckForTimeOut>
    16ae:	88 23       	and	r24, r24
    16b0:	09 f5       	brne	.+66     	; 0x16f4 <xQueueReceive+0x11e>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16b2:	8a 81       	ldd	r24, Y+2	; 0x02
    16b4:	9b 81       	ldd	r25, Y+3	; 0x03
    16b6:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <prvIsQueueEmpty>
    16ba:	88 23       	and	r24, r24
    16bc:	a1 f0       	breq	.+40     	; 0x16e6 <xQueueReceive+0x110>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    16be:	8a 81       	ldd	r24, Y+2	; 0x02
    16c0:	9b 81       	ldd	r25, Y+3	; 0x03
    16c2:	41 96       	adiw	r24, 0x11	; 17
    16c4:	2c 85       	ldd	r18, Y+12	; 0x0c
    16c6:	3d 85       	ldd	r19, Y+13	; 0x0d
    16c8:	b9 01       	movw	r22, r18
    16ca:	0e 94 e7 1d 	call	0x3bce	; 0x3bce <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    16ce:	8a 81       	ldd	r24, Y+2	; 0x02
    16d0:	9b 81       	ldd	r25, Y+3	; 0x03
    16d2:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    16d6:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    16da:	88 23       	and	r24, r24
    16dc:	09 f0       	breq	.+2      	; 0x16e0 <xQueueReceive+0x10a>
    16de:	90 cf       	rjmp	.-224    	; 0x1600 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    16e0:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>
    16e4:	8d cf       	rjmp	.-230    	; 0x1600 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    16e6:	8a 81       	ldd	r24, Y+2	; 0x02
    16e8:	9b 81       	ldd	r25, Y+3	; 0x03
    16ea:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    16ee:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    16f2:	86 cf       	rjmp	.-244    	; 0x1600 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    16f4:	8a 81       	ldd	r24, Y+2	; 0x02
    16f6:	9b 81       	ldd	r25, Y+3	; 0x03
    16f8:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    16fc:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1700:	8a 81       	ldd	r24, Y+2	; 0x02
    1702:	9b 81       	ldd	r25, Y+3	; 0x03
    1704:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <prvIsQueueEmpty>
    1708:	88 23       	and	r24, r24
    170a:	09 f4       	brne	.+2      	; 0x170e <xQueueReceive+0x138>
    170c:	79 cf       	rjmp	.-270    	; 0x1600 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    170e:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    1710:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1712:	2e 96       	adiw	r28, 0x0e	; 14
    1714:	0f b6       	in	r0, 0x3f	; 63
    1716:	f8 94       	cli
    1718:	de bf       	out	0x3e, r29	; 62
    171a:	0f be       	out	0x3f, r0	; 63
    171c:	cd bf       	out	0x3d, r28	; 61
    171e:	cf 91       	pop	r28
    1720:	df 91       	pop	r29
    1722:	08 95       	ret

00001724 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    1724:	df 93       	push	r29
    1726:	cf 93       	push	r28
    1728:	cd b7       	in	r28, 0x3d	; 61
    172a:	de b7       	in	r29, 0x3e	; 62
    172c:	2c 97       	sbiw	r28, 0x0c	; 12
    172e:	0f b6       	in	r0, 0x3f	; 63
    1730:	f8 94       	cli
    1732:	de bf       	out	0x3e, r29	; 62
    1734:	0f be       	out	0x3f, r0	; 63
    1736:	cd bf       	out	0x3d, r28	; 61
    1738:	99 87       	std	Y+9, r25	; 0x09
    173a:	88 87       	std	Y+8, r24	; 0x08
    173c:	7b 87       	std	Y+11, r23	; 0x0b
    173e:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    1740:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1742:	88 85       	ldd	r24, Y+8	; 0x08
    1744:	99 85       	ldd	r25, Y+9	; 0x09
    1746:	9b 83       	std	Y+3, r25	; 0x03
    1748:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    174a:	0f b6       	in	r0, 0x3f	; 63
    174c:	f8 94       	cli
    174e:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1750:	ea 81       	ldd	r30, Y+2	; 0x02
    1752:	fb 81       	ldd	r31, Y+3	; 0x03
    1754:	82 8d       	ldd	r24, Z+26	; 0x1a
    1756:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1758:	89 81       	ldd	r24, Y+1	; 0x01
    175a:	88 23       	and	r24, r24
    175c:	a1 f0       	breq	.+40     	; 0x1786 <xQueueSemaphoreTake+0x62>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    175e:	89 81       	ldd	r24, Y+1	; 0x01
    1760:	81 50       	subi	r24, 0x01	; 1
    1762:	ea 81       	ldd	r30, Y+2	; 0x02
    1764:	fb 81       	ldd	r31, Y+3	; 0x03
    1766:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1768:	ea 81       	ldd	r30, Y+2	; 0x02
    176a:	fb 81       	ldd	r31, Y+3	; 0x03
    176c:	80 85       	ldd	r24, Z+8	; 0x08
    176e:	88 23       	and	r24, r24
    1770:	29 f0       	breq	.+10     	; 0x177c <xQueueSemaphoreTake+0x58>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1772:	8a 81       	ldd	r24, Y+2	; 0x02
    1774:	9b 81       	ldd	r25, Y+3	; 0x03
    1776:	08 96       	adiw	r24, 0x08	; 8
    1778:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    177c:	0f 90       	pop	r0
    177e:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1780:	81 e0       	ldi	r24, 0x01	; 1
    1782:	8c 87       	std	Y+12, r24	; 0x0c
    1784:	63 c0       	rjmp	.+198    	; 0x184c <xQueueSemaphoreTake+0x128>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1786:	8a 85       	ldd	r24, Y+10	; 0x0a
    1788:	9b 85       	ldd	r25, Y+11	; 0x0b
    178a:	00 97       	sbiw	r24, 0x00	; 0
    178c:	21 f4       	brne	.+8      	; 0x1796 <xQueueSemaphoreTake+0x72>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    178e:	0f 90       	pop	r0
    1790:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    1792:	1c 86       	std	Y+12, r1	; 0x0c
    1794:	5b c0       	rjmp	.+182    	; 0x184c <xQueueSemaphoreTake+0x128>
                }
                else if( xEntryTimeSet == pdFALSE )
    1796:	8c 81       	ldd	r24, Y+4	; 0x04
    1798:	88 23       	and	r24, r24
    179a:	31 f4       	brne	.+12     	; 0x17a8 <xQueueSemaphoreTake+0x84>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    179c:	ce 01       	movw	r24, r28
    179e:	05 96       	adiw	r24, 0x05	; 5
    17a0:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    17a4:	81 e0       	ldi	r24, 0x01	; 1
    17a6:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    17a8:	0f 90       	pop	r0
    17aa:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    17ac:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    17b0:	0f b6       	in	r0, 0x3f	; 63
    17b2:	f8 94       	cli
    17b4:	0f 92       	push	r0
    17b6:	ea 81       	ldd	r30, Y+2	; 0x02
    17b8:	fb 81       	ldd	r31, Y+3	; 0x03
    17ba:	85 8d       	ldd	r24, Z+29	; 0x1d
    17bc:	8f 3f       	cpi	r24, 0xFF	; 255
    17be:	19 f4       	brne	.+6      	; 0x17c6 <xQueueSemaphoreTake+0xa2>
    17c0:	ea 81       	ldd	r30, Y+2	; 0x02
    17c2:	fb 81       	ldd	r31, Y+3	; 0x03
    17c4:	15 8e       	std	Z+29, r1	; 0x1d
    17c6:	ea 81       	ldd	r30, Y+2	; 0x02
    17c8:	fb 81       	ldd	r31, Y+3	; 0x03
    17ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    17cc:	8f 3f       	cpi	r24, 0xFF	; 255
    17ce:	19 f4       	brne	.+6      	; 0x17d6 <xQueueSemaphoreTake+0xb2>
    17d0:	ea 81       	ldd	r30, Y+2	; 0x02
    17d2:	fb 81       	ldd	r31, Y+3	; 0x03
    17d4:	16 8e       	std	Z+30, r1	; 0x1e
    17d6:	0f 90       	pop	r0
    17d8:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17da:	ce 01       	movw	r24, r28
    17dc:	05 96       	adiw	r24, 0x05	; 5
    17de:	9e 01       	movw	r18, r28
    17e0:	26 5f       	subi	r18, 0xF6	; 246
    17e2:	3f 4f       	sbci	r19, 0xFF	; 255
    17e4:	b9 01       	movw	r22, r18
    17e6:	0e 94 f7 20 	call	0x41ee	; 0x41ee <xTaskCheckForTimeOut>
    17ea:	88 23       	and	r24, r24
    17ec:	09 f5       	brne	.+66     	; 0x1830 <xQueueSemaphoreTake+0x10c>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17ee:	8a 81       	ldd	r24, Y+2	; 0x02
    17f0:	9b 81       	ldd	r25, Y+3	; 0x03
    17f2:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <prvIsQueueEmpty>
    17f6:	88 23       	and	r24, r24
    17f8:	a1 f0       	breq	.+40     	; 0x1822 <xQueueSemaphoreTake+0xfe>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17fa:	8a 81       	ldd	r24, Y+2	; 0x02
    17fc:	9b 81       	ldd	r25, Y+3	; 0x03
    17fe:	41 96       	adiw	r24, 0x11	; 17
    1800:	2a 85       	ldd	r18, Y+10	; 0x0a
    1802:	3b 85       	ldd	r19, Y+11	; 0x0b
    1804:	b9 01       	movw	r22, r18
    1806:	0e 94 e7 1d 	call	0x3bce	; 0x3bce <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    180a:	8a 81       	ldd	r24, Y+2	; 0x02
    180c:	9b 81       	ldd	r25, Y+3	; 0x03
    180e:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1812:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    1816:	88 23       	and	r24, r24
    1818:	09 f0       	breq	.+2      	; 0x181c <xQueueSemaphoreTake+0xf8>
    181a:	97 cf       	rjmp	.-210    	; 0x174a <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    181c:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>
    1820:	94 cf       	rjmp	.-216    	; 0x174a <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    1822:	8a 81       	ldd	r24, Y+2	; 0x02
    1824:	9b 81       	ldd	r25, Y+3	; 0x03
    1826:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    182a:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    182e:	8d cf       	rjmp	.-230    	; 0x174a <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    1830:	8a 81       	ldd	r24, Y+2	; 0x02
    1832:	9b 81       	ldd	r25, Y+3	; 0x03
    1834:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1838:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    183c:	8a 81       	ldd	r24, Y+2	; 0x02
    183e:	9b 81       	ldd	r25, Y+3	; 0x03
    1840:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <prvIsQueueEmpty>
    1844:	88 23       	and	r24, r24
    1846:	09 f4       	brne	.+2      	; 0x184a <xQueueSemaphoreTake+0x126>
    1848:	80 cf       	rjmp	.-256    	; 0x174a <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    184a:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    184c:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    184e:	2c 96       	adiw	r28, 0x0c	; 12
    1850:	0f b6       	in	r0, 0x3f	; 63
    1852:	f8 94       	cli
    1854:	de bf       	out	0x3e, r29	; 62
    1856:	0f be       	out	0x3f, r0	; 63
    1858:	cd bf       	out	0x3d, r28	; 61
    185a:	cf 91       	pop	r28
    185c:	df 91       	pop	r29
    185e:	08 95       	ret

00001860 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    1860:	df 93       	push	r29
    1862:	cf 93       	push	r28
    1864:	cd b7       	in	r28, 0x3d	; 61
    1866:	de b7       	in	r29, 0x3e	; 62
    1868:	60 97       	sbiw	r28, 0x10	; 16
    186a:	0f b6       	in	r0, 0x3f	; 63
    186c:	f8 94       	cli
    186e:	de bf       	out	0x3e, r29	; 62
    1870:	0f be       	out	0x3f, r0	; 63
    1872:	cd bf       	out	0x3d, r28	; 61
    1874:	9b 87       	std	Y+11, r25	; 0x0b
    1876:	8a 87       	std	Y+10, r24	; 0x0a
    1878:	7d 87       	std	Y+13, r23	; 0x0d
    187a:	6c 87       	std	Y+12, r22	; 0x0c
    187c:	5f 87       	std	Y+15, r21	; 0x0f
    187e:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    1880:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    1882:	8a 85       	ldd	r24, Y+10	; 0x0a
    1884:	9b 85       	ldd	r25, Y+11	; 0x0b
    1886:	9b 83       	std	Y+3, r25	; 0x03
    1888:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    188a:	0f b6       	in	r0, 0x3f	; 63
    188c:	f8 94       	cli
    188e:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1890:	ea 81       	ldd	r30, Y+2	; 0x02
    1892:	fb 81       	ldd	r31, Y+3	; 0x03
    1894:	82 8d       	ldd	r24, Z+26	; 0x1a
    1896:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1898:	89 81       	ldd	r24, Y+1	; 0x01
    189a:	88 23       	and	r24, r24
    189c:	11 f1       	breq	.+68     	; 0x18e2 <xQueuePeek+0x82>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    189e:	ea 81       	ldd	r30, Y+2	; 0x02
    18a0:	fb 81       	ldd	r31, Y+3	; 0x03
    18a2:	86 81       	ldd	r24, Z+6	; 0x06
    18a4:	97 81       	ldd	r25, Z+7	; 0x07
    18a6:	9d 83       	std	Y+5, r25	; 0x05
    18a8:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    18aa:	8a 81       	ldd	r24, Y+2	; 0x02
    18ac:	9b 81       	ldd	r25, Y+3	; 0x03
    18ae:	2c 85       	ldd	r18, Y+12	; 0x0c
    18b0:	3d 85       	ldd	r19, Y+13	; 0x0d
    18b2:	b9 01       	movw	r22, r18
    18b4:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    18b8:	ea 81       	ldd	r30, Y+2	; 0x02
    18ba:	fb 81       	ldd	r31, Y+3	; 0x03
    18bc:	8c 81       	ldd	r24, Y+4	; 0x04
    18be:	9d 81       	ldd	r25, Y+5	; 0x05
    18c0:	97 83       	std	Z+7, r25	; 0x07
    18c2:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18c4:	ea 81       	ldd	r30, Y+2	; 0x02
    18c6:	fb 81       	ldd	r31, Y+3	; 0x03
    18c8:	81 89       	ldd	r24, Z+17	; 0x11
    18ca:	88 23       	and	r24, r24
    18cc:	29 f0       	breq	.+10     	; 0x18d8 <xQueuePeek+0x78>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18ce:	8a 81       	ldd	r24, Y+2	; 0x02
    18d0:	9b 81       	ldd	r25, Y+3	; 0x03
    18d2:	41 96       	adiw	r24, 0x11	; 17
    18d4:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    18d8:	0f 90       	pop	r0
    18da:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	88 8b       	std	Y+16, r24	; 0x10
    18e0:	63 c0       	rjmp	.+198    	; 0x19a8 <xQueuePeek+0x148>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    18e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    18e4:	9f 85       	ldd	r25, Y+15	; 0x0f
    18e6:	00 97       	sbiw	r24, 0x00	; 0
    18e8:	21 f4       	brne	.+8      	; 0x18f2 <xQueuePeek+0x92>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    18ea:	0f 90       	pop	r0
    18ec:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    18ee:	18 8a       	std	Y+16, r1	; 0x10
    18f0:	5b c0       	rjmp	.+182    	; 0x19a8 <xQueuePeek+0x148>
                }
                else if( xEntryTimeSet == pdFALSE )
    18f2:	8e 81       	ldd	r24, Y+6	; 0x06
    18f4:	88 23       	and	r24, r24
    18f6:	31 f4       	brne	.+12     	; 0x1904 <xQueuePeek+0xa4>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    18f8:	ce 01       	movw	r24, r28
    18fa:	07 96       	adiw	r24, 0x07	; 7
    18fc:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1900:	81 e0       	ldi	r24, 0x01	; 1
    1902:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1904:	0f 90       	pop	r0
    1906:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    1908:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    190c:	0f b6       	in	r0, 0x3f	; 63
    190e:	f8 94       	cli
    1910:	0f 92       	push	r0
    1912:	ea 81       	ldd	r30, Y+2	; 0x02
    1914:	fb 81       	ldd	r31, Y+3	; 0x03
    1916:	85 8d       	ldd	r24, Z+29	; 0x1d
    1918:	8f 3f       	cpi	r24, 0xFF	; 255
    191a:	19 f4       	brne	.+6      	; 0x1922 <xQueuePeek+0xc2>
    191c:	ea 81       	ldd	r30, Y+2	; 0x02
    191e:	fb 81       	ldd	r31, Y+3	; 0x03
    1920:	15 8e       	std	Z+29, r1	; 0x1d
    1922:	ea 81       	ldd	r30, Y+2	; 0x02
    1924:	fb 81       	ldd	r31, Y+3	; 0x03
    1926:	86 8d       	ldd	r24, Z+30	; 0x1e
    1928:	8f 3f       	cpi	r24, 0xFF	; 255
    192a:	19 f4       	brne	.+6      	; 0x1932 <xQueuePeek+0xd2>
    192c:	ea 81       	ldd	r30, Y+2	; 0x02
    192e:	fb 81       	ldd	r31, Y+3	; 0x03
    1930:	16 8e       	std	Z+30, r1	; 0x1e
    1932:	0f 90       	pop	r0
    1934:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1936:	ce 01       	movw	r24, r28
    1938:	07 96       	adiw	r24, 0x07	; 7
    193a:	9e 01       	movw	r18, r28
    193c:	22 5f       	subi	r18, 0xF2	; 242
    193e:	3f 4f       	sbci	r19, 0xFF	; 255
    1940:	b9 01       	movw	r22, r18
    1942:	0e 94 f7 20 	call	0x41ee	; 0x41ee <xTaskCheckForTimeOut>
    1946:	88 23       	and	r24, r24
    1948:	09 f5       	brne	.+66     	; 0x198c <xQueuePeek+0x12c>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    194a:	8a 81       	ldd	r24, Y+2	; 0x02
    194c:	9b 81       	ldd	r25, Y+3	; 0x03
    194e:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <prvIsQueueEmpty>
    1952:	88 23       	and	r24, r24
    1954:	a1 f0       	breq	.+40     	; 0x197e <xQueuePeek+0x11e>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1956:	8a 81       	ldd	r24, Y+2	; 0x02
    1958:	9b 81       	ldd	r25, Y+3	; 0x03
    195a:	41 96       	adiw	r24, 0x11	; 17
    195c:	2e 85       	ldd	r18, Y+14	; 0x0e
    195e:	3f 85       	ldd	r19, Y+15	; 0x0f
    1960:	b9 01       	movw	r22, r18
    1962:	0e 94 e7 1d 	call	0x3bce	; 0x3bce <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1966:	8a 81       	ldd	r24, Y+2	; 0x02
    1968:	9b 81       	ldd	r25, Y+3	; 0x03
    196a:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    196e:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    1972:	88 23       	and	r24, r24
    1974:	09 f0       	breq	.+2      	; 0x1978 <xQueuePeek+0x118>
    1976:	89 cf       	rjmp	.-238    	; 0x188a <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    1978:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>
    197c:	86 cf       	rjmp	.-244    	; 0x188a <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    197e:	8a 81       	ldd	r24, Y+2	; 0x02
    1980:	9b 81       	ldd	r25, Y+3	; 0x03
    1982:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1986:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    198a:	7f cf       	rjmp	.-258    	; 0x188a <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    198c:	8a 81       	ldd	r24, Y+2	; 0x02
    198e:	9b 81       	ldd	r25, Y+3	; 0x03
    1990:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1994:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1998:	8a 81       	ldd	r24, Y+2	; 0x02
    199a:	9b 81       	ldd	r25, Y+3	; 0x03
    199c:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <prvIsQueueEmpty>
    19a0:	88 23       	and	r24, r24
    19a2:	09 f4       	brne	.+2      	; 0x19a6 <xQueuePeek+0x146>
    19a4:	72 cf       	rjmp	.-284    	; 0x188a <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    19a6:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    19a8:	88 89       	ldd	r24, Y+16	; 0x10
}
    19aa:	60 96       	adiw	r28, 0x10	; 16
    19ac:	0f b6       	in	r0, 0x3f	; 63
    19ae:	f8 94       	cli
    19b0:	de bf       	out	0x3e, r29	; 62
    19b2:	0f be       	out	0x3f, r0	; 63
    19b4:	cd bf       	out	0x3d, r28	; 61
    19b6:	cf 91       	pop	r28
    19b8:	df 91       	pop	r29
    19ba:	08 95       	ret

000019bc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    19bc:	df 93       	push	r29
    19be:	cf 93       	push	r28
    19c0:	cd b7       	in	r28, 0x3d	; 61
    19c2:	de b7       	in	r29, 0x3e	; 62
    19c4:	2c 97       	sbiw	r28, 0x0c	; 12
    19c6:	0f b6       	in	r0, 0x3f	; 63
    19c8:	f8 94       	cli
    19ca:	de bf       	out	0x3e, r29	; 62
    19cc:	0f be       	out	0x3f, r0	; 63
    19ce:	cd bf       	out	0x3d, r28	; 61
    19d0:	98 87       	std	Y+8, r25	; 0x08
    19d2:	8f 83       	std	Y+7, r24	; 0x07
    19d4:	7a 87       	std	Y+10, r23	; 0x0a
    19d6:	69 87       	std	Y+9, r22	; 0x09
    19d8:	5c 87       	std	Y+12, r21	; 0x0c
    19da:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    19dc:	8f 81       	ldd	r24, Y+7	; 0x07
    19de:	98 85       	ldd	r25, Y+8	; 0x08
    19e0:	9c 83       	std	Y+4, r25	; 0x04
    19e2:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    19e4:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    19e6:	eb 81       	ldd	r30, Y+3	; 0x03
    19e8:	fc 81       	ldd	r31, Y+4	; 0x04
    19ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    19ec:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    19ee:	8a 81       	ldd	r24, Y+2	; 0x02
    19f0:	88 23       	and	r24, r24
    19f2:	81 f1       	breq	.+96     	; 0x1a54 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    19f4:	eb 81       	ldd	r30, Y+3	; 0x03
    19f6:	fc 81       	ldd	r31, Y+4	; 0x04
    19f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    19fa:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    19fc:	8b 81       	ldd	r24, Y+3	; 0x03
    19fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1a00:	29 85       	ldd	r18, Y+9	; 0x09
    1a02:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a04:	b9 01       	movw	r22, r18
    1a06:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a0c:	81 50       	subi	r24, 0x01	; 1
    1a0e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a10:	fc 81       	ldd	r31, Y+4	; 0x04
    1a12:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    1a14:	89 81       	ldd	r24, Y+1	; 0x01
    1a16:	8f 3f       	cpi	r24, 0xFF	; 255
    1a18:	a9 f4       	brne	.+42     	; 0x1a44 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a1e:	80 85       	ldd	r24, Z+8	; 0x08
    1a20:	88 23       	and	r24, r24
    1a22:	a9 f0       	breq	.+42     	; 0x1a4e <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a24:	8b 81       	ldd	r24, Y+3	; 0x03
    1a26:	9c 81       	ldd	r25, Y+4	; 0x04
    1a28:	08 96       	adiw	r24, 0x08	; 8
    1a2a:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
    1a2e:	88 23       	and	r24, r24
    1a30:	71 f0       	breq	.+28     	; 0x1a4e <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    1a32:	8b 85       	ldd	r24, Y+11	; 0x0b
    1a34:	9c 85       	ldd	r25, Y+12	; 0x0c
    1a36:	00 97       	sbiw	r24, 0x00	; 0
    1a38:	51 f0       	breq	.+20     	; 0x1a4e <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    1a3a:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a3c:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a3e:	81 e0       	ldi	r24, 0x01	; 1
    1a40:	80 83       	st	Z, r24
    1a42:	05 c0       	rjmp	.+10     	; 0x1a4e <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1a44:	89 81       	ldd	r24, Y+1	; 0x01
    1a46:	8f 5f       	subi	r24, 0xFF	; 255
    1a48:	eb 81       	ldd	r30, Y+3	; 0x03
    1a4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a4c:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    1a4e:	81 e0       	ldi	r24, 0x01	; 1
    1a50:	8e 83       	std	Y+6, r24	; 0x06
    1a52:	01 c0       	rjmp	.+2      	; 0x1a56 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    1a54:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1a56:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1a58:	2c 96       	adiw	r28, 0x0c	; 12
    1a5a:	0f b6       	in	r0, 0x3f	; 63
    1a5c:	f8 94       	cli
    1a5e:	de bf       	out	0x3e, r29	; 62
    1a60:	0f be       	out	0x3f, r0	; 63
    1a62:	cd bf       	out	0x3d, r28	; 61
    1a64:	cf 91       	pop	r28
    1a66:	df 91       	pop	r29
    1a68:	08 95       	ret

00001a6a <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    1a6a:	df 93       	push	r29
    1a6c:	cf 93       	push	r28
    1a6e:	cd b7       	in	r28, 0x3d	; 61
    1a70:	de b7       	in	r29, 0x3e	; 62
    1a72:	2a 97       	sbiw	r28, 0x0a	; 10
    1a74:	0f b6       	in	r0, 0x3f	; 63
    1a76:	f8 94       	cli
    1a78:	de bf       	out	0x3e, r29	; 62
    1a7a:	0f be       	out	0x3f, r0	; 63
    1a7c:	cd bf       	out	0x3d, r28	; 61
    1a7e:	98 87       	std	Y+8, r25	; 0x08
    1a80:	8f 83       	std	Y+7, r24	; 0x07
    1a82:	7a 87       	std	Y+10, r23	; 0x0a
    1a84:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    1a86:	8f 81       	ldd	r24, Y+7	; 0x07
    1a88:	98 85       	ldd	r25, Y+8	; 0x08
    1a8a:	9a 83       	std	Y+2, r25	; 0x02
    1a8c:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a8e:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a90:	e9 81       	ldd	r30, Y+1	; 0x01
    1a92:	fa 81       	ldd	r31, Y+2	; 0x02
    1a94:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a96:	88 23       	and	r24, r24
    1a98:	b1 f0       	breq	.+44     	; 0x1ac6 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a9e:	86 81       	ldd	r24, Z+6	; 0x06
    1aa0:	97 81       	ldd	r25, Z+7	; 0x07
    1aa2:	9c 83       	std	Y+4, r25	; 0x04
    1aa4:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    1aa6:	89 81       	ldd	r24, Y+1	; 0x01
    1aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    1aaa:	29 85       	ldd	r18, Y+9	; 0x09
    1aac:	3a 85       	ldd	r19, Y+10	; 0x0a
    1aae:	b9 01       	movw	r22, r18
    1ab0:	0e 94 82 0e 	call	0x1d04	; 0x1d04 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1ab4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aba:	9c 81       	ldd	r25, Y+4	; 0x04
    1abc:	97 83       	std	Z+7, r25	; 0x07
    1abe:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    1ac0:	81 e0       	ldi	r24, 0x01	; 1
    1ac2:	8e 83       	std	Y+6, r24	; 0x06
    1ac4:	01 c0       	rjmp	.+2      	; 0x1ac8 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    1ac6:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1ac8:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1aca:	2a 96       	adiw	r28, 0x0a	; 10
    1acc:	0f b6       	in	r0, 0x3f	; 63
    1ace:	f8 94       	cli
    1ad0:	de bf       	out	0x3e, r29	; 62
    1ad2:	0f be       	out	0x3f, r0	; 63
    1ad4:	cd bf       	out	0x3d, r28	; 61
    1ad6:	cf 91       	pop	r28
    1ad8:	df 91       	pop	r29
    1ada:	08 95       	ret

00001adc <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1adc:	df 93       	push	r29
    1ade:	cf 93       	push	r28
    1ae0:	00 d0       	rcall	.+0      	; 0x1ae2 <uxQueueMessagesWaiting+0x6>
    1ae2:	0f 92       	push	r0
    1ae4:	cd b7       	in	r28, 0x3d	; 61
    1ae6:	de b7       	in	r29, 0x3e	; 62
    1ae8:	9b 83       	std	Y+3, r25	; 0x03
    1aea:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    1aec:	0f b6       	in	r0, 0x3f	; 63
    1aee:	f8 94       	cli
    1af0:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1af2:	ea 81       	ldd	r30, Y+2	; 0x02
    1af4:	fb 81       	ldd	r31, Y+3	; 0x03
    1af6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1af8:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    1afa:	0f 90       	pop	r0
    1afc:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1afe:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b00:	0f 90       	pop	r0
    1b02:	0f 90       	pop	r0
    1b04:	0f 90       	pop	r0
    1b06:	cf 91       	pop	r28
    1b08:	df 91       	pop	r29
    1b0a:	08 95       	ret

00001b0c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1b0c:	df 93       	push	r29
    1b0e:	cf 93       	push	r28
    1b10:	00 d0       	rcall	.+0      	; 0x1b12 <uxQueueSpacesAvailable+0x6>
    1b12:	00 d0       	rcall	.+0      	; 0x1b14 <uxQueueSpacesAvailable+0x8>
    1b14:	0f 92       	push	r0
    1b16:	cd b7       	in	r28, 0x3d	; 61
    1b18:	de b7       	in	r29, 0x3e	; 62
    1b1a:	9d 83       	std	Y+5, r25	; 0x05
    1b1c:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    1b1e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b20:	9d 81       	ldd	r25, Y+5	; 0x05
    1b22:	9a 83       	std	Y+2, r25	; 0x02
    1b24:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    1b26:	0f b6       	in	r0, 0x3f	; 63
    1b28:	f8 94       	cli
    1b2a:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1b2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b30:	93 8d       	ldd	r25, Z+27	; 0x1b
    1b32:	e9 81       	ldd	r30, Y+1	; 0x01
    1b34:	fa 81       	ldd	r31, Y+2	; 0x02
    1b36:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b38:	29 2f       	mov	r18, r25
    1b3a:	28 1b       	sub	r18, r24
    1b3c:	82 2f       	mov	r24, r18
    1b3e:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    1b40:	0f 90       	pop	r0
    1b42:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1b44:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b46:	0f 90       	pop	r0
    1b48:	0f 90       	pop	r0
    1b4a:	0f 90       	pop	r0
    1b4c:	0f 90       	pop	r0
    1b4e:	0f 90       	pop	r0
    1b50:	cf 91       	pop	r28
    1b52:	df 91       	pop	r29
    1b54:	08 95       	ret

00001b56 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1b56:	df 93       	push	r29
    1b58:	cf 93       	push	r28
    1b5a:	00 d0       	rcall	.+0      	; 0x1b5c <uxQueueMessagesWaitingFromISR+0x6>
    1b5c:	00 d0       	rcall	.+0      	; 0x1b5e <uxQueueMessagesWaitingFromISR+0x8>
    1b5e:	0f 92       	push	r0
    1b60:	cd b7       	in	r28, 0x3d	; 61
    1b62:	de b7       	in	r29, 0x3e	; 62
    1b64:	9d 83       	std	Y+5, r25	; 0x05
    1b66:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    1b68:	8c 81       	ldd	r24, Y+4	; 0x04
    1b6a:	9d 81       	ldd	r25, Y+5	; 0x05
    1b6c:	9a 83       	std	Y+2, r25	; 0x02
    1b6e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    1b70:	e9 81       	ldd	r30, Y+1	; 0x01
    1b72:	fa 81       	ldd	r31, Y+2	; 0x02
    1b74:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b76:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    1b78:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b7a:	0f 90       	pop	r0
    1b7c:	0f 90       	pop	r0
    1b7e:	0f 90       	pop	r0
    1b80:	0f 90       	pop	r0
    1b82:	0f 90       	pop	r0
    1b84:	cf 91       	pop	r28
    1b86:	df 91       	pop	r29
    1b88:	08 95       	ret

00001b8a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1b8a:	df 93       	push	r29
    1b8c:	cf 93       	push	r28
    1b8e:	00 d0       	rcall	.+0      	; 0x1b90 <vQueueDelete+0x6>
    1b90:	00 d0       	rcall	.+0      	; 0x1b92 <vQueueDelete+0x8>
    1b92:	cd b7       	in	r28, 0x3d	; 61
    1b94:	de b7       	in	r29, 0x3e	; 62
    1b96:	9c 83       	std	Y+4, r25	; 0x04
    1b98:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1b9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b9e:	9a 83       	std	Y+2, r25	; 0x02
    1ba0:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
    1ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba6:	0e 94 31 04 	call	0x862	; 0x862 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1baa:	0f 90       	pop	r0
    1bac:	0f 90       	pop	r0
    1bae:	0f 90       	pop	r0
    1bb0:	0f 90       	pop	r0
    1bb2:	cf 91       	pop	r28
    1bb4:	df 91       	pop	r29
    1bb6:	08 95       	ret

00001bb8 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    1bb8:	df 93       	push	r29
    1bba:	cf 93       	push	r28
    1bbc:	cd b7       	in	r28, 0x3d	; 61
    1bbe:	de b7       	in	r29, 0x3e	; 62
    1bc0:	27 97       	sbiw	r28, 0x07	; 7
    1bc2:	0f b6       	in	r0, 0x3f	; 63
    1bc4:	f8 94       	cli
    1bc6:	de bf       	out	0x3e, r29	; 62
    1bc8:	0f be       	out	0x3f, r0	; 63
    1bca:	cd bf       	out	0x3d, r28	; 61
    1bcc:	9c 83       	std	Y+4, r25	; 0x04
    1bce:	8b 83       	std	Y+3, r24	; 0x03
    1bd0:	7e 83       	std	Y+6, r23	; 0x06
    1bd2:	6d 83       	std	Y+5, r22	; 0x05
    1bd4:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    1bd6:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1bd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bda:	fc 81       	ldd	r31, Y+4	; 0x04
    1bdc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bde:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1be0:	eb 81       	ldd	r30, Y+3	; 0x03
    1be2:	fc 81       	ldd	r31, Y+4	; 0x04
    1be4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1be6:	88 23       	and	r24, r24
    1be8:	09 f4       	brne	.+2      	; 0x1bec <prvCopyDataToQueue+0x34>
    1bea:	7d c0       	rjmp	.+250    	; 0x1ce6 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    1bec:	8f 81       	ldd	r24, Y+7	; 0x07
    1bee:	88 23       	and	r24, r24
    1bf0:	99 f5       	brne	.+102    	; 0x1c58 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1bf2:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf4:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf6:	62 81       	ldd	r22, Z+2	; 0x02
    1bf8:	73 81       	ldd	r23, Z+3	; 0x03
    1bfa:	eb 81       	ldd	r30, Y+3	; 0x03
    1bfc:	fc 81       	ldd	r31, Y+4	; 0x04
    1bfe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c00:	48 2f       	mov	r20, r24
    1c02:	50 e0       	ldi	r21, 0x00	; 0
    1c04:	2d 81       	ldd	r18, Y+5	; 0x05
    1c06:	3e 81       	ldd	r19, Y+6	; 0x06
    1c08:	cb 01       	movw	r24, r22
    1c0a:	b9 01       	movw	r22, r18
    1c0c:	0e 94 88 37 	call	0x6f10	; 0x6f10 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1c10:	eb 81       	ldd	r30, Y+3	; 0x03
    1c12:	fc 81       	ldd	r31, Y+4	; 0x04
    1c14:	22 81       	ldd	r18, Z+2	; 0x02
    1c16:	33 81       	ldd	r19, Z+3	; 0x03
    1c18:	eb 81       	ldd	r30, Y+3	; 0x03
    1c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c1e:	88 2f       	mov	r24, r24
    1c20:	90 e0       	ldi	r25, 0x00	; 0
    1c22:	82 0f       	add	r24, r18
    1c24:	93 1f       	adc	r25, r19
    1c26:	eb 81       	ldd	r30, Y+3	; 0x03
    1c28:	fc 81       	ldd	r31, Y+4	; 0x04
    1c2a:	93 83       	std	Z+3, r25	; 0x03
    1c2c:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1c2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c30:	fc 81       	ldd	r31, Y+4	; 0x04
    1c32:	22 81       	ldd	r18, Z+2	; 0x02
    1c34:	33 81       	ldd	r19, Z+3	; 0x03
    1c36:	eb 81       	ldd	r30, Y+3	; 0x03
    1c38:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3a:	84 81       	ldd	r24, Z+4	; 0x04
    1c3c:	95 81       	ldd	r25, Z+5	; 0x05
    1c3e:	28 17       	cp	r18, r24
    1c40:	39 07       	cpc	r19, r25
    1c42:	08 f4       	brcc	.+2      	; 0x1c46 <prvCopyDataToQueue+0x8e>
    1c44:	50 c0       	rjmp	.+160    	; 0x1ce6 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1c46:	eb 81       	ldd	r30, Y+3	; 0x03
    1c48:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4a:	80 81       	ld	r24, Z
    1c4c:	91 81       	ldd	r25, Z+1	; 0x01
    1c4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c50:	fc 81       	ldd	r31, Y+4	; 0x04
    1c52:	93 83       	std	Z+3, r25	; 0x03
    1c54:	82 83       	std	Z+2, r24	; 0x02
    1c56:	47 c0       	rjmp	.+142    	; 0x1ce6 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1c58:	eb 81       	ldd	r30, Y+3	; 0x03
    1c5a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c5c:	66 81       	ldd	r22, Z+6	; 0x06
    1c5e:	77 81       	ldd	r23, Z+7	; 0x07
    1c60:	eb 81       	ldd	r30, Y+3	; 0x03
    1c62:	fc 81       	ldd	r31, Y+4	; 0x04
    1c64:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c66:	48 2f       	mov	r20, r24
    1c68:	50 e0       	ldi	r21, 0x00	; 0
    1c6a:	2d 81       	ldd	r18, Y+5	; 0x05
    1c6c:	3e 81       	ldd	r19, Y+6	; 0x06
    1c6e:	cb 01       	movw	r24, r22
    1c70:	b9 01       	movw	r22, r18
    1c72:	0e 94 88 37 	call	0x6f10	; 0x6f10 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1c76:	eb 81       	ldd	r30, Y+3	; 0x03
    1c78:	fc 81       	ldd	r31, Y+4	; 0x04
    1c7a:	26 81       	ldd	r18, Z+6	; 0x06
    1c7c:	37 81       	ldd	r19, Z+7	; 0x07
    1c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c80:	fc 81       	ldd	r31, Y+4	; 0x04
    1c82:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c84:	88 2f       	mov	r24, r24
    1c86:	90 e0       	ldi	r25, 0x00	; 0
    1c88:	90 95       	com	r25
    1c8a:	81 95       	neg	r24
    1c8c:	9f 4f       	sbci	r25, 0xFF	; 255
    1c8e:	82 0f       	add	r24, r18
    1c90:	93 1f       	adc	r25, r19
    1c92:	eb 81       	ldd	r30, Y+3	; 0x03
    1c94:	fc 81       	ldd	r31, Y+4	; 0x04
    1c96:	97 83       	std	Z+7, r25	; 0x07
    1c98:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1c9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c9e:	26 81       	ldd	r18, Z+6	; 0x06
    1ca0:	37 81       	ldd	r19, Z+7	; 0x07
    1ca2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ca4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca6:	80 81       	ld	r24, Z
    1ca8:	91 81       	ldd	r25, Z+1	; 0x01
    1caa:	28 17       	cp	r18, r24
    1cac:	39 07       	cpc	r19, r25
    1cae:	90 f4       	brcc	.+36     	; 0x1cd4 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1cb0:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb2:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb4:	24 81       	ldd	r18, Z+4	; 0x04
    1cb6:	35 81       	ldd	r19, Z+5	; 0x05
    1cb8:	eb 81       	ldd	r30, Y+3	; 0x03
    1cba:	fc 81       	ldd	r31, Y+4	; 0x04
    1cbc:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cbe:	88 2f       	mov	r24, r24
    1cc0:	90 e0       	ldi	r25, 0x00	; 0
    1cc2:	90 95       	com	r25
    1cc4:	81 95       	neg	r24
    1cc6:	9f 4f       	sbci	r25, 0xFF	; 255
    1cc8:	82 0f       	add	r24, r18
    1cca:	93 1f       	adc	r25, r19
    1ccc:	eb 81       	ldd	r30, Y+3	; 0x03
    1cce:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd0:	97 83       	std	Z+7, r25	; 0x07
    1cd2:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    1cd4:	8f 81       	ldd	r24, Y+7	; 0x07
    1cd6:	82 30       	cpi	r24, 0x02	; 2
    1cd8:	31 f4       	brne	.+12     	; 0x1ce6 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1cda:	89 81       	ldd	r24, Y+1	; 0x01
    1cdc:	88 23       	and	r24, r24
    1cde:	19 f0       	breq	.+6      	; 0x1ce6 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    1ce0:	89 81       	ldd	r24, Y+1	; 0x01
    1ce2:	81 50       	subi	r24, 0x01	; 1
    1ce4:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1ce6:	89 81       	ldd	r24, Y+1	; 0x01
    1ce8:	8f 5f       	subi	r24, 0xFF	; 255
    1cea:	eb 81       	ldd	r30, Y+3	; 0x03
    1cec:	fc 81       	ldd	r31, Y+4	; 0x04
    1cee:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    1cf0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1cf2:	27 96       	adiw	r28, 0x07	; 7
    1cf4:	0f b6       	in	r0, 0x3f	; 63
    1cf6:	f8 94       	cli
    1cf8:	de bf       	out	0x3e, r29	; 62
    1cfa:	0f be       	out	0x3f, r0	; 63
    1cfc:	cd bf       	out	0x3d, r28	; 61
    1cfe:	cf 91       	pop	r28
    1d00:	df 91       	pop	r29
    1d02:	08 95       	ret

00001d04 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    1d04:	df 93       	push	r29
    1d06:	cf 93       	push	r28
    1d08:	00 d0       	rcall	.+0      	; 0x1d0a <prvCopyDataFromQueue+0x6>
    1d0a:	00 d0       	rcall	.+0      	; 0x1d0c <prvCopyDataFromQueue+0x8>
    1d0c:	cd b7       	in	r28, 0x3d	; 61
    1d0e:	de b7       	in	r29, 0x3e	; 62
    1d10:	9a 83       	std	Y+2, r25	; 0x02
    1d12:	89 83       	std	Y+1, r24	; 0x01
    1d14:	7c 83       	std	Y+4, r23	; 0x04
    1d16:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1d18:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d1e:	88 23       	and	r24, r24
    1d20:	89 f1       	breq	.+98     	; 0x1d84 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1d22:	e9 81       	ldd	r30, Y+1	; 0x01
    1d24:	fa 81       	ldd	r31, Y+2	; 0x02
    1d26:	26 81       	ldd	r18, Z+6	; 0x06
    1d28:	37 81       	ldd	r19, Z+7	; 0x07
    1d2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d2e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d30:	88 2f       	mov	r24, r24
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	82 0f       	add	r24, r18
    1d36:	93 1f       	adc	r25, r19
    1d38:	e9 81       	ldd	r30, Y+1	; 0x01
    1d3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d3c:	97 83       	std	Z+7, r25	; 0x07
    1d3e:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1d40:	e9 81       	ldd	r30, Y+1	; 0x01
    1d42:	fa 81       	ldd	r31, Y+2	; 0x02
    1d44:	26 81       	ldd	r18, Z+6	; 0x06
    1d46:	37 81       	ldd	r19, Z+7	; 0x07
    1d48:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4c:	84 81       	ldd	r24, Z+4	; 0x04
    1d4e:	95 81       	ldd	r25, Z+5	; 0x05
    1d50:	28 17       	cp	r18, r24
    1d52:	39 07       	cpc	r19, r25
    1d54:	40 f0       	brcs	.+16     	; 0x1d66 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1d56:	e9 81       	ldd	r30, Y+1	; 0x01
    1d58:	fa 81       	ldd	r31, Y+2	; 0x02
    1d5a:	80 81       	ld	r24, Z
    1d5c:	91 81       	ldd	r25, Z+1	; 0x01
    1d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d60:	fa 81       	ldd	r31, Y+2	; 0x02
    1d62:	97 83       	std	Z+7, r25	; 0x07
    1d64:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1d66:	e9 81       	ldd	r30, Y+1	; 0x01
    1d68:	fa 81       	ldd	r31, Y+2	; 0x02
    1d6a:	46 81       	ldd	r20, Z+6	; 0x06
    1d6c:	57 81       	ldd	r21, Z+7	; 0x07
    1d6e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d70:	fa 81       	ldd	r31, Y+2	; 0x02
    1d72:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d74:	28 2f       	mov	r18, r24
    1d76:	30 e0       	ldi	r19, 0x00	; 0
    1d78:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7c:	ba 01       	movw	r22, r20
    1d7e:	a9 01       	movw	r20, r18
    1d80:	0e 94 88 37 	call	0x6f10	; 0x6f10 <memcpy>
    }
}
    1d84:	0f 90       	pop	r0
    1d86:	0f 90       	pop	r0
    1d88:	0f 90       	pop	r0
    1d8a:	0f 90       	pop	r0
    1d8c:	cf 91       	pop	r28
    1d8e:	df 91       	pop	r29
    1d90:	08 95       	ret

00001d92 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1d92:	df 93       	push	r29
    1d94:	cf 93       	push	r28
    1d96:	00 d0       	rcall	.+0      	; 0x1d98 <prvUnlockQueue+0x6>
    1d98:	00 d0       	rcall	.+0      	; 0x1d9a <prvUnlockQueue+0x8>
    1d9a:	cd b7       	in	r28, 0x3d	; 61
    1d9c:	de b7       	in	r29, 0x3e	; 62
    1d9e:	9c 83       	std	Y+4, r25	; 0x04
    1da0:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    1da2:	0f b6       	in	r0, 0x3f	; 63
    1da4:	f8 94       	cli
    1da6:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    1da8:	eb 81       	ldd	r30, Y+3	; 0x03
    1daa:	fc 81       	ldd	r31, Y+4	; 0x04
    1dac:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dae:	8a 83       	std	Y+2, r24	; 0x02
    1db0:	11 c0       	rjmp	.+34     	; 0x1dd4 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1db2:	eb 81       	ldd	r30, Y+3	; 0x03
    1db4:	fc 81       	ldd	r31, Y+4	; 0x04
    1db6:	81 89       	ldd	r24, Z+17	; 0x11
    1db8:	88 23       	and	r24, r24
    1dba:	79 f0       	breq	.+30     	; 0x1dda <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1dbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1dbe:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc0:	41 96       	adiw	r24, 0x11	; 17
    1dc2:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
    1dc6:	88 23       	and	r24, r24
    1dc8:	11 f0       	breq	.+4      	; 0x1dce <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    1dca:	0e 94 5e 21 	call	0x42bc	; 0x42bc <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    1dce:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd0:	81 50       	subi	r24, 0x01	; 1
    1dd2:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    1dd4:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd6:	18 16       	cp	r1, r24
    1dd8:	64 f3       	brlt	.-40     	; 0x1db2 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    1dda:	eb 81       	ldd	r30, Y+3	; 0x03
    1ddc:	fc 81       	ldd	r31, Y+4	; 0x04
    1dde:	8f ef       	ldi	r24, 0xFF	; 255
    1de0:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    1de2:	0f 90       	pop	r0
    1de4:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    1de6:	0f b6       	in	r0, 0x3f	; 63
    1de8:	f8 94       	cli
    1dea:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    1dec:	eb 81       	ldd	r30, Y+3	; 0x03
    1dee:	fc 81       	ldd	r31, Y+4	; 0x04
    1df0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1df2:	89 83       	std	Y+1, r24	; 0x01
    1df4:	11 c0       	rjmp	.+34     	; 0x1e18 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1df6:	eb 81       	ldd	r30, Y+3	; 0x03
    1df8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfa:	80 85       	ldd	r24, Z+8	; 0x08
    1dfc:	88 23       	and	r24, r24
    1dfe:	79 f0       	breq	.+30     	; 0x1e1e <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e00:	8b 81       	ldd	r24, Y+3	; 0x03
    1e02:	9c 81       	ldd	r25, Y+4	; 0x04
    1e04:	08 96       	adiw	r24, 0x08	; 8
    1e06:	0e 94 6e 1e 	call	0x3cdc	; 0x3cdc <xTaskRemoveFromEventList>
    1e0a:	88 23       	and	r24, r24
    1e0c:	11 f0       	breq	.+4      	; 0x1e12 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    1e0e:	0e 94 5e 21 	call	0x42bc	; 0x42bc <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    1e12:	89 81       	ldd	r24, Y+1	; 0x01
    1e14:	81 50       	subi	r24, 0x01	; 1
    1e16:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    1e18:	89 81       	ldd	r24, Y+1	; 0x01
    1e1a:	18 16       	cp	r1, r24
    1e1c:	64 f3       	brlt	.-40     	; 0x1df6 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    1e1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e20:	fc 81       	ldd	r31, Y+4	; 0x04
    1e22:	8f ef       	ldi	r24, 0xFF	; 255
    1e24:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    1e26:	0f 90       	pop	r0
    1e28:	0f be       	out	0x3f, r0	; 63
}
    1e2a:	0f 90       	pop	r0
    1e2c:	0f 90       	pop	r0
    1e2e:	0f 90       	pop	r0
    1e30:	0f 90       	pop	r0
    1e32:	cf 91       	pop	r28
    1e34:	df 91       	pop	r29
    1e36:	08 95       	ret

00001e38 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    1e38:	df 93       	push	r29
    1e3a:	cf 93       	push	r28
    1e3c:	00 d0       	rcall	.+0      	; 0x1e3e <prvIsQueueEmpty+0x6>
    1e3e:	0f 92       	push	r0
    1e40:	cd b7       	in	r28, 0x3d	; 61
    1e42:	de b7       	in	r29, 0x3e	; 62
    1e44:	9b 83       	std	Y+3, r25	; 0x03
    1e46:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1e48:	0f b6       	in	r0, 0x3f	; 63
    1e4a:	f8 94       	cli
    1e4c:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e4e:	ea 81       	ldd	r30, Y+2	; 0x02
    1e50:	fb 81       	ldd	r31, Y+3	; 0x03
    1e52:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e54:	88 23       	and	r24, r24
    1e56:	19 f4       	brne	.+6      	; 0x1e5e <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    1e58:	81 e0       	ldi	r24, 0x01	; 1
    1e5a:	89 83       	std	Y+1, r24	; 0x01
    1e5c:	01 c0       	rjmp	.+2      	; 0x1e60 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    1e5e:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    1e60:	0f 90       	pop	r0
    1e62:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    1e64:	89 81       	ldd	r24, Y+1	; 0x01
}
    1e66:	0f 90       	pop	r0
    1e68:	0f 90       	pop	r0
    1e6a:	0f 90       	pop	r0
    1e6c:	cf 91       	pop	r28
    1e6e:	df 91       	pop	r29
    1e70:	08 95       	ret

00001e72 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1e72:	df 93       	push	r29
    1e74:	cf 93       	push	r28
    1e76:	00 d0       	rcall	.+0      	; 0x1e78 <xQueueIsQueueEmptyFromISR+0x6>
    1e78:	00 d0       	rcall	.+0      	; 0x1e7a <xQueueIsQueueEmptyFromISR+0x8>
    1e7a:	0f 92       	push	r0
    1e7c:	cd b7       	in	r28, 0x3d	; 61
    1e7e:	de b7       	in	r29, 0x3e	; 62
    1e80:	9d 83       	std	Y+5, r25	; 0x05
    1e82:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    1e84:	8c 81       	ldd	r24, Y+4	; 0x04
    1e86:	9d 81       	ldd	r25, Y+5	; 0x05
    1e88:	9a 83       	std	Y+2, r25	; 0x02
    1e8a:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1e8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e90:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e92:	88 23       	and	r24, r24
    1e94:	19 f4       	brne	.+6      	; 0x1e9c <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    1e96:	81 e0       	ldi	r24, 0x01	; 1
    1e98:	8b 83       	std	Y+3, r24	; 0x03
    1e9a:	01 c0       	rjmp	.+2      	; 0x1e9e <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    1e9c:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    1e9e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1ea0:	0f 90       	pop	r0
    1ea2:	0f 90       	pop	r0
    1ea4:	0f 90       	pop	r0
    1ea6:	0f 90       	pop	r0
    1ea8:	0f 90       	pop	r0
    1eaa:	cf 91       	pop	r28
    1eac:	df 91       	pop	r29
    1eae:	08 95       	ret

00001eb0 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    1eb0:	df 93       	push	r29
    1eb2:	cf 93       	push	r28
    1eb4:	00 d0       	rcall	.+0      	; 0x1eb6 <prvIsQueueFull+0x6>
    1eb6:	0f 92       	push	r0
    1eb8:	cd b7       	in	r28, 0x3d	; 61
    1eba:	de b7       	in	r29, 0x3e	; 62
    1ebc:	9b 83       	std	Y+3, r25	; 0x03
    1ebe:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
    1ec4:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1ec6:	ea 81       	ldd	r30, Y+2	; 0x02
    1ec8:	fb 81       	ldd	r31, Y+3	; 0x03
    1eca:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ecc:	ea 81       	ldd	r30, Y+2	; 0x02
    1ece:	fb 81       	ldd	r31, Y+3	; 0x03
    1ed0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ed2:	98 17       	cp	r25, r24
    1ed4:	19 f4       	brne	.+6      	; 0x1edc <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    1ed6:	81 e0       	ldi	r24, 0x01	; 1
    1ed8:	89 83       	std	Y+1, r24	; 0x01
    1eda:	01 c0       	rjmp	.+2      	; 0x1ede <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    1edc:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    1ede:	0f 90       	pop	r0
    1ee0:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    1ee2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ee4:	0f 90       	pop	r0
    1ee6:	0f 90       	pop	r0
    1ee8:	0f 90       	pop	r0
    1eea:	cf 91       	pop	r28
    1eec:	df 91       	pop	r29
    1eee:	08 95       	ret

00001ef0 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1ef0:	df 93       	push	r29
    1ef2:	cf 93       	push	r28
    1ef4:	00 d0       	rcall	.+0      	; 0x1ef6 <xQueueIsQueueFullFromISR+0x6>
    1ef6:	00 d0       	rcall	.+0      	; 0x1ef8 <xQueueIsQueueFullFromISR+0x8>
    1ef8:	0f 92       	push	r0
    1efa:	cd b7       	in	r28, 0x3d	; 61
    1efc:	de b7       	in	r29, 0x3e	; 62
    1efe:	9d 83       	std	Y+5, r25	; 0x05
    1f00:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    1f02:	8c 81       	ldd	r24, Y+4	; 0x04
    1f04:	9d 81       	ldd	r25, Y+5	; 0x05
    1f06:	9a 83       	std	Y+2, r25	; 0x02
    1f08:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f0e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f10:	e9 81       	ldd	r30, Y+1	; 0x01
    1f12:	fa 81       	ldd	r31, Y+2	; 0x02
    1f14:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f16:	98 17       	cp	r25, r24
    1f18:	19 f4       	brne	.+6      	; 0x1f20 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    1f1a:	81 e0       	ldi	r24, 0x01	; 1
    1f1c:	8b 83       	std	Y+3, r24	; 0x03
    1f1e:	01 c0       	rjmp	.+2      	; 0x1f22 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    1f20:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    1f22:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1f24:	0f 90       	pop	r0
    1f26:	0f 90       	pop	r0
    1f28:	0f 90       	pop	r0
    1f2a:	0f 90       	pop	r0
    1f2c:	0f 90       	pop	r0
    1f2e:	cf 91       	pop	r28
    1f30:	df 91       	pop	r29
    1f32:	08 95       	ret

00001f34 <xStreamBufferGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer )
    {
    1f34:	0f 93       	push	r16
    1f36:	df 93       	push	r29
    1f38:	cf 93       	push	r28
    1f3a:	cd b7       	in	r28, 0x3d	; 61
    1f3c:	de b7       	in	r29, 0x3e	; 62
    1f3e:	28 97       	sbiw	r28, 0x08	; 8
    1f40:	0f b6       	in	r0, 0x3f	; 63
    1f42:	f8 94       	cli
    1f44:	de bf       	out	0x3e, r29	; 62
    1f46:	0f be       	out	0x3f, r0	; 63
    1f48:	cd bf       	out	0x3d, r28	; 61
    1f4a:	9d 83       	std	Y+5, r25	; 0x05
    1f4c:	8c 83       	std	Y+4, r24	; 0x04
    1f4e:	7f 83       	std	Y+7, r23	; 0x07
    1f50:	6e 83       	std	Y+6, r22	; 0x06
    1f52:	48 87       	std	Y+8, r20	; 0x08

        /* In case the stream buffer is going to be used as a message buffer
         * (that is, it will hold discrete messages with a little meta data that
         * says how big the next message is) check the buffer will be large enough
         * to hold at least one message. */
        if( xIsMessageBuffer == pdTRUE )
    1f54:	88 85       	ldd	r24, Y+8	; 0x08
    1f56:	81 30       	cpi	r24, 0x01	; 1
    1f58:	19 f4       	brne	.+6      	; 0x1f60 <xStreamBufferGenericCreate+0x2c>
        {
            /* Is a message buffer but not statically allocated. */
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    1f5a:	81 e0       	ldi	r24, 0x01	; 1
    1f5c:	89 83       	std	Y+1, r24	; 0x01
    1f5e:	01 c0       	rjmp	.+2      	; 0x1f62 <xStreamBufferGenericCreate+0x2e>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
        }
        else
        {
            /* Not a message buffer and not statically allocated. */
            ucFlags = 0;
    1f60:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    1f62:	8e 81       	ldd	r24, Y+6	; 0x06
    1f64:	9f 81       	ldd	r25, Y+7	; 0x07
    1f66:	00 97       	sbiw	r24, 0x00	; 0
    1f68:	21 f4       	brne	.+8      	; 0x1f72 <xStreamBufferGenericCreate+0x3e>
        {
            xTriggerLevelBytes = ( size_t ) 1;
    1f6a:	81 e0       	ldi	r24, 0x01	; 1
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	9f 83       	std	Y+7, r25	; 0x07
    1f70:	8e 83       	std	Y+6, r24	; 0x06
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    1f72:	8c 81       	ldd	r24, Y+4	; 0x04
    1f74:	9d 81       	ldd	r25, Y+5	; 0x05
    1f76:	9c 01       	movw	r18, r24
    1f78:	20 5f       	subi	r18, 0xF0	; 240
    1f7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f7e:	9d 81       	ldd	r25, Y+5	; 0x05
    1f80:	82 17       	cp	r24, r18
    1f82:	93 07       	cpc	r25, r19
    1f84:	68 f4       	brcc	.+26     	; 0x1fa0 <xStreamBufferGenericCreate+0x6c>
        {
            xBufferSizeBytes++;
    1f86:	8c 81       	ldd	r24, Y+4	; 0x04
    1f88:	9d 81       	ldd	r25, Y+5	; 0x05
    1f8a:	01 96       	adiw	r24, 0x01	; 1
    1f8c:	9d 83       	std	Y+5, r25	; 0x05
    1f8e:	8c 83       	std	Y+4, r24	; 0x04
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    1f90:	8c 81       	ldd	r24, Y+4	; 0x04
    1f92:	9d 81       	ldd	r25, Y+5	; 0x05
    1f94:	0f 96       	adiw	r24, 0x0f	; 15
    1f96:	0e 94 d7 03 	call	0x7ae	; 0x7ae <pvPortMalloc>
    1f9a:	9b 83       	std	Y+3, r25	; 0x03
    1f9c:	8a 83       	std	Y+2, r24	; 0x02
    1f9e:	02 c0       	rjmp	.+4      	; 0x1fa4 <xStreamBufferGenericCreate+0x70>
        }
        else
        {
            pucAllocatedMemory = NULL;
    1fa0:	1b 82       	std	Y+3, r1	; 0x03
    1fa2:	1a 82       	std	Y+2, r1	; 0x02
        }

        if( pucAllocatedMemory != NULL )
    1fa4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa6:	9b 81       	ldd	r25, Y+3	; 0x03
    1fa8:	00 97       	sbiw	r24, 0x00	; 0
    1faa:	89 f0       	breq	.+34     	; 0x1fce <xStreamBufferGenericCreate+0x9a>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    1fac:	6a 81       	ldd	r22, Y+2	; 0x02
    1fae:	7b 81       	ldd	r23, Y+3	; 0x03
    1fb0:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb2:	9b 81       	ldd	r25, Y+3	; 0x03
    1fb4:	9c 01       	movw	r18, r24
    1fb6:	21 5f       	subi	r18, 0xF1	; 241
    1fb8:	3f 4f       	sbci	r19, 0xFF	; 255
    1fba:	4c 81       	ldd	r20, Y+4	; 0x04
    1fbc:	5d 81       	ldd	r21, Y+5	; 0x05
    1fbe:	ee 81       	ldd	r30, Y+6	; 0x06
    1fc0:	ff 81       	ldd	r31, Y+7	; 0x07
    1fc2:	cb 01       	movw	r24, r22
    1fc4:	b9 01       	movw	r22, r18
    1fc6:	9f 01       	movw	r18, r30
    1fc8:	09 81       	ldd	r16, Y+1	; 0x01
    1fca:	0e 94 22 17 	call	0x2e44	; 0x2e44 <prvInitialiseNewStreamBuffer>
        else
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    1fce:	8a 81       	ldd	r24, Y+2	; 0x02
    1fd0:	9b 81       	ldd	r25, Y+3	; 0x03
    }
    1fd2:	28 96       	adiw	r28, 0x08	; 8
    1fd4:	0f b6       	in	r0, 0x3f	; 63
    1fd6:	f8 94       	cli
    1fd8:	de bf       	out	0x3e, r29	; 62
    1fda:	0f be       	out	0x3f, r0	; 63
    1fdc:	cd bf       	out	0x3d, r28	; 61
    1fde:	cf 91       	pop	r28
    1fe0:	df 91       	pop	r29
    1fe2:	0f 91       	pop	r16
    1fe4:	08 95       	ret

00001fe6 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    1fe6:	df 93       	push	r29
    1fe8:	cf 93       	push	r28
    1fea:	00 d0       	rcall	.+0      	; 0x1fec <vStreamBufferDelete+0x6>
    1fec:	00 d0       	rcall	.+0      	; 0x1fee <vStreamBufferDelete+0x8>
    1fee:	cd b7       	in	r28, 0x3d	; 61
    1ff0:	de b7       	in	r29, 0x3e	; 62
    1ff2:	9c 83       	std	Y+4, r25	; 0x04
    1ff4:	8b 83       	std	Y+3, r24	; 0x03
    StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    1ff6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ff8:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffa:	9a 83       	std	Y+2, r25	; 0x02
    1ffc:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    1ffe:	e9 81       	ldd	r30, Y+1	; 0x01
    2000:	fa 81       	ldd	r31, Y+2	; 0x02
    2002:	86 85       	ldd	r24, Z+14	; 0x0e
    2004:	88 2f       	mov	r24, r24
    2006:	90 e0       	ldi	r25, 0x00	; 0
    2008:	82 70       	andi	r24, 0x02	; 2
    200a:	90 70       	andi	r25, 0x00	; 0
    200c:	00 97       	sbiw	r24, 0x00	; 0
    200e:	29 f4       	brne	.+10     	; 0x201a <vStreamBufferDelete+0x34>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
            {
                /* Both the structure and the buffer were allocated using a single call
                * to pvPortMalloc(), hence only one call to vPortFree() is required. */
                vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2010:	89 81       	ldd	r24, Y+1	; 0x01
    2012:	9a 81       	ldd	r25, Y+2	; 0x02
    2014:	0e 94 31 04 	call	0x862	; 0x862 <vPortFree>
    2018:	08 c0       	rjmp	.+16     	; 0x202a <vStreamBufferDelete+0x44>
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    201a:	89 81       	ldd	r24, Y+1	; 0x01
    201c:	9a 81       	ldd	r25, Y+2	; 0x02
    201e:	60 e0       	ldi	r22, 0x00	; 0
    2020:	70 e0       	ldi	r23, 0x00	; 0
    2022:	4f e0       	ldi	r20, 0x0F	; 15
    2024:	50 e0       	ldi	r21, 0x00	; 0
    2026:	0e 94 91 37 	call	0x6f22	; 0x6f22 <memset>
    }
}
    202a:	0f 90       	pop	r0
    202c:	0f 90       	pop	r0
    202e:	0f 90       	pop	r0
    2030:	0f 90       	pop	r0
    2032:	cf 91       	pop	r28
    2034:	df 91       	pop	r29
    2036:	08 95       	ret

00002038 <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    2038:	0f 93       	push	r16
    203a:	df 93       	push	r29
    203c:	cf 93       	push	r28
    203e:	00 d0       	rcall	.+0      	; 0x2040 <xStreamBufferReset+0x8>
    2040:	00 d0       	rcall	.+0      	; 0x2042 <xStreamBufferReset+0xa>
    2042:	0f 92       	push	r0
    2044:	cd b7       	in	r28, 0x3d	; 61
    2046:	de b7       	in	r29, 0x3e	; 62
    2048:	9d 83       	std	Y+5, r25	; 0x05
    204a:	8c 83       	std	Y+4, r24	; 0x04
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    204c:	8c 81       	ldd	r24, Y+4	; 0x04
    204e:	9d 81       	ldd	r25, Y+5	; 0x05
    2050:	9b 83       	std	Y+3, r25	; 0x03
    2052:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn = pdFAIL;
    2054:	19 82       	std	Y+1, r1	; 0x01
            uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
        }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    2056:	0f b6       	in	r0, 0x3f	; 63
    2058:	f8 94       	cli
    205a:	0f 92       	push	r0
    {
        if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    205c:	ea 81       	ldd	r30, Y+2	; 0x02
    205e:	fb 81       	ldd	r31, Y+3	; 0x03
    2060:	80 85       	ldd	r24, Z+8	; 0x08
    2062:	91 85       	ldd	r25, Z+9	; 0x09
    2064:	00 97       	sbiw	r24, 0x00	; 0
    2066:	f1 f4       	brne	.+60     	; 0x20a4 <xStreamBufferReset+0x6c>
        {
            if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    2068:	ea 81       	ldd	r30, Y+2	; 0x02
    206a:	fb 81       	ldd	r31, Y+3	; 0x03
    206c:	82 85       	ldd	r24, Z+10	; 0x0a
    206e:	93 85       	ldd	r25, Z+11	; 0x0b
    2070:	00 97       	sbiw	r24, 0x00	; 0
    2072:	c1 f4       	brne	.+48     	; 0x20a4 <xStreamBufferReset+0x6c>
            {
                prvInitialiseNewStreamBuffer( pxStreamBuffer,
    2074:	ea 81       	ldd	r30, Y+2	; 0x02
    2076:	fb 81       	ldd	r31, Y+3	; 0x03
    2078:	24 85       	ldd	r18, Z+12	; 0x0c
    207a:	35 85       	ldd	r19, Z+13	; 0x0d
    207c:	ea 81       	ldd	r30, Y+2	; 0x02
    207e:	fb 81       	ldd	r31, Y+3	; 0x03
    2080:	44 81       	ldd	r20, Z+4	; 0x04
    2082:	55 81       	ldd	r21, Z+5	; 0x05
    2084:	ea 81       	ldd	r30, Y+2	; 0x02
    2086:	fb 81       	ldd	r31, Y+3	; 0x03
    2088:	a6 81       	ldd	r26, Z+6	; 0x06
    208a:	b7 81       	ldd	r27, Z+7	; 0x07
    208c:	ea 81       	ldd	r30, Y+2	; 0x02
    208e:	fb 81       	ldd	r31, Y+3	; 0x03
    2090:	e6 85       	ldd	r30, Z+14	; 0x0e
    2092:	8a 81       	ldd	r24, Y+2	; 0x02
    2094:	9b 81       	ldd	r25, Y+3	; 0x03
    2096:	b9 01       	movw	r22, r18
    2098:	9d 01       	movw	r18, r26
    209a:	0e 2f       	mov	r16, r30
    209c:	0e 94 22 17 	call	0x2e44	; 0x2e44 <prvInitialiseNewStreamBuffer>
                                              pxStreamBuffer->pucBuffer,
                                              pxStreamBuffer->xLength,
                                              pxStreamBuffer->xTriggerLevelBytes,
                                              pxStreamBuffer->ucFlags );
                xReturn = pdPASS;
    20a0:	81 e0       	ldi	r24, 0x01	; 1
    20a2:	89 83       	std	Y+1, r24	; 0x01

                traceSTREAM_BUFFER_RESET( xStreamBuffer );
            }
        }
    }
    taskEXIT_CRITICAL();
    20a4:	0f 90       	pop	r0
    20a6:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    20a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    20aa:	0f 90       	pop	r0
    20ac:	0f 90       	pop	r0
    20ae:	0f 90       	pop	r0
    20b0:	0f 90       	pop	r0
    20b2:	0f 90       	pop	r0
    20b4:	cf 91       	pop	r28
    20b6:	df 91       	pop	r29
    20b8:	0f 91       	pop	r16
    20ba:	08 95       	ret

000020bc <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    20bc:	df 93       	push	r29
    20be:	cf 93       	push	r28
    20c0:	cd b7       	in	r28, 0x3d	; 61
    20c2:	de b7       	in	r29, 0x3e	; 62
    20c4:	27 97       	sbiw	r28, 0x07	; 7
    20c6:	0f b6       	in	r0, 0x3f	; 63
    20c8:	f8 94       	cli
    20ca:	de bf       	out	0x3e, r29	; 62
    20cc:	0f be       	out	0x3f, r0	; 63
    20ce:	cd bf       	out	0x3d, r28	; 61
    20d0:	9d 83       	std	Y+5, r25	; 0x05
    20d2:	8c 83       	std	Y+4, r24	; 0x04
    20d4:	7f 83       	std	Y+7, r23	; 0x07
    20d6:	6e 83       	std	Y+6, r22	; 0x06
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    20d8:	8c 81       	ldd	r24, Y+4	; 0x04
    20da:	9d 81       	ldd	r25, Y+5	; 0x05
    20dc:	9b 83       	std	Y+3, r25	; 0x03
    20de:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    20e0:	8e 81       	ldd	r24, Y+6	; 0x06
    20e2:	9f 81       	ldd	r25, Y+7	; 0x07
    20e4:	00 97       	sbiw	r24, 0x00	; 0
    20e6:	21 f4       	brne	.+8      	; 0x20f0 <xStreamBufferSetTriggerLevel+0x34>
    {
        xTriggerLevel = ( size_t ) 1;
    20e8:	81 e0       	ldi	r24, 0x01	; 1
    20ea:	90 e0       	ldi	r25, 0x00	; 0
    20ec:	9f 83       	std	Y+7, r25	; 0x07
    20ee:	8e 83       	std	Y+6, r24	; 0x06
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    20f0:	ea 81       	ldd	r30, Y+2	; 0x02
    20f2:	fb 81       	ldd	r31, Y+3	; 0x03
    20f4:	24 81       	ldd	r18, Z+4	; 0x04
    20f6:	35 81       	ldd	r19, Z+5	; 0x05
    20f8:	8e 81       	ldd	r24, Y+6	; 0x06
    20fa:	9f 81       	ldd	r25, Y+7	; 0x07
    20fc:	82 17       	cp	r24, r18
    20fe:	93 07       	cpc	r25, r19
    2100:	48 f4       	brcc	.+18     	; 0x2114 <xStreamBufferSetTriggerLevel+0x58>
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2102:	ea 81       	ldd	r30, Y+2	; 0x02
    2104:	fb 81       	ldd	r31, Y+3	; 0x03
    2106:	8e 81       	ldd	r24, Y+6	; 0x06
    2108:	9f 81       	ldd	r25, Y+7	; 0x07
    210a:	97 83       	std	Z+7, r25	; 0x07
    210c:	86 83       	std	Z+6, r24	; 0x06
        xReturn = pdPASS;
    210e:	81 e0       	ldi	r24, 0x01	; 1
    2110:	89 83       	std	Y+1, r24	; 0x01
    2112:	01 c0       	rjmp	.+2      	; 0x2116 <xStreamBufferSetTriggerLevel+0x5a>
    }
    else
    {
        xReturn = pdFALSE;
    2114:	19 82       	std	Y+1, r1	; 0x01
    }

    return xReturn;
    2116:	89 81       	ldd	r24, Y+1	; 0x01
}
    2118:	27 96       	adiw	r28, 0x07	; 7
    211a:	0f b6       	in	r0, 0x3f	; 63
    211c:	f8 94       	cli
    211e:	de bf       	out	0x3e, r29	; 62
    2120:	0f be       	out	0x3f, r0	; 63
    2122:	cd bf       	out	0x3d, r28	; 61
    2124:	cf 91       	pop	r28
    2126:	df 91       	pop	r29
    2128:	08 95       	ret

0000212a <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    212a:	df 93       	push	r29
    212c:	cf 93       	push	r28
    212e:	cd b7       	in	r28, 0x3d	; 61
    2130:	de b7       	in	r29, 0x3e	; 62
    2132:	28 97       	sbiw	r28, 0x08	; 8
    2134:	0f b6       	in	r0, 0x3f	; 63
    2136:	f8 94       	cli
    2138:	de bf       	out	0x3e, r29	; 62
    213a:	0f be       	out	0x3f, r0	; 63
    213c:	cd bf       	out	0x3d, r28	; 61
    213e:	98 87       	std	Y+8, r25	; 0x08
    2140:	8f 83       	std	Y+7, r24	; 0x07
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2142:	8f 81       	ldd	r24, Y+7	; 0x07
    2144:	98 85       	ldd	r25, Y+8	; 0x08
    2146:	9e 83       	std	Y+6, r25	; 0x06
    2148:	8d 83       	std	Y+5, r24	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    214a:	ed 81       	ldd	r30, Y+5	; 0x05
    214c:	fe 81       	ldd	r31, Y+6	; 0x06
    214e:	80 81       	ld	r24, Z
    2150:	91 81       	ldd	r25, Z+1	; 0x01
    2152:	9a 83       	std	Y+2, r25	; 0x02
    2154:	89 83       	std	Y+1, r24	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2156:	ed 81       	ldd	r30, Y+5	; 0x05
    2158:	fe 81       	ldd	r31, Y+6	; 0x06
    215a:	24 81       	ldd	r18, Z+4	; 0x04
    215c:	35 81       	ldd	r19, Z+5	; 0x05
    215e:	ed 81       	ldd	r30, Y+5	; 0x05
    2160:	fe 81       	ldd	r31, Y+6	; 0x06
    2162:	80 81       	ld	r24, Z
    2164:	91 81       	ldd	r25, Z+1	; 0x01
    2166:	82 0f       	add	r24, r18
    2168:	93 1f       	adc	r25, r19
    216a:	9c 83       	std	Y+4, r25	; 0x04
    216c:	8b 83       	std	Y+3, r24	; 0x03
        xSpace -= pxStreamBuffer->xHead;
    216e:	ed 81       	ldd	r30, Y+5	; 0x05
    2170:	fe 81       	ldd	r31, Y+6	; 0x06
    2172:	22 81       	ldd	r18, Z+2	; 0x02
    2174:	33 81       	ldd	r19, Z+3	; 0x03
    2176:	8b 81       	ldd	r24, Y+3	; 0x03
    2178:	9c 81       	ldd	r25, Y+4	; 0x04
    217a:	82 1b       	sub	r24, r18
    217c:	93 0b       	sbc	r25, r19
    217e:	9c 83       	std	Y+4, r25	; 0x04
    2180:	8b 83       	std	Y+3, r24	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    2182:	ed 81       	ldd	r30, Y+5	; 0x05
    2184:	fe 81       	ldd	r31, Y+6	; 0x06
    2186:	20 81       	ld	r18, Z
    2188:	31 81       	ldd	r19, Z+1	; 0x01
    218a:	89 81       	ldd	r24, Y+1	; 0x01
    218c:	9a 81       	ldd	r25, Y+2	; 0x02
    218e:	28 17       	cp	r18, r24
    2190:	39 07       	cpc	r19, r25
    2192:	d9 f6       	brne	.-74     	; 0x214a <xStreamBufferSpacesAvailable+0x20>

    xSpace -= ( size_t ) 1;
    2194:	8b 81       	ldd	r24, Y+3	; 0x03
    2196:	9c 81       	ldd	r25, Y+4	; 0x04
    2198:	01 97       	sbiw	r24, 0x01	; 1
    219a:	9c 83       	std	Y+4, r25	; 0x04
    219c:	8b 83       	std	Y+3, r24	; 0x03

    if( xSpace >= pxStreamBuffer->xLength )
    219e:	ed 81       	ldd	r30, Y+5	; 0x05
    21a0:	fe 81       	ldd	r31, Y+6	; 0x06
    21a2:	24 81       	ldd	r18, Z+4	; 0x04
    21a4:	35 81       	ldd	r19, Z+5	; 0x05
    21a6:	8b 81       	ldd	r24, Y+3	; 0x03
    21a8:	9c 81       	ldd	r25, Y+4	; 0x04
    21aa:	82 17       	cp	r24, r18
    21ac:	93 07       	cpc	r25, r19
    21ae:	50 f0       	brcs	.+20     	; 0x21c4 <xStreamBufferSpacesAvailable+0x9a>
    {
        xSpace -= pxStreamBuffer->xLength;
    21b0:	ed 81       	ldd	r30, Y+5	; 0x05
    21b2:	fe 81       	ldd	r31, Y+6	; 0x06
    21b4:	24 81       	ldd	r18, Z+4	; 0x04
    21b6:	35 81       	ldd	r19, Z+5	; 0x05
    21b8:	8b 81       	ldd	r24, Y+3	; 0x03
    21ba:	9c 81       	ldd	r25, Y+4	; 0x04
    21bc:	82 1b       	sub	r24, r18
    21be:	93 0b       	sbc	r25, r19
    21c0:	9c 83       	std	Y+4, r25	; 0x04
    21c2:	8b 83       	std	Y+3, r24	; 0x03
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
    21c4:	8b 81       	ldd	r24, Y+3	; 0x03
    21c6:	9c 81       	ldd	r25, Y+4	; 0x04
}
    21c8:	28 96       	adiw	r28, 0x08	; 8
    21ca:	0f b6       	in	r0, 0x3f	; 63
    21cc:	f8 94       	cli
    21ce:	de bf       	out	0x3e, r29	; 62
    21d0:	0f be       	out	0x3f, r0	; 63
    21d2:	cd bf       	out	0x3d, r28	; 61
    21d4:	cf 91       	pop	r28
    21d6:	df 91       	pop	r29
    21d8:	08 95       	ret

000021da <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    21da:	df 93       	push	r29
    21dc:	cf 93       	push	r28
    21de:	00 d0       	rcall	.+0      	; 0x21e0 <xStreamBufferBytesAvailable+0x6>
    21e0:	00 d0       	rcall	.+0      	; 0x21e2 <xStreamBufferBytesAvailable+0x8>
    21e2:	00 d0       	rcall	.+0      	; 0x21e4 <xStreamBufferBytesAvailable+0xa>
    21e4:	cd b7       	in	r28, 0x3d	; 61
    21e6:	de b7       	in	r29, 0x3e	; 62
    21e8:	9e 83       	std	Y+6, r25	; 0x06
    21ea:	8d 83       	std	Y+5, r24	; 0x05
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    21ec:	8d 81       	ldd	r24, Y+5	; 0x05
    21ee:	9e 81       	ldd	r25, Y+6	; 0x06
    21f0:	9c 83       	std	Y+4, r25	; 0x04
    21f2:	8b 83       	std	Y+3, r24	; 0x03
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    21f4:	8b 81       	ldd	r24, Y+3	; 0x03
    21f6:	9c 81       	ldd	r25, Y+4	; 0x04
    21f8:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <prvBytesInBuffer>
    21fc:	9a 83       	std	Y+2, r25	; 0x02
    21fe:	89 83       	std	Y+1, r24	; 0x01
    return xReturn;
    2200:	89 81       	ldd	r24, Y+1	; 0x01
    2202:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2204:	26 96       	adiw	r28, 0x06	; 6
    2206:	0f b6       	in	r0, 0x3f	; 63
    2208:	f8 94       	cli
    220a:	de bf       	out	0x3e, r29	; 62
    220c:	0f be       	out	0x3f, r0	; 63
    220e:	cd bf       	out	0x3d, r28	; 61
    2210:	cf 91       	pop	r28
    2212:	df 91       	pop	r29
    2214:	08 95       	ret

00002216 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    2216:	cf 92       	push	r12
    2218:	df 92       	push	r13
    221a:	ef 92       	push	r14
    221c:	ff 92       	push	r15
    221e:	0f 93       	push	r16
    2220:	1f 93       	push	r17
    2222:	df 93       	push	r29
    2224:	cf 93       	push	r28
    2226:	cd b7       	in	r28, 0x3d	; 61
    2228:	de b7       	in	r29, 0x3e	; 62
    222a:	65 97       	sbiw	r28, 0x15	; 21
    222c:	0f b6       	in	r0, 0x3f	; 63
    222e:	f8 94       	cli
    2230:	de bf       	out	0x3e, r29	; 62
    2232:	0f be       	out	0x3f, r0	; 63
    2234:	cd bf       	out	0x3d, r28	; 61
    2236:	9f 87       	std	Y+15, r25	; 0x0f
    2238:	8e 87       	std	Y+14, r24	; 0x0e
    223a:	79 8b       	std	Y+17, r23	; 0x11
    223c:	68 8b       	std	Y+16, r22	; 0x10
    223e:	5b 8b       	std	Y+19, r21	; 0x13
    2240:	4a 8b       	std	Y+18, r20	; 0x12
    2242:	3d 8b       	std	Y+21, r19	; 0x15
    2244:	2c 8b       	std	Y+20, r18	; 0x14
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2246:	8e 85       	ldd	r24, Y+14	; 0x0e
    2248:	9f 85       	ldd	r25, Y+15	; 0x0f
    224a:	9a 87       	std	Y+10, r25	; 0x0a
    224c:	89 87       	std	Y+9, r24	; 0x09
    size_t xReturn, xSpace = 0;
    224e:	1e 82       	std	Y+6, r1	; 0x06
    2250:	1d 82       	std	Y+5, r1	; 0x05
    size_t xRequiredSpace = xDataLengthBytes;
    2252:	8a 89       	ldd	r24, Y+18	; 0x12
    2254:	9b 89       	ldd	r25, Y+19	; 0x13
    2256:	9c 83       	std	Y+4, r25	; 0x04
    2258:	8b 83       	std	Y+3, r24	; 0x03
    TimeOut_t xTimeOut;
    size_t xMaxReportedSpace = 0;
    225a:	1a 82       	std	Y+2, r1	; 0x02
    225c:	19 82       	std	Y+1, r1	; 0x01
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    225e:	e9 85       	ldd	r30, Y+9	; 0x09
    2260:	fa 85       	ldd	r31, Y+10	; 0x0a
    2262:	84 81       	ldd	r24, Z+4	; 0x04
    2264:	95 81       	ldd	r25, Z+5	; 0x05
    2266:	01 97       	sbiw	r24, 0x01	; 1
    2268:	9a 83       	std	Y+2, r25	; 0x02
    226a:	89 83       	std	Y+1, r24	; 0x01

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    226c:	e9 85       	ldd	r30, Y+9	; 0x09
    226e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2270:	86 85       	ldd	r24, Z+14	; 0x0e
    2272:	88 2f       	mov	r24, r24
    2274:	90 e0       	ldi	r25, 0x00	; 0
    2276:	81 70       	andi	r24, 0x01	; 1
    2278:	90 70       	andi	r25, 0x00	; 0
    227a:	88 23       	and	r24, r24
    227c:	79 f0       	breq	.+30     	; 0x229c <xStreamBufferSend+0x86>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    227e:	8b 81       	ldd	r24, Y+3	; 0x03
    2280:	9c 81       	ldd	r25, Y+4	; 0x04
    2282:	02 96       	adiw	r24, 0x02	; 2
    2284:	9c 83       	std	Y+4, r25	; 0x04
    2286:	8b 83       	std	Y+3, r24	; 0x03
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    2288:	2b 81       	ldd	r18, Y+3	; 0x03
    228a:	3c 81       	ldd	r19, Y+4	; 0x04
    228c:	89 81       	ldd	r24, Y+1	; 0x01
    228e:	9a 81       	ldd	r25, Y+2	; 0x02
    2290:	82 17       	cp	r24, r18
    2292:	93 07       	cpc	r25, r19
    2294:	70 f4       	brcc	.+28     	; 0x22b2 <xStreamBufferSend+0x9c>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    2296:	1d 8a       	std	Y+21, r1	; 0x15
    2298:	1c 8a       	std	Y+20, r1	; 0x14
    229a:	0b c0       	rjmp	.+22     	; 0x22b2 <xStreamBufferSend+0x9c>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    229c:	2b 81       	ldd	r18, Y+3	; 0x03
    229e:	3c 81       	ldd	r19, Y+4	; 0x04
    22a0:	89 81       	ldd	r24, Y+1	; 0x01
    22a2:	9a 81       	ldd	r25, Y+2	; 0x02
    22a4:	82 17       	cp	r24, r18
    22a6:	93 07       	cpc	r25, r19
    22a8:	20 f4       	brcc	.+8      	; 0x22b2 <xStreamBufferSend+0x9c>
        {
            xRequiredSpace = xMaxReportedSpace;
    22aa:	89 81       	ldd	r24, Y+1	; 0x01
    22ac:	9a 81       	ldd	r25, Y+2	; 0x02
    22ae:	9c 83       	std	Y+4, r25	; 0x04
    22b0:	8b 83       	std	Y+3, r24	; 0x03
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    22b2:	8c 89       	ldd	r24, Y+20	; 0x14
    22b4:	9d 89       	ldd	r25, Y+21	; 0x15
    22b6:	00 97       	sbiw	r24, 0x00	; 0
    22b8:	09 f4       	brne	.+2      	; 0x22bc <xStreamBufferSend+0xa6>
    22ba:	43 c0       	rjmp	.+134    	; 0x2342 <xStreamBufferSend+0x12c>
    {
        vTaskSetTimeOutState( &xTimeOut );
    22bc:	ce 01       	movw	r24, r28
    22be:	0b 96       	adiw	r24, 0x0b	; 11
    22c0:	0e 94 c0 20 	call	0x4180	; 0x4180 <vTaskSetTimeOutState>

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    22c4:	0f b6       	in	r0, 0x3f	; 63
    22c6:	f8 94       	cli
    22c8:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    22ca:	89 85       	ldd	r24, Y+9	; 0x09
    22cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    22ce:	0e 94 95 10 	call	0x212a	; 0x212a <xStreamBufferSpacesAvailable>
    22d2:	9e 83       	std	Y+6, r25	; 0x06
    22d4:	8d 83       	std	Y+5, r24	; 0x05

                if( xSpace < xRequiredSpace )
    22d6:	2d 81       	ldd	r18, Y+5	; 0x05
    22d8:	3e 81       	ldd	r19, Y+6	; 0x06
    22da:	8b 81       	ldd	r24, Y+3	; 0x03
    22dc:	9c 81       	ldd	r25, Y+4	; 0x04
    22de:	28 17       	cp	r18, r24
    22e0:	39 07       	cpc	r19, r25
    22e2:	68 f5       	brcc	.+90     	; 0x233e <xStreamBufferSend+0x128>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    22e4:	80 e0       	ldi	r24, 0x00	; 0
    22e6:	90 e0       	ldi	r25, 0x00	; 0
    22e8:	60 e0       	ldi	r22, 0x00	; 0
    22ea:	0e 94 03 29 	call	0x5206	; 0x5206 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    22ee:	0e 94 18 22 	call	0x4430	; 0x4430 <xTaskGetCurrentTaskHandle>
    22f2:	e9 85       	ldd	r30, Y+9	; 0x09
    22f4:	fa 85       	ldd	r31, Y+10	; 0x0a
    22f6:	93 87       	std	Z+11, r25	; 0x0b
    22f8:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    22fa:	0f 90       	pop	r0
    22fc:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    22fe:	ec 89       	ldd	r30, Y+20	; 0x14
    2300:	fd 89       	ldd	r31, Y+21	; 0x15
    2302:	80 e0       	ldi	r24, 0x00	; 0
    2304:	40 e0       	ldi	r20, 0x00	; 0
    2306:	50 e0       	ldi	r21, 0x00	; 0
    2308:	60 e0       	ldi	r22, 0x00	; 0
    230a:	70 e0       	ldi	r23, 0x00	; 0
    230c:	00 e0       	ldi	r16, 0x00	; 0
    230e:	10 e0       	ldi	r17, 0x00	; 0
    2310:	20 e0       	ldi	r18, 0x00	; 0
    2312:	30 e0       	ldi	r19, 0x00	; 0
    2314:	ee 24       	eor	r14, r14
    2316:	ff 24       	eor	r15, r15
    2318:	6f 01       	movw	r12, r30
    231a:	0e 94 07 23 	call	0x460e	; 0x460e <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    231e:	e9 85       	ldd	r30, Y+9	; 0x09
    2320:	fa 85       	ldd	r31, Y+10	; 0x0a
    2322:	13 86       	std	Z+11, r1	; 0x0b
    2324:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2326:	ce 01       	movw	r24, r28
    2328:	0b 96       	adiw	r24, 0x0b	; 11
    232a:	9e 01       	movw	r18, r28
    232c:	2c 5e       	subi	r18, 0xEC	; 236
    232e:	3f 4f       	sbci	r19, 0xFF	; 255
    2330:	b9 01       	movw	r22, r18
    2332:	0e 94 f7 20 	call	0x41ee	; 0x41ee <xTaskCheckForTimeOut>
    2336:	88 23       	and	r24, r24
    2338:	09 f4       	brne	.+2      	; 0x233c <xStreamBufferSend+0x126>
    233a:	c4 cf       	rjmp	.-120    	; 0x22c4 <xStreamBufferSend+0xae>
    233c:	02 c0       	rjmp	.+4      	; 0x2342 <xStreamBufferSend+0x12c>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    233e:	0f 90       	pop	r0
    2340:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    2342:	8d 81       	ldd	r24, Y+5	; 0x05
    2344:	9e 81       	ldd	r25, Y+6	; 0x06
    2346:	00 97       	sbiw	r24, 0x00	; 0
    2348:	31 f4       	brne	.+12     	; 0x2356 <xStreamBufferSend+0x140>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    234a:	89 85       	ldd	r24, Y+9	; 0x09
    234c:	9a 85       	ldd	r25, Y+10	; 0x0a
    234e:	0e 94 95 10 	call	0x212a	; 0x212a <xStreamBufferSpacesAvailable>
    2352:	9e 83       	std	Y+6, r25	; 0x06
    2354:	8d 83       	std	Y+5, r24	; 0x05
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2356:	89 85       	ldd	r24, Y+9	; 0x09
    2358:	9a 85       	ldd	r25, Y+10	; 0x0a
    235a:	28 89       	ldd	r18, Y+16	; 0x10
    235c:	39 89       	ldd	r19, Y+17	; 0x11
    235e:	4a 89       	ldd	r20, Y+18	; 0x12
    2360:	5b 89       	ldd	r21, Y+19	; 0x13
    2362:	ed 81       	ldd	r30, Y+5	; 0x05
    2364:	fe 81       	ldd	r31, Y+6	; 0x06
    2366:	ab 81       	ldd	r26, Y+3	; 0x03
    2368:	bc 81       	ldd	r27, Y+4	; 0x04
    236a:	b9 01       	movw	r22, r18
    236c:	9f 01       	movw	r18, r30
    236e:	8d 01       	movw	r16, r26
    2370:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <prvWriteMessageToBuffer>
    2374:	98 87       	std	Y+8, r25	; 0x08
    2376:	8f 83       	std	Y+7, r24	; 0x07

    if( xReturn > ( size_t ) 0 )
    2378:	8f 81       	ldd	r24, Y+7	; 0x07
    237a:	98 85       	ldd	r25, Y+8	; 0x08
    237c:	00 97       	sbiw	r24, 0x00	; 0
    237e:	41 f1       	breq	.+80     	; 0x23d0 <xStreamBufferSend+0x1ba>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2380:	89 85       	ldd	r24, Y+9	; 0x09
    2382:	9a 85       	ldd	r25, Y+10	; 0x0a
    2384:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <prvBytesInBuffer>
    2388:	9c 01       	movw	r18, r24
    238a:	e9 85       	ldd	r30, Y+9	; 0x09
    238c:	fa 85       	ldd	r31, Y+10	; 0x0a
    238e:	86 81       	ldd	r24, Z+6	; 0x06
    2390:	97 81       	ldd	r25, Z+7	; 0x07
    2392:	28 17       	cp	r18, r24
    2394:	39 07       	cpc	r19, r25
    2396:	e0 f0       	brcs	.+56     	; 0x23d0 <xStreamBufferSend+0x1ba>
        {
            sbSEND_COMPLETED( pxStreamBuffer );
    2398:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
    239c:	e9 85       	ldd	r30, Y+9	; 0x09
    239e:	fa 85       	ldd	r31, Y+10	; 0x0a
    23a0:	80 85       	ldd	r24, Z+8	; 0x08
    23a2:	91 85       	ldd	r25, Z+9	; 0x09
    23a4:	00 97       	sbiw	r24, 0x00	; 0
    23a6:	91 f0       	breq	.+36     	; 0x23cc <xStreamBufferSend+0x1b6>
    23a8:	e9 85       	ldd	r30, Y+9	; 0x09
    23aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    23ac:	80 85       	ldd	r24, Z+8	; 0x08
    23ae:	91 85       	ldd	r25, Z+9	; 0x09
    23b0:	60 e0       	ldi	r22, 0x00	; 0
    23b2:	20 e0       	ldi	r18, 0x00	; 0
    23b4:	30 e0       	ldi	r19, 0x00	; 0
    23b6:	40 e0       	ldi	r20, 0x00	; 0
    23b8:	50 e0       	ldi	r21, 0x00	; 0
    23ba:	00 e0       	ldi	r16, 0x00	; 0
    23bc:	ee 24       	eor	r14, r14
    23be:	ff 24       	eor	r15, r15
    23c0:	0e 94 fe 23 	call	0x47fc	; 0x47fc <xTaskGenericNotify>
    23c4:	e9 85       	ldd	r30, Y+9	; 0x09
    23c6:	fa 85       	ldd	r31, Y+10	; 0x0a
    23c8:	11 86       	std	Z+9, r1	; 0x09
    23ca:	10 86       	std	Z+8, r1	; 0x08
    23cc:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    {
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
    23d0:	8f 81       	ldd	r24, Y+7	; 0x07
    23d2:	98 85       	ldd	r25, Y+8	; 0x08
}
    23d4:	65 96       	adiw	r28, 0x15	; 21
    23d6:	0f b6       	in	r0, 0x3f	; 63
    23d8:	f8 94       	cli
    23da:	de bf       	out	0x3e, r29	; 62
    23dc:	0f be       	out	0x3f, r0	; 63
    23de:	cd bf       	out	0x3d, r28	; 61
    23e0:	cf 91       	pop	r28
    23e2:	df 91       	pop	r29
    23e4:	1f 91       	pop	r17
    23e6:	0f 91       	pop	r16
    23e8:	ff 90       	pop	r15
    23ea:	ef 90       	pop	r14
    23ec:	df 90       	pop	r13
    23ee:	cf 90       	pop	r12
    23f0:	08 95       	ret

000023f2 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    23f2:	cf 92       	push	r12
    23f4:	df 92       	push	r13
    23f6:	ef 92       	push	r14
    23f8:	ff 92       	push	r15
    23fa:	0f 93       	push	r16
    23fc:	1f 93       	push	r17
    23fe:	df 93       	push	r29
    2400:	cf 93       	push	r28
    2402:	cd b7       	in	r28, 0x3d	; 61
    2404:	de b7       	in	r29, 0x3e	; 62
    2406:	61 97       	sbiw	r28, 0x11	; 17
    2408:	0f b6       	in	r0, 0x3f	; 63
    240a:	f8 94       	cli
    240c:	de bf       	out	0x3e, r29	; 62
    240e:	0f be       	out	0x3f, r0	; 63
    2410:	cd bf       	out	0x3d, r28	; 61
    2412:	9b 87       	std	Y+11, r25	; 0x0b
    2414:	8a 87       	std	Y+10, r24	; 0x0a
    2416:	7d 87       	std	Y+13, r23	; 0x0d
    2418:	6c 87       	std	Y+12, r22	; 0x0c
    241a:	5f 87       	std	Y+15, r21	; 0x0f
    241c:	4e 87       	std	Y+14, r20	; 0x0e
    241e:	39 8b       	std	Y+17, r19	; 0x11
    2420:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2422:	8a 85       	ldd	r24, Y+10	; 0x0a
    2424:	9b 85       	ldd	r25, Y+11	; 0x0b
    2426:	99 87       	std	Y+9, r25	; 0x09
    2428:	88 87       	std	Y+8, r24	; 0x08
    size_t xReturn, xSpace;
    size_t xRequiredSpace = xDataLengthBytes;
    242a:	8e 85       	ldd	r24, Y+14	; 0x0e
    242c:	9f 85       	ldd	r25, Y+15	; 0x0f
    242e:	9b 83       	std	Y+3, r25	; 0x03
    2430:	8a 83       	std	Y+2, r24	; 0x02

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2432:	e8 85       	ldd	r30, Y+8	; 0x08
    2434:	f9 85       	ldd	r31, Y+9	; 0x09
    2436:	86 85       	ldd	r24, Z+14	; 0x0e
    2438:	88 2f       	mov	r24, r24
    243a:	90 e0       	ldi	r25, 0x00	; 0
    243c:	81 70       	andi	r24, 0x01	; 1
    243e:	90 70       	andi	r25, 0x00	; 0
    2440:	88 23       	and	r24, r24
    2442:	29 f0       	breq	.+10     	; 0x244e <xStreamBufferSendFromISR+0x5c>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2444:	8a 81       	ldd	r24, Y+2	; 0x02
    2446:	9b 81       	ldd	r25, Y+3	; 0x03
    2448:	02 96       	adiw	r24, 0x02	; 2
    244a:	9b 83       	std	Y+3, r25	; 0x03
    244c:	8a 83       	std	Y+2, r24	; 0x02
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    244e:	88 85       	ldd	r24, Y+8	; 0x08
    2450:	99 85       	ldd	r25, Y+9	; 0x09
    2452:	0e 94 95 10 	call	0x212a	; 0x212a <xStreamBufferSpacesAvailable>
    2456:	9d 83       	std	Y+5, r25	; 0x05
    2458:	8c 83       	std	Y+4, r24	; 0x04
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    245a:	88 85       	ldd	r24, Y+8	; 0x08
    245c:	99 85       	ldd	r25, Y+9	; 0x09
    245e:	2c 85       	ldd	r18, Y+12	; 0x0c
    2460:	3d 85       	ldd	r19, Y+13	; 0x0d
    2462:	4e 85       	ldd	r20, Y+14	; 0x0e
    2464:	5f 85       	ldd	r21, Y+15	; 0x0f
    2466:	ec 81       	ldd	r30, Y+4	; 0x04
    2468:	fd 81       	ldd	r31, Y+5	; 0x05
    246a:	aa 81       	ldd	r26, Y+2	; 0x02
    246c:	bb 81       	ldd	r27, Y+3	; 0x03
    246e:	b9 01       	movw	r22, r18
    2470:	9f 01       	movw	r18, r30
    2472:	8d 01       	movw	r16, r26
    2474:	0e 94 7b 12 	call	0x24f6	; 0x24f6 <prvWriteMessageToBuffer>
    2478:	9f 83       	std	Y+7, r25	; 0x07
    247a:	8e 83       	std	Y+6, r24	; 0x06

    if( xReturn > ( size_t ) 0 )
    247c:	8e 81       	ldd	r24, Y+6	; 0x06
    247e:	9f 81       	ldd	r25, Y+7	; 0x07
    2480:	00 97       	sbiw	r24, 0x00	; 0
    2482:	41 f1       	breq	.+80     	; 0x24d4 <xStreamBufferSendFromISR+0xe2>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2484:	88 85       	ldd	r24, Y+8	; 0x08
    2486:	99 85       	ldd	r25, Y+9	; 0x09
    2488:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <prvBytesInBuffer>
    248c:	9c 01       	movw	r18, r24
    248e:	e8 85       	ldd	r30, Y+8	; 0x08
    2490:	f9 85       	ldd	r31, Y+9	; 0x09
    2492:	86 81       	ldd	r24, Z+6	; 0x06
    2494:	97 81       	ldd	r25, Z+7	; 0x07
    2496:	28 17       	cp	r18, r24
    2498:	39 07       	cpc	r19, r25
    249a:	e0 f0       	brcs	.+56     	; 0x24d4 <xStreamBufferSendFromISR+0xe2>
        {
            sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    249c:	19 82       	std	Y+1, r1	; 0x01
    249e:	e8 85       	ldd	r30, Y+8	; 0x08
    24a0:	f9 85       	ldd	r31, Y+9	; 0x09
    24a2:	80 85       	ldd	r24, Z+8	; 0x08
    24a4:	91 85       	ldd	r25, Z+9	; 0x09
    24a6:	00 97       	sbiw	r24, 0x00	; 0
    24a8:	a9 f0       	breq	.+42     	; 0x24d4 <xStreamBufferSendFromISR+0xe2>
    24aa:	e8 85       	ldd	r30, Y+8	; 0x08
    24ac:	f9 85       	ldd	r31, Y+9	; 0x09
    24ae:	80 85       	ldd	r24, Z+8	; 0x08
    24b0:	91 85       	ldd	r25, Z+9	; 0x09
    24b2:	e8 89       	ldd	r30, Y+16	; 0x10
    24b4:	f9 89       	ldd	r31, Y+17	; 0x11
    24b6:	60 e0       	ldi	r22, 0x00	; 0
    24b8:	20 e0       	ldi	r18, 0x00	; 0
    24ba:	30 e0       	ldi	r19, 0x00	; 0
    24bc:	40 e0       	ldi	r20, 0x00	; 0
    24be:	50 e0       	ldi	r21, 0x00	; 0
    24c0:	00 e0       	ldi	r16, 0x00	; 0
    24c2:	ee 24       	eor	r14, r14
    24c4:	ff 24       	eor	r15, r15
    24c6:	6f 01       	movw	r12, r30
    24c8:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <xTaskGenericNotifyFromISR>
    24cc:	e8 85       	ldd	r30, Y+8	; 0x08
    24ce:	f9 85       	ldd	r31, Y+9	; 0x09
    24d0:	11 86       	std	Z+9, r1	; 0x09
    24d2:	10 86       	std	Z+8, r1	; 0x08
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
    24d4:	8e 81       	ldd	r24, Y+6	; 0x06
    24d6:	9f 81       	ldd	r25, Y+7	; 0x07
}
    24d8:	61 96       	adiw	r28, 0x11	; 17
    24da:	0f b6       	in	r0, 0x3f	; 63
    24dc:	f8 94       	cli
    24de:	de bf       	out	0x3e, r29	; 62
    24e0:	0f be       	out	0x3f, r0	; 63
    24e2:	cd bf       	out	0x3d, r28	; 61
    24e4:	cf 91       	pop	r28
    24e6:	df 91       	pop	r29
    24e8:	1f 91       	pop	r17
    24ea:	0f 91       	pop	r16
    24ec:	ff 90       	pop	r15
    24ee:	ef 90       	pop	r14
    24f0:	df 90       	pop	r13
    24f2:	cf 90       	pop	r12
    24f4:	08 95       	ret

000024f6 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    24f6:	0f 93       	push	r16
    24f8:	1f 93       	push	r17
    24fa:	df 93       	push	r29
    24fc:	cf 93       	push	r28
    24fe:	cd b7       	in	r28, 0x3d	; 61
    2500:	de b7       	in	r29, 0x3e	; 62
    2502:	60 97       	sbiw	r28, 0x10	; 16
    2504:	0f b6       	in	r0, 0x3f	; 63
    2506:	f8 94       	cli
    2508:	de bf       	out	0x3e, r29	; 62
    250a:	0f be       	out	0x3f, r0	; 63
    250c:	cd bf       	out	0x3d, r28	; 61
    250e:	9c 83       	std	Y+4, r25	; 0x04
    2510:	8b 83       	std	Y+3, r24	; 0x03
    2512:	7e 83       	std	Y+6, r23	; 0x06
    2514:	6d 83       	std	Y+5, r22	; 0x05
    2516:	58 87       	std	Y+8, r21	; 0x08
    2518:	4f 83       	std	Y+7, r20	; 0x07
    251a:	3a 87       	std	Y+10, r19	; 0x0a
    251c:	29 87       	std	Y+9, r18	; 0x09
    251e:	1c 87       	std	Y+12, r17	; 0x0c
    2520:	0b 87       	std	Y+11, r16	; 0x0b
    size_t xNextHead = pxStreamBuffer->xHead;
    2522:	eb 81       	ldd	r30, Y+3	; 0x03
    2524:	fc 81       	ldd	r31, Y+4	; 0x04
    2526:	82 81       	ldd	r24, Z+2	; 0x02
    2528:	93 81       	ldd	r25, Z+3	; 0x03
    252a:	9a 83       	std	Y+2, r25	; 0x02
    252c:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    252e:	eb 81       	ldd	r30, Y+3	; 0x03
    2530:	fc 81       	ldd	r31, Y+4	; 0x04
    2532:	86 85       	ldd	r24, Z+14	; 0x0e
    2534:	88 2f       	mov	r24, r24
    2536:	90 e0       	ldi	r25, 0x00	; 0
    2538:	81 70       	andi	r24, 0x01	; 1
    253a:	90 70       	andi	r25, 0x00	; 0
    253c:	88 23       	and	r24, r24
    253e:	d1 f0       	breq	.+52     	; 0x2574 <prvWriteMessageToBuffer+0x7e>
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        if( xSpace >= xRequiredSpace )
    2540:	29 85       	ldd	r18, Y+9	; 0x09
    2542:	3a 85       	ldd	r19, Y+10	; 0x0a
    2544:	8b 85       	ldd	r24, Y+11	; 0x0b
    2546:	9c 85       	ldd	r25, Y+12	; 0x0c
    2548:	28 17       	cp	r18, r24
    254a:	39 07       	cpc	r19, r25
    254c:	80 f0       	brcs	.+32     	; 0x256e <prvWriteMessageToBuffer+0x78>
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    254e:	9e 01       	movw	r18, r28
    2550:	29 5f       	subi	r18, 0xF9	; 249
    2552:	3f 4f       	sbci	r19, 0xFF	; 255
    2554:	8b 81       	ldd	r24, Y+3	; 0x03
    2556:	9c 81       	ldd	r25, Y+4	; 0x04
    2558:	e9 81       	ldd	r30, Y+1	; 0x01
    255a:	fa 81       	ldd	r31, Y+2	; 0x02
    255c:	b9 01       	movw	r22, r18
    255e:	42 e0       	ldi	r20, 0x02	; 2
    2560:	50 e0       	ldi	r21, 0x00	; 0
    2562:	9f 01       	movw	r18, r30
    2564:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <prvWriteBytesToBuffer>
    2568:	9a 83       	std	Y+2, r25	; 0x02
    256a:	89 83       	std	Y+1, r24	; 0x01
    256c:	1a c0       	rjmp	.+52     	; 0x25a2 <prvWriteMessageToBuffer+0xac>
        }
        else
        {
            /* Not enough space, so do not write data to the buffer. */
            xDataLengthBytes = 0;
    256e:	18 86       	std	Y+8, r1	; 0x08
    2570:	1f 82       	std	Y+7, r1	; 0x07
    2572:	17 c0       	rjmp	.+46     	; 0x25a2 <prvWriteMessageToBuffer+0xac>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    2574:	2f 81       	ldd	r18, Y+7	; 0x07
    2576:	38 85       	ldd	r19, Y+8	; 0x08
    2578:	38 8b       	std	Y+16, r19	; 0x10
    257a:	2f 87       	std	Y+15, r18	; 0x0f
    257c:	89 85       	ldd	r24, Y+9	; 0x09
    257e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2580:	9e 87       	std	Y+14, r25	; 0x0e
    2582:	8d 87       	std	Y+13, r24	; 0x0d
    2584:	2d 85       	ldd	r18, Y+13	; 0x0d
    2586:	3e 85       	ldd	r19, Y+14	; 0x0e
    2588:	8f 85       	ldd	r24, Y+15	; 0x0f
    258a:	98 89       	ldd	r25, Y+16	; 0x10
    258c:	82 17       	cp	r24, r18
    258e:	93 07       	cpc	r25, r19
    2590:	20 f4       	brcc	.+8      	; 0x259a <prvWriteMessageToBuffer+0xa4>
    2592:	2f 85       	ldd	r18, Y+15	; 0x0f
    2594:	38 89       	ldd	r19, Y+16	; 0x10
    2596:	3e 87       	std	Y+14, r19	; 0x0e
    2598:	2d 87       	std	Y+13, r18	; 0x0d
    259a:	8d 85       	ldd	r24, Y+13	; 0x0d
    259c:	9e 85       	ldd	r25, Y+14	; 0x0e
    259e:	98 87       	std	Y+8, r25	; 0x08
    25a0:	8f 83       	std	Y+7, r24	; 0x07
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    25a2:	8f 81       	ldd	r24, Y+7	; 0x07
    25a4:	98 85       	ldd	r25, Y+8	; 0x08
    25a6:	00 97       	sbiw	r24, 0x00	; 0
    25a8:	81 f0       	breq	.+32     	; 0x25ca <prvWriteMessageToBuffer+0xd4>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    25aa:	4d 81       	ldd	r20, Y+5	; 0x05
    25ac:	5e 81       	ldd	r21, Y+6	; 0x06
    25ae:	ef 81       	ldd	r30, Y+7	; 0x07
    25b0:	f8 85       	ldd	r31, Y+8	; 0x08
    25b2:	8b 81       	ldd	r24, Y+3	; 0x03
    25b4:	9c 81       	ldd	r25, Y+4	; 0x04
    25b6:	29 81       	ldd	r18, Y+1	; 0x01
    25b8:	3a 81       	ldd	r19, Y+2	; 0x02
    25ba:	ba 01       	movw	r22, r20
    25bc:	af 01       	movw	r20, r30
    25be:	0e 94 e0 15 	call	0x2bc0	; 0x2bc0 <prvWriteBytesToBuffer>
    25c2:	eb 81       	ldd	r30, Y+3	; 0x03
    25c4:	fc 81       	ldd	r31, Y+4	; 0x04
    25c6:	93 83       	std	Z+3, r25	; 0x03
    25c8:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
    25ca:	8f 81       	ldd	r24, Y+7	; 0x07
    25cc:	98 85       	ldd	r25, Y+8	; 0x08
}
    25ce:	60 96       	adiw	r28, 0x10	; 16
    25d0:	0f b6       	in	r0, 0x3f	; 63
    25d2:	f8 94       	cli
    25d4:	de bf       	out	0x3e, r29	; 62
    25d6:	0f be       	out	0x3f, r0	; 63
    25d8:	cd bf       	out	0x3d, r28	; 61
    25da:	cf 91       	pop	r28
    25dc:	df 91       	pop	r29
    25de:	1f 91       	pop	r17
    25e0:	0f 91       	pop	r16
    25e2:	08 95       	ret

000025e4 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    25e4:	cf 92       	push	r12
    25e6:	df 92       	push	r13
    25e8:	ef 92       	push	r14
    25ea:	ff 92       	push	r15
    25ec:	0f 93       	push	r16
    25ee:	1f 93       	push	r17
    25f0:	df 93       	push	r29
    25f2:	cf 93       	push	r28
    25f4:	cd b7       	in	r28, 0x3d	; 61
    25f6:	de b7       	in	r29, 0x3e	; 62
    25f8:	60 97       	sbiw	r28, 0x10	; 16
    25fa:	0f b6       	in	r0, 0x3f	; 63
    25fc:	f8 94       	cli
    25fe:	de bf       	out	0x3e, r29	; 62
    2600:	0f be       	out	0x3f, r0	; 63
    2602:	cd bf       	out	0x3d, r28	; 61
    2604:	9a 87       	std	Y+10, r25	; 0x0a
    2606:	89 87       	std	Y+9, r24	; 0x09
    2608:	7c 87       	std	Y+12, r23	; 0x0c
    260a:	6b 87       	std	Y+11, r22	; 0x0b
    260c:	5e 87       	std	Y+14, r21	; 0x0e
    260e:	4d 87       	std	Y+13, r20	; 0x0d
    2610:	38 8b       	std	Y+16, r19	; 0x10
    2612:	2f 87       	std	Y+15, r18	; 0x0f
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2614:	89 85       	ldd	r24, Y+9	; 0x09
    2616:	9a 85       	ldd	r25, Y+10	; 0x0a
    2618:	98 87       	std	Y+8, r25	; 0x08
    261a:	8f 83       	std	Y+7, r24	; 0x07
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    261c:	1e 82       	std	Y+6, r1	; 0x06
    261e:	1d 82       	std	Y+5, r1	; 0x05
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2620:	ef 81       	ldd	r30, Y+7	; 0x07
    2622:	f8 85       	ldd	r31, Y+8	; 0x08
    2624:	86 85       	ldd	r24, Z+14	; 0x0e
    2626:	88 2f       	mov	r24, r24
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	81 70       	andi	r24, 0x01	; 1
    262c:	90 70       	andi	r25, 0x00	; 0
    262e:	88 23       	and	r24, r24
    2630:	29 f0       	breq	.+10     	; 0x263c <xStreamBufferReceive+0x58>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2632:	82 e0       	ldi	r24, 0x02	; 2
    2634:	90 e0       	ldi	r25, 0x00	; 0
    2636:	9a 83       	std	Y+2, r25	; 0x02
    2638:	89 83       	std	Y+1, r24	; 0x01
    263a:	02 c0       	rjmp	.+4      	; 0x2640 <xStreamBufferReceive+0x5c>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    263c:	1a 82       	std	Y+2, r1	; 0x02
    263e:	19 82       	std	Y+1, r1	; 0x01
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    2640:	8f 85       	ldd	r24, Y+15	; 0x0f
    2642:	98 89       	ldd	r25, Y+16	; 0x10
    2644:	00 97       	sbiw	r24, 0x00	; 0
    2646:	09 f4       	brne	.+2      	; 0x264a <xStreamBufferReceive+0x66>
    2648:	3f c0       	rjmp	.+126    	; 0x26c8 <xStreamBufferReceive+0xe4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    264a:	0f b6       	in	r0, 0x3f	; 63
    264c:	f8 94       	cli
    264e:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2650:	8f 81       	ldd	r24, Y+7	; 0x07
    2652:	98 85       	ldd	r25, Y+8	; 0x08
    2654:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <prvBytesInBuffer>
    2658:	9c 83       	std	Y+4, r25	; 0x04
    265a:	8b 83       	std	Y+3, r24	; 0x03
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    265c:	2b 81       	ldd	r18, Y+3	; 0x03
    265e:	3c 81       	ldd	r19, Y+4	; 0x04
    2660:	89 81       	ldd	r24, Y+1	; 0x01
    2662:	9a 81       	ldd	r25, Y+2	; 0x02
    2664:	82 17       	cp	r24, r18
    2666:	93 07       	cpc	r25, r19
    2668:	58 f0       	brcs	.+22     	; 0x2680 <xStreamBufferReceive+0x9c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    266a:	80 e0       	ldi	r24, 0x00	; 0
    266c:	90 e0       	ldi	r25, 0x00	; 0
    266e:	60 e0       	ldi	r22, 0x00	; 0
    2670:	0e 94 03 29 	call	0x5206	; 0x5206 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    2674:	0e 94 18 22 	call	0x4430	; 0x4430 <xTaskGetCurrentTaskHandle>
    2678:	ef 81       	ldd	r30, Y+7	; 0x07
    267a:	f8 85       	ldd	r31, Y+8	; 0x08
    267c:	91 87       	std	Z+9, r25	; 0x09
    267e:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2680:	0f 90       	pop	r0
    2682:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    2684:	2b 81       	ldd	r18, Y+3	; 0x03
    2686:	3c 81       	ldd	r19, Y+4	; 0x04
    2688:	89 81       	ldd	r24, Y+1	; 0x01
    268a:	9a 81       	ldd	r25, Y+2	; 0x02
    268c:	82 17       	cp	r24, r18
    268e:	93 07       	cpc	r25, r19
    2690:	08 f1       	brcs	.+66     	; 0x26d4 <xStreamBufferReceive+0xf0>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2692:	ef 85       	ldd	r30, Y+15	; 0x0f
    2694:	f8 89       	ldd	r31, Y+16	; 0x10
    2696:	80 e0       	ldi	r24, 0x00	; 0
    2698:	40 e0       	ldi	r20, 0x00	; 0
    269a:	50 e0       	ldi	r21, 0x00	; 0
    269c:	60 e0       	ldi	r22, 0x00	; 0
    269e:	70 e0       	ldi	r23, 0x00	; 0
    26a0:	00 e0       	ldi	r16, 0x00	; 0
    26a2:	10 e0       	ldi	r17, 0x00	; 0
    26a4:	20 e0       	ldi	r18, 0x00	; 0
    26a6:	30 e0       	ldi	r19, 0x00	; 0
    26a8:	ee 24       	eor	r14, r14
    26aa:	ff 24       	eor	r15, r15
    26ac:	6f 01       	movw	r12, r30
    26ae:	0e 94 07 23 	call	0x460e	; 0x460e <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    26b2:	ef 81       	ldd	r30, Y+7	; 0x07
    26b4:	f8 85       	ldd	r31, Y+8	; 0x08
    26b6:	11 86       	std	Z+9, r1	; 0x09
    26b8:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    26ba:	8f 81       	ldd	r24, Y+7	; 0x07
    26bc:	98 85       	ldd	r25, Y+8	; 0x08
    26be:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <prvBytesInBuffer>
    26c2:	9c 83       	std	Y+4, r25	; 0x04
    26c4:	8b 83       	std	Y+3, r24	; 0x03
    26c6:	06 c0       	rjmp	.+12     	; 0x26d4 <xStreamBufferReceive+0xf0>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    26c8:	8f 81       	ldd	r24, Y+7	; 0x07
    26ca:	98 85       	ldd	r25, Y+8	; 0x08
    26cc:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <prvBytesInBuffer>
    26d0:	9c 83       	std	Y+4, r25	; 0x04
    26d2:	8b 83       	std	Y+3, r24	; 0x03
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    26d4:	2b 81       	ldd	r18, Y+3	; 0x03
    26d6:	3c 81       	ldd	r19, Y+4	; 0x04
    26d8:	89 81       	ldd	r24, Y+1	; 0x01
    26da:	9a 81       	ldd	r25, Y+2	; 0x02
    26dc:	82 17       	cp	r24, r18
    26de:	93 07       	cpc	r25, r19
    26e0:	70 f5       	brcc	.+92     	; 0x273e <xStreamBufferReceive+0x15a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    26e2:	8f 81       	ldd	r24, Y+7	; 0x07
    26e4:	98 85       	ldd	r25, Y+8	; 0x08
    26e6:	2b 85       	ldd	r18, Y+11	; 0x0b
    26e8:	3c 85       	ldd	r19, Y+12	; 0x0c
    26ea:	4d 85       	ldd	r20, Y+13	; 0x0d
    26ec:	5e 85       	ldd	r21, Y+14	; 0x0e
    26ee:	eb 81       	ldd	r30, Y+3	; 0x03
    26f0:	fc 81       	ldd	r31, Y+4	; 0x04
    26f2:	b9 01       	movw	r22, r18
    26f4:	9f 01       	movw	r18, r30
    26f6:	0e 94 71 14 	call	0x28e2	; 0x28e2 <prvReadMessageFromBuffer>
    26fa:	9e 83       	std	Y+6, r25	; 0x06
    26fc:	8d 83       	std	Y+5, r24	; 0x05

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    26fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2700:	9e 81       	ldd	r25, Y+6	; 0x06
    2702:	00 97       	sbiw	r24, 0x00	; 0
    2704:	e1 f0       	breq	.+56     	; 0x273e <xStreamBufferReceive+0x15a>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            sbRECEIVE_COMPLETED( pxStreamBuffer );
    2706:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
    270a:	ef 81       	ldd	r30, Y+7	; 0x07
    270c:	f8 85       	ldd	r31, Y+8	; 0x08
    270e:	82 85       	ldd	r24, Z+10	; 0x0a
    2710:	93 85       	ldd	r25, Z+11	; 0x0b
    2712:	00 97       	sbiw	r24, 0x00	; 0
    2714:	91 f0       	breq	.+36     	; 0x273a <xStreamBufferReceive+0x156>
    2716:	ef 81       	ldd	r30, Y+7	; 0x07
    2718:	f8 85       	ldd	r31, Y+8	; 0x08
    271a:	82 85       	ldd	r24, Z+10	; 0x0a
    271c:	93 85       	ldd	r25, Z+11	; 0x0b
    271e:	60 e0       	ldi	r22, 0x00	; 0
    2720:	20 e0       	ldi	r18, 0x00	; 0
    2722:	30 e0       	ldi	r19, 0x00	; 0
    2724:	40 e0       	ldi	r20, 0x00	; 0
    2726:	50 e0       	ldi	r21, 0x00	; 0
    2728:	00 e0       	ldi	r16, 0x00	; 0
    272a:	ee 24       	eor	r14, r14
    272c:	ff 24       	eor	r15, r15
    272e:	0e 94 fe 23 	call	0x47fc	; 0x47fc <xTaskGenericNotify>
    2732:	ef 81       	ldd	r30, Y+7	; 0x07
    2734:	f8 85       	ldd	r31, Y+8	; 0x08
    2736:	13 86       	std	Z+11, r1	; 0x0b
    2738:	12 86       	std	Z+10, r1	; 0x0a
    273a:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    {
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
    273e:	8d 81       	ldd	r24, Y+5	; 0x05
    2740:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2742:	60 96       	adiw	r28, 0x10	; 16
    2744:	0f b6       	in	r0, 0x3f	; 63
    2746:	f8 94       	cli
    2748:	de bf       	out	0x3e, r29	; 62
    274a:	0f be       	out	0x3f, r0	; 63
    274c:	cd bf       	out	0x3d, r28	; 61
    274e:	cf 91       	pop	r28
    2750:	df 91       	pop	r29
    2752:	1f 91       	pop	r17
    2754:	0f 91       	pop	r16
    2756:	ff 90       	pop	r15
    2758:	ef 90       	pop	r14
    275a:	df 90       	pop	r13
    275c:	cf 90       	pop	r12
    275e:	08 95       	ret

00002760 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    2760:	df 93       	push	r29
    2762:	cf 93       	push	r28
    2764:	cd b7       	in	r28, 0x3d	; 61
    2766:	de b7       	in	r29, 0x3e	; 62
    2768:	2a 97       	sbiw	r28, 0x0a	; 10
    276a:	0f b6       	in	r0, 0x3f	; 63
    276c:	f8 94       	cli
    276e:	de bf       	out	0x3e, r29	; 62
    2770:	0f be       	out	0x3f, r0	; 63
    2772:	cd bf       	out	0x3d, r28	; 61
    2774:	9a 87       	std	Y+10, r25	; 0x0a
    2776:	89 87       	std	Y+9, r24	; 0x09
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2778:	89 85       	ldd	r24, Y+9	; 0x09
    277a:	9a 85       	ldd	r25, Y+10	; 0x0a
    277c:	9e 83       	std	Y+6, r25	; 0x06
    277e:	8d 83       	std	Y+5, r24	; 0x05
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2780:	ed 81       	ldd	r30, Y+5	; 0x05
    2782:	fe 81       	ldd	r31, Y+6	; 0x06
    2784:	86 85       	ldd	r24, Z+14	; 0x0e
    2786:	88 2f       	mov	r24, r24
    2788:	90 e0       	ldi	r25, 0x00	; 0
    278a:	81 70       	andi	r24, 0x01	; 1
    278c:	90 70       	andi	r25, 0x00	; 0
    278e:	88 23       	and	r24, r24
    2790:	19 f1       	breq	.+70     	; 0x27d8 <xStreamBufferNextMessageLengthBytes+0x78>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2792:	8d 81       	ldd	r24, Y+5	; 0x05
    2794:	9e 81       	ldd	r25, Y+6	; 0x06
    2796:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <prvBytesInBuffer>
    279a:	9a 83       	std	Y+2, r25	; 0x02
    279c:	89 83       	std	Y+1, r24	; 0x01

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    279e:	89 81       	ldd	r24, Y+1	; 0x01
    27a0:	9a 81       	ldd	r25, Y+2	; 0x02
    27a2:	83 30       	cpi	r24, 0x03	; 3
    27a4:	91 05       	cpc	r25, r1
    27a6:	a8 f0       	brcs	.+42     	; 0x27d2 <xStreamBufferNextMessageLengthBytes+0x72>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    27a8:	9e 01       	movw	r18, r28
    27aa:	29 5f       	subi	r18, 0xF9	; 249
    27ac:	3f 4f       	sbci	r19, 0xFF	; 255
    27ae:	ed 81       	ldd	r30, Y+5	; 0x05
    27b0:	fe 81       	ldd	r31, Y+6	; 0x06
    27b2:	01 90       	ld	r0, Z+
    27b4:	f0 81       	ld	r31, Z
    27b6:	e0 2d       	mov	r30, r0
    27b8:	8d 81       	ldd	r24, Y+5	; 0x05
    27ba:	9e 81       	ldd	r25, Y+6	; 0x06
    27bc:	b9 01       	movw	r22, r18
    27be:	42 e0       	ldi	r20, 0x02	; 2
    27c0:	50 e0       	ldi	r21, 0x00	; 0
    27c2:	9f 01       	movw	r18, r30
    27c4:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    27c8:	8f 81       	ldd	r24, Y+7	; 0x07
    27ca:	98 85       	ldd	r25, Y+8	; 0x08
    27cc:	9c 83       	std	Y+4, r25	; 0x04
    27ce:	8b 83       	std	Y+3, r24	; 0x03
    27d0:	05 c0       	rjmp	.+10     	; 0x27dc <xStreamBufferNextMessageLengthBytes+0x7c>
            /* The minimum amount of bytes in a message buffer is
             * ( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
             * less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
             * value is 0. */
            configASSERT( xBytesAvailable == 0 );
            xReturn = 0;
    27d2:	1c 82       	std	Y+4, r1	; 0x04
    27d4:	1b 82       	std	Y+3, r1	; 0x03
    27d6:	02 c0       	rjmp	.+4      	; 0x27dc <xStreamBufferNextMessageLengthBytes+0x7c>
        }
    }
    else
    {
        xReturn = 0;
    27d8:	1c 82       	std	Y+4, r1	; 0x04
    27da:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    27dc:	8b 81       	ldd	r24, Y+3	; 0x03
    27de:	9c 81       	ldd	r25, Y+4	; 0x04
}
    27e0:	2a 96       	adiw	r28, 0x0a	; 10
    27e2:	0f b6       	in	r0, 0x3f	; 63
    27e4:	f8 94       	cli
    27e6:	de bf       	out	0x3e, r29	; 62
    27e8:	0f be       	out	0x3f, r0	; 63
    27ea:	cd bf       	out	0x3d, r28	; 61
    27ec:	cf 91       	pop	r28
    27ee:	df 91       	pop	r29
    27f0:	08 95       	ret

000027f2 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    27f2:	cf 92       	push	r12
    27f4:	df 92       	push	r13
    27f6:	ef 92       	push	r14
    27f8:	ff 92       	push	r15
    27fa:	0f 93       	push	r16
    27fc:	df 93       	push	r29
    27fe:	cf 93       	push	r28
    2800:	cd b7       	in	r28, 0x3d	; 61
    2802:	de b7       	in	r29, 0x3e	; 62
    2804:	61 97       	sbiw	r28, 0x11	; 17
    2806:	0f b6       	in	r0, 0x3f	; 63
    2808:	f8 94       	cli
    280a:	de bf       	out	0x3e, r29	; 62
    280c:	0f be       	out	0x3f, r0	; 63
    280e:	cd bf       	out	0x3d, r28	; 61
    2810:	9b 87       	std	Y+11, r25	; 0x0b
    2812:	8a 87       	std	Y+10, r24	; 0x0a
    2814:	7d 87       	std	Y+13, r23	; 0x0d
    2816:	6c 87       	std	Y+12, r22	; 0x0c
    2818:	5f 87       	std	Y+15, r21	; 0x0f
    281a:	4e 87       	std	Y+14, r20	; 0x0e
    281c:	39 8b       	std	Y+17, r19	; 0x11
    281e:	28 8b       	std	Y+16, r18	; 0x10
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2820:	8a 85       	ldd	r24, Y+10	; 0x0a
    2822:	9b 85       	ldd	r25, Y+11	; 0x0b
    2824:	99 87       	std	Y+9, r25	; 0x09
    2826:	88 87       	std	Y+8, r24	; 0x08
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2828:	1f 82       	std	Y+7, r1	; 0x07
    282a:	1e 82       	std	Y+6, r1	; 0x06
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    282c:	e8 85       	ldd	r30, Y+8	; 0x08
    282e:	f9 85       	ldd	r31, Y+9	; 0x09
    2830:	86 85       	ldd	r24, Z+14	; 0x0e
    2832:	88 2f       	mov	r24, r24
    2834:	90 e0       	ldi	r25, 0x00	; 0
    2836:	81 70       	andi	r24, 0x01	; 1
    2838:	90 70       	andi	r25, 0x00	; 0
    283a:	88 23       	and	r24, r24
    283c:	29 f0       	breq	.+10     	; 0x2848 <xStreamBufferReceiveFromISR+0x56>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    283e:	82 e0       	ldi	r24, 0x02	; 2
    2840:	90 e0       	ldi	r25, 0x00	; 0
    2842:	9b 83       	std	Y+3, r25	; 0x03
    2844:	8a 83       	std	Y+2, r24	; 0x02
    2846:	02 c0       	rjmp	.+4      	; 0x284c <xStreamBufferReceiveFromISR+0x5a>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    2848:	1b 82       	std	Y+3, r1	; 0x03
    284a:	1a 82       	std	Y+2, r1	; 0x02
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    284c:	88 85       	ldd	r24, Y+8	; 0x08
    284e:	99 85       	ldd	r25, Y+9	; 0x09
    2850:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <prvBytesInBuffer>
    2854:	9d 83       	std	Y+5, r25	; 0x05
    2856:	8c 83       	std	Y+4, r24	; 0x04
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    2858:	2c 81       	ldd	r18, Y+4	; 0x04
    285a:	3d 81       	ldd	r19, Y+5	; 0x05
    285c:	8a 81       	ldd	r24, Y+2	; 0x02
    285e:	9b 81       	ldd	r25, Y+3	; 0x03
    2860:	82 17       	cp	r24, r18
    2862:	93 07       	cpc	r25, r19
    2864:	70 f5       	brcc	.+92     	; 0x28c2 <xStreamBufferReceiveFromISR+0xd0>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    2866:	88 85       	ldd	r24, Y+8	; 0x08
    2868:	99 85       	ldd	r25, Y+9	; 0x09
    286a:	2c 85       	ldd	r18, Y+12	; 0x0c
    286c:	3d 85       	ldd	r19, Y+13	; 0x0d
    286e:	4e 85       	ldd	r20, Y+14	; 0x0e
    2870:	5f 85       	ldd	r21, Y+15	; 0x0f
    2872:	ec 81       	ldd	r30, Y+4	; 0x04
    2874:	fd 81       	ldd	r31, Y+5	; 0x05
    2876:	b9 01       	movw	r22, r18
    2878:	9f 01       	movw	r18, r30
    287a:	0e 94 71 14 	call	0x28e2	; 0x28e2 <prvReadMessageFromBuffer>
    287e:	9f 83       	std	Y+7, r25	; 0x07
    2880:	8e 83       	std	Y+6, r24	; 0x06

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    2882:	8e 81       	ldd	r24, Y+6	; 0x06
    2884:	9f 81       	ldd	r25, Y+7	; 0x07
    2886:	00 97       	sbiw	r24, 0x00	; 0
    2888:	e1 f0       	breq	.+56     	; 0x28c2 <xStreamBufferReceiveFromISR+0xd0>
        {
            sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    288a:	19 82       	std	Y+1, r1	; 0x01
    288c:	e8 85       	ldd	r30, Y+8	; 0x08
    288e:	f9 85       	ldd	r31, Y+9	; 0x09
    2890:	82 85       	ldd	r24, Z+10	; 0x0a
    2892:	93 85       	ldd	r25, Z+11	; 0x0b
    2894:	00 97       	sbiw	r24, 0x00	; 0
    2896:	a9 f0       	breq	.+42     	; 0x28c2 <xStreamBufferReceiveFromISR+0xd0>
    2898:	e8 85       	ldd	r30, Y+8	; 0x08
    289a:	f9 85       	ldd	r31, Y+9	; 0x09
    289c:	82 85       	ldd	r24, Z+10	; 0x0a
    289e:	93 85       	ldd	r25, Z+11	; 0x0b
    28a0:	e8 89       	ldd	r30, Y+16	; 0x10
    28a2:	f9 89       	ldd	r31, Y+17	; 0x11
    28a4:	60 e0       	ldi	r22, 0x00	; 0
    28a6:	20 e0       	ldi	r18, 0x00	; 0
    28a8:	30 e0       	ldi	r19, 0x00	; 0
    28aa:	40 e0       	ldi	r20, 0x00	; 0
    28ac:	50 e0       	ldi	r21, 0x00	; 0
    28ae:	00 e0       	ldi	r16, 0x00	; 0
    28b0:	ee 24       	eor	r14, r14
    28b2:	ff 24       	eor	r15, r15
    28b4:	6f 01       	movw	r12, r30
    28b6:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <xTaskGenericNotifyFromISR>
    28ba:	e8 85       	ldd	r30, Y+8	; 0x08
    28bc:	f9 85       	ldd	r31, Y+9	; 0x09
    28be:	13 86       	std	Z+11, r1	; 0x0b
    28c0:	12 86       	std	Z+10, r1	; 0x0a
        mtCOVERAGE_TEST_MARKER();
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
    28c2:	8e 81       	ldd	r24, Y+6	; 0x06
    28c4:	9f 81       	ldd	r25, Y+7	; 0x07
}
    28c6:	61 96       	adiw	r28, 0x11	; 17
    28c8:	0f b6       	in	r0, 0x3f	; 63
    28ca:	f8 94       	cli
    28cc:	de bf       	out	0x3e, r29	; 62
    28ce:	0f be       	out	0x3f, r0	; 63
    28d0:	cd bf       	out	0x3d, r28	; 61
    28d2:	cf 91       	pop	r28
    28d4:	df 91       	pop	r29
    28d6:	0f 91       	pop	r16
    28d8:	ff 90       	pop	r15
    28da:	ef 90       	pop	r14
    28dc:	df 90       	pop	r13
    28de:	cf 90       	pop	r12
    28e0:	08 95       	ret

000028e2 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    28e2:	df 93       	push	r29
    28e4:	cf 93       	push	r28
    28e6:	cd b7       	in	r28, 0x3d	; 61
    28e8:	de b7       	in	r29, 0x3e	; 62
    28ea:	64 97       	sbiw	r28, 0x14	; 20
    28ec:	0f b6       	in	r0, 0x3f	; 63
    28ee:	f8 94       	cli
    28f0:	de bf       	out	0x3e, r29	; 62
    28f2:	0f be       	out	0x3f, r0	; 63
    28f4:	cd bf       	out	0x3d, r28	; 61
    28f6:	9a 87       	std	Y+10, r25	; 0x0a
    28f8:	89 87       	std	Y+9, r24	; 0x09
    28fa:	7c 87       	std	Y+12, r23	; 0x0c
    28fc:	6b 87       	std	Y+11, r22	; 0x0b
    28fe:	5e 87       	std	Y+14, r21	; 0x0e
    2900:	4d 87       	std	Y+13, r20	; 0x0d
    2902:	38 8b       	std	Y+16, r19	; 0x10
    2904:	2f 87       	std	Y+15, r18	; 0x0f
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    2906:	e9 85       	ldd	r30, Y+9	; 0x09
    2908:	fa 85       	ldd	r31, Y+10	; 0x0a
    290a:	80 81       	ld	r24, Z
    290c:	91 81       	ldd	r25, Z+1	; 0x01
    290e:	9a 83       	std	Y+2, r25	; 0x02
    2910:	89 83       	std	Y+1, r24	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2912:	e9 85       	ldd	r30, Y+9	; 0x09
    2914:	fa 85       	ldd	r31, Y+10	; 0x0a
    2916:	86 85       	ldd	r24, Z+14	; 0x0e
    2918:	88 2f       	mov	r24, r24
    291a:	90 e0       	ldi	r25, 0x00	; 0
    291c:	81 70       	andi	r24, 0x01	; 1
    291e:	90 70       	andi	r25, 0x00	; 0
    2920:	88 23       	and	r24, r24
    2922:	11 f1       	breq	.+68     	; 0x2968 <prvReadMessageFromBuffer+0x86>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    2924:	9e 01       	movw	r18, r28
    2926:	29 5f       	subi	r18, 0xF9	; 249
    2928:	3f 4f       	sbci	r19, 0xFF	; 255
    292a:	89 85       	ldd	r24, Y+9	; 0x09
    292c:	9a 85       	ldd	r25, Y+10	; 0x0a
    292e:	e9 81       	ldd	r30, Y+1	; 0x01
    2930:	fa 81       	ldd	r31, Y+2	; 0x02
    2932:	b9 01       	movw	r22, r18
    2934:	42 e0       	ldi	r20, 0x02	; 2
    2936:	50 e0       	ldi	r21, 0x00	; 0
    2938:	9f 01       	movw	r18, r30
    293a:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <prvReadBytesFromBuffer>
    293e:	9a 83       	std	Y+2, r25	; 0x02
    2940:	89 83       	std	Y+1, r24	; 0x01
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    2942:	8f 81       	ldd	r24, Y+7	; 0x07
    2944:	98 85       	ldd	r25, Y+8	; 0x08
    2946:	9c 83       	std	Y+4, r25	; 0x04
    2948:	8b 83       	std	Y+3, r24	; 0x03

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    294a:	8f 85       	ldd	r24, Y+15	; 0x0f
    294c:	98 89       	ldd	r25, Y+16	; 0x10
    294e:	02 97       	sbiw	r24, 0x02	; 2
    2950:	98 8b       	std	Y+16, r25	; 0x10
    2952:	8f 87       	std	Y+15, r24	; 0x0f

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    2954:	2b 81       	ldd	r18, Y+3	; 0x03
    2956:	3c 81       	ldd	r19, Y+4	; 0x04
    2958:	8d 85       	ldd	r24, Y+13	; 0x0d
    295a:	9e 85       	ldd	r25, Y+14	; 0x0e
    295c:	82 17       	cp	r24, r18
    295e:	93 07       	cpc	r25, r19
    2960:	38 f4       	brcc	.+14     	; 0x2970 <prvReadMessageFromBuffer+0x8e>
        {
            /* The user has provided insufficient space to read the message. */
            xNextMessageLength = 0;
    2962:	1c 82       	std	Y+4, r1	; 0x04
    2964:	1b 82       	std	Y+3, r1	; 0x03
    2966:	04 c0       	rjmp	.+8      	; 0x2970 <prvReadMessageFromBuffer+0x8e>
    }
    else
    {
        /* A stream of bytes is being received (as opposed to a discrete
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    2968:	8d 85       	ldd	r24, Y+13	; 0x0d
    296a:	9e 85       	ldd	r25, Y+14	; 0x0e
    296c:	9c 83       	std	Y+4, r25	; 0x04
    296e:	8b 83       	std	Y+3, r24	; 0x03
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    2970:	2b 81       	ldd	r18, Y+3	; 0x03
    2972:	3c 81       	ldd	r19, Y+4	; 0x04
    2974:	3c 8b       	std	Y+20, r19	; 0x14
    2976:	2b 8b       	std	Y+19, r18	; 0x13
    2978:	8f 85       	ldd	r24, Y+15	; 0x0f
    297a:	98 89       	ldd	r25, Y+16	; 0x10
    297c:	9a 8b       	std	Y+18, r25	; 0x12
    297e:	89 8b       	std	Y+17, r24	; 0x11
    2980:	29 89       	ldd	r18, Y+17	; 0x11
    2982:	3a 89       	ldd	r19, Y+18	; 0x12
    2984:	8b 89       	ldd	r24, Y+19	; 0x13
    2986:	9c 89       	ldd	r25, Y+20	; 0x14
    2988:	82 17       	cp	r24, r18
    298a:	93 07       	cpc	r25, r19
    298c:	20 f4       	brcc	.+8      	; 0x2996 <prvReadMessageFromBuffer+0xb4>
    298e:	2b 89       	ldd	r18, Y+19	; 0x13
    2990:	3c 89       	ldd	r19, Y+20	; 0x14
    2992:	3a 8b       	std	Y+18, r19	; 0x12
    2994:	29 8b       	std	Y+17, r18	; 0x11
    2996:	89 89       	ldd	r24, Y+17	; 0x11
    2998:	9a 89       	ldd	r25, Y+18	; 0x12
    299a:	9e 83       	std	Y+6, r25	; 0x06
    299c:	8d 83       	std	Y+5, r24	; 0x05

    if( xCount != ( size_t ) 0 )
    299e:	8d 81       	ldd	r24, Y+5	; 0x05
    29a0:	9e 81       	ldd	r25, Y+6	; 0x06
    29a2:	00 97       	sbiw	r24, 0x00	; 0
    29a4:	89 f0       	breq	.+34     	; 0x29c8 <prvReadMessageFromBuffer+0xe6>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    29a6:	4b 85       	ldd	r20, Y+11	; 0x0b
    29a8:	5c 85       	ldd	r21, Y+12	; 0x0c
    29aa:	89 85       	ldd	r24, Y+9	; 0x09
    29ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    29ae:	2d 81       	ldd	r18, Y+5	; 0x05
    29b0:	3e 81       	ldd	r19, Y+6	; 0x06
    29b2:	e9 81       	ldd	r30, Y+1	; 0x01
    29b4:	fa 81       	ldd	r31, Y+2	; 0x02
    29b6:	ba 01       	movw	r22, r20
    29b8:	a9 01       	movw	r20, r18
    29ba:	9f 01       	movw	r18, r30
    29bc:	0e 94 63 16 	call	0x2cc6	; 0x2cc6 <prvReadBytesFromBuffer>
    29c0:	e9 85       	ldd	r30, Y+9	; 0x09
    29c2:	fa 85       	ldd	r31, Y+10	; 0x0a
    29c4:	91 83       	std	Z+1, r25	; 0x01
    29c6:	80 83       	st	Z, r24
    }

    return xCount;
    29c8:	8d 81       	ldd	r24, Y+5	; 0x05
    29ca:	9e 81       	ldd	r25, Y+6	; 0x06
}
    29cc:	64 96       	adiw	r28, 0x14	; 20
    29ce:	0f b6       	in	r0, 0x3f	; 63
    29d0:	f8 94       	cli
    29d2:	de bf       	out	0x3e, r29	; 62
    29d4:	0f be       	out	0x3f, r0	; 63
    29d6:	cd bf       	out	0x3d, r28	; 61
    29d8:	cf 91       	pop	r28
    29da:	df 91       	pop	r29
    29dc:	08 95       	ret

000029de <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    29de:	df 93       	push	r29
    29e0:	cf 93       	push	r28
    29e2:	cd b7       	in	r28, 0x3d	; 61
    29e4:	de b7       	in	r29, 0x3e	; 62
    29e6:	27 97       	sbiw	r28, 0x07	; 7
    29e8:	0f b6       	in	r0, 0x3f	; 63
    29ea:	f8 94       	cli
    29ec:	de bf       	out	0x3e, r29	; 62
    29ee:	0f be       	out	0x3f, r0	; 63
    29f0:	cd bf       	out	0x3d, r28	; 61
    29f2:	9f 83       	std	Y+7, r25	; 0x07
    29f4:	8e 83       	std	Y+6, r24	; 0x06
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    29f6:	8e 81       	ldd	r24, Y+6	; 0x06
    29f8:	9f 81       	ldd	r25, Y+7	; 0x07
    29fa:	9d 83       	std	Y+5, r25	; 0x05
    29fc:	8c 83       	std	Y+4, r24	; 0x04
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    29fe:	ec 81       	ldd	r30, Y+4	; 0x04
    2a00:	fd 81       	ldd	r31, Y+5	; 0x05
    2a02:	80 81       	ld	r24, Z
    2a04:	91 81       	ldd	r25, Z+1	; 0x01
    2a06:	9a 83       	std	Y+2, r25	; 0x02
    2a08:	89 83       	std	Y+1, r24	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    2a0a:	ec 81       	ldd	r30, Y+4	; 0x04
    2a0c:	fd 81       	ldd	r31, Y+5	; 0x05
    2a0e:	22 81       	ldd	r18, Z+2	; 0x02
    2a10:	33 81       	ldd	r19, Z+3	; 0x03
    2a12:	89 81       	ldd	r24, Y+1	; 0x01
    2a14:	9a 81       	ldd	r25, Y+2	; 0x02
    2a16:	28 17       	cp	r18, r24
    2a18:	39 07       	cpc	r19, r25
    2a1a:	19 f4       	brne	.+6      	; 0x2a22 <xStreamBufferIsEmpty+0x44>
    {
        xReturn = pdTRUE;
    2a1c:	81 e0       	ldi	r24, 0x01	; 1
    2a1e:	8b 83       	std	Y+3, r24	; 0x03
    2a20:	01 c0       	rjmp	.+2      	; 0x2a24 <xStreamBufferIsEmpty+0x46>
    }
    else
    {
        xReturn = pdFALSE;
    2a22:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2a24:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2a26:	27 96       	adiw	r28, 0x07	; 7
    2a28:	0f b6       	in	r0, 0x3f	; 63
    2a2a:	f8 94       	cli
    2a2c:	de bf       	out	0x3e, r29	; 62
    2a2e:	0f be       	out	0x3f, r0	; 63
    2a30:	cd bf       	out	0x3d, r28	; 61
    2a32:	cf 91       	pop	r28
    2a34:	df 91       	pop	r29
    2a36:	08 95       	ret

00002a38 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    2a38:	df 93       	push	r29
    2a3a:	cf 93       	push	r28
    2a3c:	cd b7       	in	r28, 0x3d	; 61
    2a3e:	de b7       	in	r29, 0x3e	; 62
    2a40:	27 97       	sbiw	r28, 0x07	; 7
    2a42:	0f b6       	in	r0, 0x3f	; 63
    2a44:	f8 94       	cli
    2a46:	de bf       	out	0x3e, r29	; 62
    2a48:	0f be       	out	0x3f, r0	; 63
    2a4a:	cd bf       	out	0x3d, r28	; 61
    2a4c:	9f 83       	std	Y+7, r25	; 0x07
    2a4e:	8e 83       	std	Y+6, r24	; 0x06
    BaseType_t xReturn;
    size_t xBytesToStoreMessageLength;
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2a50:	8e 81       	ldd	r24, Y+6	; 0x06
    2a52:	9f 81       	ldd	r25, Y+7	; 0x07
    2a54:	9a 83       	std	Y+2, r25	; 0x02
    2a56:	89 83       	std	Y+1, r24	; 0x01

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2a58:	e9 81       	ldd	r30, Y+1	; 0x01
    2a5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a5c:	86 85       	ldd	r24, Z+14	; 0x0e
    2a5e:	88 2f       	mov	r24, r24
    2a60:	90 e0       	ldi	r25, 0x00	; 0
    2a62:	81 70       	andi	r24, 0x01	; 1
    2a64:	90 70       	andi	r25, 0x00	; 0
    2a66:	88 23       	and	r24, r24
    2a68:	29 f0       	breq	.+10     	; 0x2a74 <xStreamBufferIsFull+0x3c>
    {
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2a6a:	82 e0       	ldi	r24, 0x02	; 2
    2a6c:	90 e0       	ldi	r25, 0x00	; 0
    2a6e:	9c 83       	std	Y+4, r25	; 0x04
    2a70:	8b 83       	std	Y+3, r24	; 0x03
    2a72:	02 c0       	rjmp	.+4      	; 0x2a78 <xStreamBufferIsFull+0x40>
    }
    else
    {
        xBytesToStoreMessageLength = 0;
    2a74:	1c 82       	std	Y+4, r1	; 0x04
    2a76:	1b 82       	std	Y+3, r1	; 0x03
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    2a78:	8e 81       	ldd	r24, Y+6	; 0x06
    2a7a:	9f 81       	ldd	r25, Y+7	; 0x07
    2a7c:	0e 94 95 10 	call	0x212a	; 0x212a <xStreamBufferSpacesAvailable>
    2a80:	9c 01       	movw	r18, r24
    2a82:	8b 81       	ldd	r24, Y+3	; 0x03
    2a84:	9c 81       	ldd	r25, Y+4	; 0x04
    2a86:	82 17       	cp	r24, r18
    2a88:	93 07       	cpc	r25, r19
    2a8a:	18 f0       	brcs	.+6      	; 0x2a92 <xStreamBufferIsFull+0x5a>
    {
        xReturn = pdTRUE;
    2a8c:	81 e0       	ldi	r24, 0x01	; 1
    2a8e:	8d 83       	std	Y+5, r24	; 0x05
    2a90:	01 c0       	rjmp	.+2      	; 0x2a94 <xStreamBufferIsFull+0x5c>
    }
    else
    {
        xReturn = pdFALSE;
    2a92:	1d 82       	std	Y+5, r1	; 0x05
    }

    return xReturn;
    2a94:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2a96:	27 96       	adiw	r28, 0x07	; 7
    2a98:	0f b6       	in	r0, 0x3f	; 63
    2a9a:	f8 94       	cli
    2a9c:	de bf       	out	0x3e, r29	; 62
    2a9e:	0f be       	out	0x3f, r0	; 63
    2aa0:	cd bf       	out	0x3d, r28	; 61
    2aa2:	cf 91       	pop	r28
    2aa4:	df 91       	pop	r29
    2aa6:	08 95       	ret

00002aa8 <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    2aa8:	cf 92       	push	r12
    2aaa:	df 92       	push	r13
    2aac:	ef 92       	push	r14
    2aae:	ff 92       	push	r15
    2ab0:	0f 93       	push	r16
    2ab2:	df 93       	push	r29
    2ab4:	cf 93       	push	r28
    2ab6:	cd b7       	in	r28, 0x3d	; 61
    2ab8:	de b7       	in	r29, 0x3e	; 62
    2aba:	28 97       	sbiw	r28, 0x08	; 8
    2abc:	0f b6       	in	r0, 0x3f	; 63
    2abe:	f8 94       	cli
    2ac0:	de bf       	out	0x3e, r29	; 62
    2ac2:	0f be       	out	0x3f, r0	; 63
    2ac4:	cd bf       	out	0x3d, r28	; 61
    2ac6:	9e 83       	std	Y+6, r25	; 0x06
    2ac8:	8d 83       	std	Y+5, r24	; 0x05
    2aca:	78 87       	std	Y+8, r23	; 0x08
    2acc:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2ace:	8d 81       	ldd	r24, Y+5	; 0x05
    2ad0:	9e 81       	ldd	r25, Y+6	; 0x06
    2ad2:	9c 83       	std	Y+4, r25	; 0x04
    2ad4:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2ad6:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    2ada:	fc 81       	ldd	r31, Y+4	; 0x04
    2adc:	80 85       	ldd	r24, Z+8	; 0x08
    2ade:	91 85       	ldd	r25, Z+9	; 0x09
    2ae0:	00 97       	sbiw	r24, 0x00	; 0
    2ae2:	c1 f0       	breq	.+48     	; 0x2b14 <xStreamBufferSendCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    2ae4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae8:	80 85       	ldd	r24, Z+8	; 0x08
    2aea:	91 85       	ldd	r25, Z+9	; 0x09
    2aec:	ef 81       	ldd	r30, Y+7	; 0x07
    2aee:	f8 85       	ldd	r31, Y+8	; 0x08
    2af0:	60 e0       	ldi	r22, 0x00	; 0
    2af2:	20 e0       	ldi	r18, 0x00	; 0
    2af4:	30 e0       	ldi	r19, 0x00	; 0
    2af6:	40 e0       	ldi	r20, 0x00	; 0
    2af8:	50 e0       	ldi	r21, 0x00	; 0
    2afa:	00 e0       	ldi	r16, 0x00	; 0
    2afc:	ee 24       	eor	r14, r14
    2afe:	ff 24       	eor	r15, r15
    2b00:	6f 01       	movw	r12, r30
    2b02:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2b06:	eb 81       	ldd	r30, Y+3	; 0x03
    2b08:	fc 81       	ldd	r31, Y+4	; 0x04
    2b0a:	11 86       	std	Z+9, r1	; 0x09
    2b0c:	10 86       	std	Z+8, r1	; 0x08
            xReturn = pdTRUE;
    2b0e:	81 e0       	ldi	r24, 0x01	; 1
    2b10:	8a 83       	std	Y+2, r24	; 0x02
    2b12:	01 c0       	rjmp	.+2      	; 0x2b16 <xStreamBufferSendCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    2b14:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2b16:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2b18:	28 96       	adiw	r28, 0x08	; 8
    2b1a:	0f b6       	in	r0, 0x3f	; 63
    2b1c:	f8 94       	cli
    2b1e:	de bf       	out	0x3e, r29	; 62
    2b20:	0f be       	out	0x3f, r0	; 63
    2b22:	cd bf       	out	0x3d, r28	; 61
    2b24:	cf 91       	pop	r28
    2b26:	df 91       	pop	r29
    2b28:	0f 91       	pop	r16
    2b2a:	ff 90       	pop	r15
    2b2c:	ef 90       	pop	r14
    2b2e:	df 90       	pop	r13
    2b30:	cf 90       	pop	r12
    2b32:	08 95       	ret

00002b34 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    2b34:	cf 92       	push	r12
    2b36:	df 92       	push	r13
    2b38:	ef 92       	push	r14
    2b3a:	ff 92       	push	r15
    2b3c:	0f 93       	push	r16
    2b3e:	df 93       	push	r29
    2b40:	cf 93       	push	r28
    2b42:	cd b7       	in	r28, 0x3d	; 61
    2b44:	de b7       	in	r29, 0x3e	; 62
    2b46:	28 97       	sbiw	r28, 0x08	; 8
    2b48:	0f b6       	in	r0, 0x3f	; 63
    2b4a:	f8 94       	cli
    2b4c:	de bf       	out	0x3e, r29	; 62
    2b4e:	0f be       	out	0x3f, r0	; 63
    2b50:	cd bf       	out	0x3d, r28	; 61
    2b52:	9e 83       	std	Y+6, r25	; 0x06
    2b54:	8d 83       	std	Y+5, r24	; 0x05
    2b56:	78 87       	std	Y+8, r23	; 0x08
    2b58:	6f 83       	std	Y+7, r22	; 0x07
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2b5a:	8d 81       	ldd	r24, Y+5	; 0x05
    2b5c:	9e 81       	ldd	r25, Y+6	; 0x06
    2b5e:	9c 83       	std	Y+4, r25	; 0x04
    2b60:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2b62:	19 82       	std	Y+1, r1	; 0x01
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    2b64:	eb 81       	ldd	r30, Y+3	; 0x03
    2b66:	fc 81       	ldd	r31, Y+4	; 0x04
    2b68:	82 85       	ldd	r24, Z+10	; 0x0a
    2b6a:	93 85       	ldd	r25, Z+11	; 0x0b
    2b6c:	00 97       	sbiw	r24, 0x00	; 0
    2b6e:	c1 f0       	breq	.+48     	; 0x2ba0 <xStreamBufferReceiveCompletedFromISR+0x6c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    2b70:	eb 81       	ldd	r30, Y+3	; 0x03
    2b72:	fc 81       	ldd	r31, Y+4	; 0x04
    2b74:	82 85       	ldd	r24, Z+10	; 0x0a
    2b76:	93 85       	ldd	r25, Z+11	; 0x0b
    2b78:	ef 81       	ldd	r30, Y+7	; 0x07
    2b7a:	f8 85       	ldd	r31, Y+8	; 0x08
    2b7c:	60 e0       	ldi	r22, 0x00	; 0
    2b7e:	20 e0       	ldi	r18, 0x00	; 0
    2b80:	30 e0       	ldi	r19, 0x00	; 0
    2b82:	40 e0       	ldi	r20, 0x00	; 0
    2b84:	50 e0       	ldi	r21, 0x00	; 0
    2b86:	00 e0       	ldi	r16, 0x00	; 0
    2b88:	ee 24       	eor	r14, r14
    2b8a:	ff 24       	eor	r15, r15
    2b8c:	6f 01       	movw	r12, r30
    2b8e:	0e 94 b4 25 	call	0x4b68	; 0x4b68 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    2b92:	eb 81       	ldd	r30, Y+3	; 0x03
    2b94:	fc 81       	ldd	r31, Y+4	; 0x04
    2b96:	13 86       	std	Z+11, r1	; 0x0b
    2b98:	12 86       	std	Z+10, r1	; 0x0a
            xReturn = pdTRUE;
    2b9a:	81 e0       	ldi	r24, 0x01	; 1
    2b9c:	8a 83       	std	Y+2, r24	; 0x02
    2b9e:	01 c0       	rjmp	.+2      	; 0x2ba2 <xStreamBufferReceiveCompletedFromISR+0x6e>
        }
        else
        {
            xReturn = pdFALSE;
    2ba0:	1a 82       	std	Y+2, r1	; 0x02
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2ba2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2ba4:	28 96       	adiw	r28, 0x08	; 8
    2ba6:	0f b6       	in	r0, 0x3f	; 63
    2ba8:	f8 94       	cli
    2baa:	de bf       	out	0x3e, r29	; 62
    2bac:	0f be       	out	0x3f, r0	; 63
    2bae:	cd bf       	out	0x3d, r28	; 61
    2bb0:	cf 91       	pop	r28
    2bb2:	df 91       	pop	r29
    2bb4:	0f 91       	pop	r16
    2bb6:	ff 90       	pop	r15
    2bb8:	ef 90       	pop	r14
    2bba:	df 90       	pop	r13
    2bbc:	cf 90       	pop	r12
    2bbe:	08 95       	ret

00002bc0 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    2bc0:	df 93       	push	r29
    2bc2:	cf 93       	push	r28
    2bc4:	cd b7       	in	r28, 0x3d	; 61
    2bc6:	de b7       	in	r29, 0x3e	; 62
    2bc8:	2e 97       	sbiw	r28, 0x0e	; 14
    2bca:	0f b6       	in	r0, 0x3f	; 63
    2bcc:	f8 94       	cli
    2bce:	de bf       	out	0x3e, r29	; 62
    2bd0:	0f be       	out	0x3f, r0	; 63
    2bd2:	cd bf       	out	0x3d, r28	; 61
    2bd4:	9c 83       	std	Y+4, r25	; 0x04
    2bd6:	8b 83       	std	Y+3, r24	; 0x03
    2bd8:	7e 83       	std	Y+6, r23	; 0x06
    2bda:	6d 83       	std	Y+5, r22	; 0x05
    2bdc:	58 87       	std	Y+8, r21	; 0x08
    2bde:	4f 83       	std	Y+7, r20	; 0x07
    2be0:	3a 87       	std	Y+10, r19	; 0x0a
    2be2:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    2be4:	eb 81       	ldd	r30, Y+3	; 0x03
    2be6:	fc 81       	ldd	r31, Y+4	; 0x04
    2be8:	24 81       	ldd	r18, Z+4	; 0x04
    2bea:	35 81       	ldd	r19, Z+5	; 0x05
    2bec:	89 85       	ldd	r24, Y+9	; 0x09
    2bee:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bf0:	a9 01       	movw	r20, r18
    2bf2:	48 1b       	sub	r20, r24
    2bf4:	59 0b       	sbc	r21, r25
    2bf6:	ca 01       	movw	r24, r20
    2bf8:	2f 81       	ldd	r18, Y+7	; 0x07
    2bfa:	38 85       	ldd	r19, Y+8	; 0x08
    2bfc:	3e 87       	std	Y+14, r19	; 0x0e
    2bfe:	2d 87       	std	Y+13, r18	; 0x0d
    2c00:	9c 87       	std	Y+12, r25	; 0x0c
    2c02:	8b 87       	std	Y+11, r24	; 0x0b
    2c04:	4b 85       	ldd	r20, Y+11	; 0x0b
    2c06:	5c 85       	ldd	r21, Y+12	; 0x0c
    2c08:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c0a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c0c:	84 17       	cp	r24, r20
    2c0e:	95 07       	cpc	r25, r21
    2c10:	20 f4       	brcc	.+8      	; 0x2c1a <prvWriteBytesToBuffer+0x5a>
    2c12:	2d 85       	ldd	r18, Y+13	; 0x0d
    2c14:	3e 85       	ldd	r19, Y+14	; 0x0e
    2c16:	3c 87       	std	Y+12, r19	; 0x0c
    2c18:	2b 87       	std	Y+11, r18	; 0x0b
    2c1a:	4b 85       	ldd	r20, Y+11	; 0x0b
    2c1c:	5c 85       	ldd	r21, Y+12	; 0x0c
    2c1e:	5a 83       	std	Y+2, r21	; 0x02
    2c20:	49 83       	std	Y+1, r20	; 0x01

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2c22:	eb 81       	ldd	r30, Y+3	; 0x03
    2c24:	fc 81       	ldd	r31, Y+4	; 0x04
    2c26:	24 85       	ldd	r18, Z+12	; 0x0c
    2c28:	35 85       	ldd	r19, Z+13	; 0x0d
    2c2a:	89 85       	ldd	r24, Y+9	; 0x09
    2c2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c2e:	82 0f       	add	r24, r18
    2c30:	93 1f       	adc	r25, r19
    2c32:	2d 81       	ldd	r18, Y+5	; 0x05
    2c34:	3e 81       	ldd	r19, Y+6	; 0x06
    2c36:	49 81       	ldd	r20, Y+1	; 0x01
    2c38:	5a 81       	ldd	r21, Y+2	; 0x02
    2c3a:	b9 01       	movw	r22, r18
    2c3c:	0e 94 88 37 	call	0x6f10	; 0x6f10 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    2c40:	2f 81       	ldd	r18, Y+7	; 0x07
    2c42:	38 85       	ldd	r19, Y+8	; 0x08
    2c44:	89 81       	ldd	r24, Y+1	; 0x01
    2c46:	9a 81       	ldd	r25, Y+2	; 0x02
    2c48:	82 17       	cp	r24, r18
    2c4a:	93 07       	cpc	r25, r19
    2c4c:	b0 f4       	brcc	.+44     	; 0x2c7a <prvWriteBytesToBuffer+0xba>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2c4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2c50:	fc 81       	ldd	r31, Y+4	; 0x04
    2c52:	64 85       	ldd	r22, Z+12	; 0x0c
    2c54:	75 85       	ldd	r23, Z+13	; 0x0d
    2c56:	2d 81       	ldd	r18, Y+5	; 0x05
    2c58:	3e 81       	ldd	r19, Y+6	; 0x06
    2c5a:	89 81       	ldd	r24, Y+1	; 0x01
    2c5c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c5e:	a9 01       	movw	r20, r18
    2c60:	48 0f       	add	r20, r24
    2c62:	59 1f       	adc	r21, r25
    2c64:	2f 81       	ldd	r18, Y+7	; 0x07
    2c66:	38 85       	ldd	r19, Y+8	; 0x08
    2c68:	89 81       	ldd	r24, Y+1	; 0x01
    2c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c6c:	28 1b       	sub	r18, r24
    2c6e:	39 0b       	sbc	r19, r25
    2c70:	cb 01       	movw	r24, r22
    2c72:	ba 01       	movw	r22, r20
    2c74:	a9 01       	movw	r20, r18
    2c76:	0e 94 88 37 	call	0x6f10	; 0x6f10 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    2c7a:	29 85       	ldd	r18, Y+9	; 0x09
    2c7c:	3a 85       	ldd	r19, Y+10	; 0x0a
    2c7e:	8f 81       	ldd	r24, Y+7	; 0x07
    2c80:	98 85       	ldd	r25, Y+8	; 0x08
    2c82:	82 0f       	add	r24, r18
    2c84:	93 1f       	adc	r25, r19
    2c86:	9a 87       	std	Y+10, r25	; 0x0a
    2c88:	89 87       	std	Y+9, r24	; 0x09

    if( xHead >= pxStreamBuffer->xLength )
    2c8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2c8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2c8e:	24 81       	ldd	r18, Z+4	; 0x04
    2c90:	35 81       	ldd	r19, Z+5	; 0x05
    2c92:	89 85       	ldd	r24, Y+9	; 0x09
    2c94:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c96:	82 17       	cp	r24, r18
    2c98:	93 07       	cpc	r25, r19
    2c9a:	50 f0       	brcs	.+20     	; 0x2cb0 <prvWriteBytesToBuffer+0xf0>
    {
        xHead -= pxStreamBuffer->xLength;
    2c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    2ca0:	24 81       	ldd	r18, Z+4	; 0x04
    2ca2:	35 81       	ldd	r19, Z+5	; 0x05
    2ca4:	89 85       	ldd	r24, Y+9	; 0x09
    2ca6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ca8:	82 1b       	sub	r24, r18
    2caa:	93 0b       	sbc	r25, r19
    2cac:	9a 87       	std	Y+10, r25	; 0x0a
    2cae:	89 87       	std	Y+9, r24	; 0x09
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
    2cb0:	89 85       	ldd	r24, Y+9	; 0x09
    2cb2:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2cb4:	2e 96       	adiw	r28, 0x0e	; 14
    2cb6:	0f b6       	in	r0, 0x3f	; 63
    2cb8:	f8 94       	cli
    2cba:	de bf       	out	0x3e, r29	; 62
    2cbc:	0f be       	out	0x3f, r0	; 63
    2cbe:	cd bf       	out	0x3d, r28	; 61
    2cc0:	cf 91       	pop	r28
    2cc2:	df 91       	pop	r29
    2cc4:	08 95       	ret

00002cc6 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    2cc6:	df 93       	push	r29
    2cc8:	cf 93       	push	r28
    2cca:	cd b7       	in	r28, 0x3d	; 61
    2ccc:	de b7       	in	r29, 0x3e	; 62
    2cce:	2e 97       	sbiw	r28, 0x0e	; 14
    2cd0:	0f b6       	in	r0, 0x3f	; 63
    2cd2:	f8 94       	cli
    2cd4:	de bf       	out	0x3e, r29	; 62
    2cd6:	0f be       	out	0x3f, r0	; 63
    2cd8:	cd bf       	out	0x3d, r28	; 61
    2cda:	9c 83       	std	Y+4, r25	; 0x04
    2cdc:	8b 83       	std	Y+3, r24	; 0x03
    2cde:	7e 83       	std	Y+6, r23	; 0x06
    2ce0:	6d 83       	std	Y+5, r22	; 0x05
    2ce2:	58 87       	std	Y+8, r21	; 0x08
    2ce4:	4f 83       	std	Y+7, r20	; 0x07
    2ce6:	3a 87       	std	Y+10, r19	; 0x0a
    2ce8:	29 87       	std	Y+9, r18	; 0x09
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    2cea:	eb 81       	ldd	r30, Y+3	; 0x03
    2cec:	fc 81       	ldd	r31, Y+4	; 0x04
    2cee:	24 81       	ldd	r18, Z+4	; 0x04
    2cf0:	35 81       	ldd	r19, Z+5	; 0x05
    2cf2:	89 85       	ldd	r24, Y+9	; 0x09
    2cf4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2cf6:	a9 01       	movw	r20, r18
    2cf8:	48 1b       	sub	r20, r24
    2cfa:	59 0b       	sbc	r21, r25
    2cfc:	ca 01       	movw	r24, r20
    2cfe:	2f 81       	ldd	r18, Y+7	; 0x07
    2d00:	38 85       	ldd	r19, Y+8	; 0x08
    2d02:	3e 87       	std	Y+14, r19	; 0x0e
    2d04:	2d 87       	std	Y+13, r18	; 0x0d
    2d06:	9c 87       	std	Y+12, r25	; 0x0c
    2d08:	8b 87       	std	Y+11, r24	; 0x0b
    2d0a:	4b 85       	ldd	r20, Y+11	; 0x0b
    2d0c:	5c 85       	ldd	r21, Y+12	; 0x0c
    2d0e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d10:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d12:	84 17       	cp	r24, r20
    2d14:	95 07       	cpc	r25, r21
    2d16:	20 f4       	brcc	.+8      	; 0x2d20 <prvReadBytesFromBuffer+0x5a>
    2d18:	2d 85       	ldd	r18, Y+13	; 0x0d
    2d1a:	3e 85       	ldd	r19, Y+14	; 0x0e
    2d1c:	3c 87       	std	Y+12, r19	; 0x0c
    2d1e:	2b 87       	std	Y+11, r18	; 0x0b
    2d20:	4b 85       	ldd	r20, Y+11	; 0x0b
    2d22:	5c 85       	ldd	r21, Y+12	; 0x0c
    2d24:	5a 83       	std	Y+2, r21	; 0x02
    2d26:	49 83       	std	Y+1, r20	; 0x01

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2d28:	eb 81       	ldd	r30, Y+3	; 0x03
    2d2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2d2c:	24 85       	ldd	r18, Z+12	; 0x0c
    2d2e:	35 85       	ldd	r19, Z+13	; 0x0d
    2d30:	89 85       	ldd	r24, Y+9	; 0x09
    2d32:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d34:	a9 01       	movw	r20, r18
    2d36:	48 0f       	add	r20, r24
    2d38:	59 1f       	adc	r21, r25
    2d3a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d3c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d3e:	29 81       	ldd	r18, Y+1	; 0x01
    2d40:	3a 81       	ldd	r19, Y+2	; 0x02
    2d42:	ba 01       	movw	r22, r20
    2d44:	a9 01       	movw	r20, r18
    2d46:	0e 94 88 37 	call	0x6f10	; 0x6f10 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    2d4a:	2f 81       	ldd	r18, Y+7	; 0x07
    2d4c:	38 85       	ldd	r19, Y+8	; 0x08
    2d4e:	89 81       	ldd	r24, Y+1	; 0x01
    2d50:	9a 81       	ldd	r25, Y+2	; 0x02
    2d52:	82 17       	cp	r24, r18
    2d54:	93 07       	cpc	r25, r19
    2d56:	b0 f4       	brcc	.+44     	; 0x2d84 <prvReadBytesFromBuffer+0xbe>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2d58:	2d 81       	ldd	r18, Y+5	; 0x05
    2d5a:	3e 81       	ldd	r19, Y+6	; 0x06
    2d5c:	89 81       	ldd	r24, Y+1	; 0x01
    2d5e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d60:	b9 01       	movw	r22, r18
    2d62:	68 0f       	add	r22, r24
    2d64:	79 1f       	adc	r23, r25
    2d66:	eb 81       	ldd	r30, Y+3	; 0x03
    2d68:	fc 81       	ldd	r31, Y+4	; 0x04
    2d6a:	44 85       	ldd	r20, Z+12	; 0x0c
    2d6c:	55 85       	ldd	r21, Z+13	; 0x0d
    2d6e:	2f 81       	ldd	r18, Y+7	; 0x07
    2d70:	38 85       	ldd	r19, Y+8	; 0x08
    2d72:	89 81       	ldd	r24, Y+1	; 0x01
    2d74:	9a 81       	ldd	r25, Y+2	; 0x02
    2d76:	28 1b       	sub	r18, r24
    2d78:	39 0b       	sbc	r19, r25
    2d7a:	cb 01       	movw	r24, r22
    2d7c:	ba 01       	movw	r22, r20
    2d7e:	a9 01       	movw	r20, r18
    2d80:	0e 94 88 37 	call	0x6f10	; 0x6f10 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    2d84:	29 85       	ldd	r18, Y+9	; 0x09
    2d86:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d88:	8f 81       	ldd	r24, Y+7	; 0x07
    2d8a:	98 85       	ldd	r25, Y+8	; 0x08
    2d8c:	82 0f       	add	r24, r18
    2d8e:	93 1f       	adc	r25, r19
    2d90:	9a 87       	std	Y+10, r25	; 0x0a
    2d92:	89 87       	std	Y+9, r24	; 0x09

    if( xTail >= pxStreamBuffer->xLength )
    2d94:	eb 81       	ldd	r30, Y+3	; 0x03
    2d96:	fc 81       	ldd	r31, Y+4	; 0x04
    2d98:	24 81       	ldd	r18, Z+4	; 0x04
    2d9a:	35 81       	ldd	r19, Z+5	; 0x05
    2d9c:	89 85       	ldd	r24, Y+9	; 0x09
    2d9e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2da0:	82 17       	cp	r24, r18
    2da2:	93 07       	cpc	r25, r19
    2da4:	50 f0       	brcs	.+20     	; 0x2dba <prvReadBytesFromBuffer+0xf4>
    {
        xTail -= pxStreamBuffer->xLength;
    2da6:	eb 81       	ldd	r30, Y+3	; 0x03
    2da8:	fc 81       	ldd	r31, Y+4	; 0x04
    2daa:	24 81       	ldd	r18, Z+4	; 0x04
    2dac:	35 81       	ldd	r19, Z+5	; 0x05
    2dae:	89 85       	ldd	r24, Y+9	; 0x09
    2db0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2db2:	82 1b       	sub	r24, r18
    2db4:	93 0b       	sbc	r25, r19
    2db6:	9a 87       	std	Y+10, r25	; 0x0a
    2db8:	89 87       	std	Y+9, r24	; 0x09
    }

    return xTail;
    2dba:	89 85       	ldd	r24, Y+9	; 0x09
    2dbc:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2dbe:	2e 96       	adiw	r28, 0x0e	; 14
    2dc0:	0f b6       	in	r0, 0x3f	; 63
    2dc2:	f8 94       	cli
    2dc4:	de bf       	out	0x3e, r29	; 62
    2dc6:	0f be       	out	0x3f, r0	; 63
    2dc8:	cd bf       	out	0x3d, r28	; 61
    2dca:	cf 91       	pop	r28
    2dcc:	df 91       	pop	r29
    2dce:	08 95       	ret

00002dd0 <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    2dd0:	df 93       	push	r29
    2dd2:	cf 93       	push	r28
    2dd4:	00 d0       	rcall	.+0      	; 0x2dd6 <prvBytesInBuffer+0x6>
    2dd6:	00 d0       	rcall	.+0      	; 0x2dd8 <prvBytesInBuffer+0x8>
    2dd8:	cd b7       	in	r28, 0x3d	; 61
    2dda:	de b7       	in	r29, 0x3e	; 62
    2ddc:	9c 83       	std	Y+4, r25	; 0x04
    2dde:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2de0:	eb 81       	ldd	r30, Y+3	; 0x03
    2de2:	fc 81       	ldd	r31, Y+4	; 0x04
    2de4:	24 81       	ldd	r18, Z+4	; 0x04
    2de6:	35 81       	ldd	r19, Z+5	; 0x05
    2de8:	eb 81       	ldd	r30, Y+3	; 0x03
    2dea:	fc 81       	ldd	r31, Y+4	; 0x04
    2dec:	82 81       	ldd	r24, Z+2	; 0x02
    2dee:	93 81       	ldd	r25, Z+3	; 0x03
    2df0:	82 0f       	add	r24, r18
    2df2:	93 1f       	adc	r25, r19
    2df4:	9a 83       	std	Y+2, r25	; 0x02
    2df6:	89 83       	std	Y+1, r24	; 0x01
    xCount -= pxStreamBuffer->xTail;
    2df8:	eb 81       	ldd	r30, Y+3	; 0x03
    2dfa:	fc 81       	ldd	r31, Y+4	; 0x04
    2dfc:	20 81       	ld	r18, Z
    2dfe:	31 81       	ldd	r19, Z+1	; 0x01
    2e00:	89 81       	ldd	r24, Y+1	; 0x01
    2e02:	9a 81       	ldd	r25, Y+2	; 0x02
    2e04:	82 1b       	sub	r24, r18
    2e06:	93 0b       	sbc	r25, r19
    2e08:	9a 83       	std	Y+2, r25	; 0x02
    2e0a:	89 83       	std	Y+1, r24	; 0x01

    if( xCount >= pxStreamBuffer->xLength )
    2e0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e10:	24 81       	ldd	r18, Z+4	; 0x04
    2e12:	35 81       	ldd	r19, Z+5	; 0x05
    2e14:	89 81       	ldd	r24, Y+1	; 0x01
    2e16:	9a 81       	ldd	r25, Y+2	; 0x02
    2e18:	82 17       	cp	r24, r18
    2e1a:	93 07       	cpc	r25, r19
    2e1c:	50 f0       	brcs	.+20     	; 0x2e32 <prvBytesInBuffer+0x62>
    {
        xCount -= pxStreamBuffer->xLength;
    2e1e:	eb 81       	ldd	r30, Y+3	; 0x03
    2e20:	fc 81       	ldd	r31, Y+4	; 0x04
    2e22:	24 81       	ldd	r18, Z+4	; 0x04
    2e24:	35 81       	ldd	r19, Z+5	; 0x05
    2e26:	89 81       	ldd	r24, Y+1	; 0x01
    2e28:	9a 81       	ldd	r25, Y+2	; 0x02
    2e2a:	82 1b       	sub	r24, r18
    2e2c:	93 0b       	sbc	r25, r19
    2e2e:	9a 83       	std	Y+2, r25	; 0x02
    2e30:	89 83       	std	Y+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
    2e32:	89 81       	ldd	r24, Y+1	; 0x01
    2e34:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2e36:	0f 90       	pop	r0
    2e38:	0f 90       	pop	r0
    2e3a:	0f 90       	pop	r0
    2e3c:	0f 90       	pop	r0
    2e3e:	cf 91       	pop	r28
    2e40:	df 91       	pop	r29
    2e42:	08 95       	ret

00002e44 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
                                          uint8_t * const pucBuffer,
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags )
{
    2e44:	0f 93       	push	r16
    2e46:	df 93       	push	r29
    2e48:	cf 93       	push	r28
    2e4a:	cd b7       	in	r28, 0x3d	; 61
    2e4c:	de b7       	in	r29, 0x3e	; 62
    2e4e:	29 97       	sbiw	r28, 0x09	; 9
    2e50:	0f b6       	in	r0, 0x3f	; 63
    2e52:	f8 94       	cli
    2e54:	de bf       	out	0x3e, r29	; 62
    2e56:	0f be       	out	0x3f, r0	; 63
    2e58:	cd bf       	out	0x3d, r28	; 61
    2e5a:	9a 83       	std	Y+2, r25	; 0x02
    2e5c:	89 83       	std	Y+1, r24	; 0x01
    2e5e:	7c 83       	std	Y+4, r23	; 0x04
    2e60:	6b 83       	std	Y+3, r22	; 0x03
    2e62:	5e 83       	std	Y+6, r21	; 0x06
    2e64:	4d 83       	std	Y+5, r20	; 0x05
    2e66:	38 87       	std	Y+8, r19	; 0x08
    2e68:	2f 83       	std	Y+7, r18	; 0x07
    2e6a:	09 87       	std	Y+9, r16	; 0x09
            const BaseType_t xWriteValue = 0x55;
            configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
        } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2e6c:	89 81       	ldd	r24, Y+1	; 0x01
    2e6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e70:	60 e0       	ldi	r22, 0x00	; 0
    2e72:	70 e0       	ldi	r23, 0x00	; 0
    2e74:	4f e0       	ldi	r20, 0x0F	; 15
    2e76:	50 e0       	ldi	r21, 0x00	; 0
    2e78:	0e 94 91 37 	call	0x6f22	; 0x6f22 <memset>
    pxStreamBuffer->pucBuffer = pucBuffer;
    2e7c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e7e:	fa 81       	ldd	r31, Y+2	; 0x02
    2e80:	8b 81       	ldd	r24, Y+3	; 0x03
    2e82:	9c 81       	ldd	r25, Y+4	; 0x04
    2e84:	95 87       	std	Z+13, r25	; 0x0d
    2e86:	84 87       	std	Z+12, r24	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    2e88:	e9 81       	ldd	r30, Y+1	; 0x01
    2e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e8c:	8d 81       	ldd	r24, Y+5	; 0x05
    2e8e:	9e 81       	ldd	r25, Y+6	; 0x06
    2e90:	95 83       	std	Z+5, r25	; 0x05
    2e92:	84 83       	std	Z+4, r24	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2e94:	e9 81       	ldd	r30, Y+1	; 0x01
    2e96:	fa 81       	ldd	r31, Y+2	; 0x02
    2e98:	8f 81       	ldd	r24, Y+7	; 0x07
    2e9a:	98 85       	ldd	r25, Y+8	; 0x08
    2e9c:	97 83       	std	Z+7, r25	; 0x07
    2e9e:	86 83       	std	Z+6, r24	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    2ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea4:	89 85       	ldd	r24, Y+9	; 0x09
    2ea6:	86 87       	std	Z+14, r24	; 0x0e
}
    2ea8:	29 96       	adiw	r28, 0x09	; 9
    2eaa:	0f b6       	in	r0, 0x3f	; 63
    2eac:	f8 94       	cli
    2eae:	de bf       	out	0x3e, r29	; 62
    2eb0:	0f be       	out	0x3f, r0	; 63
    2eb2:	cd bf       	out	0x3d, r28	; 61
    2eb4:	cf 91       	pop	r28
    2eb6:	df 91       	pop	r29
    2eb8:	0f 91       	pop	r16
    2eba:	08 95       	ret

00002ebc <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    2ebc:	8f 92       	push	r8
    2ebe:	9f 92       	push	r9
    2ec0:	af 92       	push	r10
    2ec2:	bf 92       	push	r11
    2ec4:	cf 92       	push	r12
    2ec6:	df 92       	push	r13
    2ec8:	ef 92       	push	r14
    2eca:	ff 92       	push	r15
    2ecc:	0f 93       	push	r16
    2ece:	1f 93       	push	r17
    2ed0:	df 93       	push	r29
    2ed2:	cf 93       	push	r28
    2ed4:	cd b7       	in	r28, 0x3d	; 61
    2ed6:	de b7       	in	r29, 0x3e	; 62
    2ed8:	60 97       	sbiw	r28, 0x10	; 16
    2eda:	0f b6       	in	r0, 0x3f	; 63
    2edc:	f8 94       	cli
    2ede:	de bf       	out	0x3e, r29	; 62
    2ee0:	0f be       	out	0x3f, r0	; 63
    2ee2:	cd bf       	out	0x3d, r28	; 61
    2ee4:	9f 83       	std	Y+7, r25	; 0x07
    2ee6:	8e 83       	std	Y+6, r24	; 0x06
    2ee8:	79 87       	std	Y+9, r23	; 0x09
    2eea:	68 87       	std	Y+8, r22	; 0x08
    2eec:	5b 87       	std	Y+11, r21	; 0x0b
    2eee:	4a 87       	std	Y+10, r20	; 0x0a
    2ef0:	3d 87       	std	Y+13, r19	; 0x0d
    2ef2:	2c 87       	std	Y+12, r18	; 0x0c
    2ef4:	0e 87       	std	Y+14, r16	; 0x0e
    2ef6:	f8 8a       	std	Y+16, r15	; 0x10
    2ef8:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2efa:	8a 85       	ldd	r24, Y+10	; 0x0a
    2efc:	9b 85       	ldd	r25, Y+11	; 0x0b
    2efe:	0e 94 d7 03 	call	0x7ae	; 0x7ae <pvPortMalloc>
    2f02:	9a 83       	std	Y+2, r25	; 0x02
    2f04:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    2f06:	89 81       	ldd	r24, Y+1	; 0x01
    2f08:	9a 81       	ldd	r25, Y+2	; 0x02
    2f0a:	00 97       	sbiw	r24, 0x00	; 0
    2f0c:	b1 f0       	breq	.+44     	; 0x2f3a <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2f0e:	86 e2       	ldi	r24, 0x26	; 38
    2f10:	90 e0       	ldi	r25, 0x00	; 0
    2f12:	0e 94 d7 03 	call	0x7ae	; 0x7ae <pvPortMalloc>
    2f16:	9d 83       	std	Y+5, r25	; 0x05
    2f18:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    2f1a:	8c 81       	ldd	r24, Y+4	; 0x04
    2f1c:	9d 81       	ldd	r25, Y+5	; 0x05
    2f1e:	00 97       	sbiw	r24, 0x00	; 0
    2f20:	39 f0       	breq	.+14     	; 0x2f30 <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    2f22:	ec 81       	ldd	r30, Y+4	; 0x04
    2f24:	fd 81       	ldd	r31, Y+5	; 0x05
    2f26:	89 81       	ldd	r24, Y+1	; 0x01
    2f28:	9a 81       	ldd	r25, Y+2	; 0x02
    2f2a:	90 8f       	std	Z+24, r25	; 0x18
    2f2c:	87 8b       	std	Z+23, r24	; 0x17
    2f2e:	07 c0       	rjmp	.+14     	; 0x2f3e <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    2f30:	89 81       	ldd	r24, Y+1	; 0x01
    2f32:	9a 81       	ldd	r25, Y+2	; 0x02
    2f34:	0e 94 31 04 	call	0x862	; 0x862 <vPortFree>
    2f38:	02 c0       	rjmp	.+4      	; 0x2f3e <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    2f3a:	1d 82       	std	Y+5, r1	; 0x05
    2f3c:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    2f3e:	8c 81       	ldd	r24, Y+4	; 0x04
    2f40:	9d 81       	ldd	r25, Y+5	; 0x05
    2f42:	00 97       	sbiw	r24, 0x00	; 0
    2f44:	e9 f0       	breq	.+58     	; 0x2f80 <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2f46:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f48:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f4a:	9c 01       	movw	r18, r24
    2f4c:	40 e0       	ldi	r20, 0x00	; 0
    2f4e:	50 e0       	ldi	r21, 0x00	; 0
    2f50:	8e 81       	ldd	r24, Y+6	; 0x06
    2f52:	9f 81       	ldd	r25, Y+7	; 0x07
    2f54:	68 85       	ldd	r22, Y+8	; 0x08
    2f56:	79 85       	ldd	r23, Y+9	; 0x09
    2f58:	ec 85       	ldd	r30, Y+12	; 0x0c
    2f5a:	fd 85       	ldd	r31, Y+13	; 0x0d
    2f5c:	af 85       	ldd	r26, Y+15	; 0x0f
    2f5e:	b8 89       	ldd	r27, Y+16	; 0x10
    2f60:	ac 80       	ldd	r10, Y+4	; 0x04
    2f62:	bd 80       	ldd	r11, Y+5	; 0x05
    2f64:	8f 01       	movw	r16, r30
    2f66:	ee 84       	ldd	r14, Y+14	; 0x0e
    2f68:	6d 01       	movw	r12, r26
    2f6a:	88 24       	eor	r8, r8
    2f6c:	99 24       	eor	r9, r9
    2f6e:	0e 94 d6 17 	call	0x2fac	; 0x2fac <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    2f72:	8c 81       	ldd	r24, Y+4	; 0x04
    2f74:	9d 81       	ldd	r25, Y+5	; 0x05
    2f76:	0e 94 9b 18 	call	0x3136	; 0x3136 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    2f7a:	81 e0       	ldi	r24, 0x01	; 1
    2f7c:	8b 83       	std	Y+3, r24	; 0x03
    2f7e:	02 c0       	rjmp	.+4      	; 0x2f84 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2f80:	8f ef       	ldi	r24, 0xFF	; 255
    2f82:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    2f84:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2f86:	60 96       	adiw	r28, 0x10	; 16
    2f88:	0f b6       	in	r0, 0x3f	; 63
    2f8a:	f8 94       	cli
    2f8c:	de bf       	out	0x3e, r29	; 62
    2f8e:	0f be       	out	0x3f, r0	; 63
    2f90:	cd bf       	out	0x3d, r28	; 61
    2f92:	cf 91       	pop	r28
    2f94:	df 91       	pop	r29
    2f96:	1f 91       	pop	r17
    2f98:	0f 91       	pop	r16
    2f9a:	ff 90       	pop	r15
    2f9c:	ef 90       	pop	r14
    2f9e:	df 90       	pop	r13
    2fa0:	cf 90       	pop	r12
    2fa2:	bf 90       	pop	r11
    2fa4:	af 90       	pop	r10
    2fa6:	9f 90       	pop	r9
    2fa8:	8f 90       	pop	r8
    2faa:	08 95       	ret

00002fac <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    2fac:	8f 92       	push	r8
    2fae:	9f 92       	push	r9
    2fb0:	af 92       	push	r10
    2fb2:	bf 92       	push	r11
    2fb4:	cf 92       	push	r12
    2fb6:	df 92       	push	r13
    2fb8:	ef 92       	push	r14
    2fba:	0f 93       	push	r16
    2fbc:	1f 93       	push	r17
    2fbe:	df 93       	push	r29
    2fc0:	cf 93       	push	r28
    2fc2:	cd b7       	in	r28, 0x3d	; 61
    2fc4:	de b7       	in	r29, 0x3e	; 62
    2fc6:	64 97       	sbiw	r28, 0x14	; 20
    2fc8:	0f b6       	in	r0, 0x3f	; 63
    2fca:	f8 94       	cli
    2fcc:	de bf       	out	0x3e, r29	; 62
    2fce:	0f be       	out	0x3f, r0	; 63
    2fd0:	cd bf       	out	0x3d, r28	; 61
    2fd2:	9d 83       	std	Y+5, r25	; 0x05
    2fd4:	8c 83       	std	Y+4, r24	; 0x04
    2fd6:	7f 83       	std	Y+7, r23	; 0x07
    2fd8:	6e 83       	std	Y+6, r22	; 0x06
    2fda:	28 87       	std	Y+8, r18	; 0x08
    2fdc:	39 87       	std	Y+9, r19	; 0x09
    2fde:	4a 87       	std	Y+10, r20	; 0x0a
    2fe0:	5b 87       	std	Y+11, r21	; 0x0b
    2fe2:	1d 87       	std	Y+13, r17	; 0x0d
    2fe4:	0c 87       	std	Y+12, r16	; 0x0c
    2fe6:	ee 86       	std	Y+14, r14	; 0x0e
    2fe8:	d8 8a       	std	Y+16, r13	; 0x10
    2fea:	cf 86       	std	Y+15, r12	; 0x0f
    2fec:	ba 8a       	std	Y+18, r11	; 0x12
    2fee:	a9 8a       	std	Y+17, r10	; 0x11
    2ff0:	9c 8a       	std	Y+20, r9	; 0x14
    2ff2:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    2ff4:	e9 89       	ldd	r30, Y+17	; 0x11
    2ff6:	fa 89       	ldd	r31, Y+18	; 0x12
    2ff8:	27 89       	ldd	r18, Z+23	; 0x17
    2ffa:	30 8d       	ldd	r19, Z+24	; 0x18
    2ffc:	88 85       	ldd	r24, Y+8	; 0x08
    2ffe:	99 85       	ldd	r25, Y+9	; 0x09
    3000:	01 97       	sbiw	r24, 0x01	; 1
    3002:	82 0f       	add	r24, r18
    3004:	93 1f       	adc	r25, r19
    3006:	9b 83       	std	Y+3, r25	; 0x03
    3008:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    300a:	8e 81       	ldd	r24, Y+6	; 0x06
    300c:	9f 81       	ldd	r25, Y+7	; 0x07
    300e:	00 97       	sbiw	r24, 0x00	; 0
    3010:	51 f1       	breq	.+84     	; 0x3066 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3012:	19 82       	std	Y+1, r1	; 0x01
    3014:	21 c0       	rjmp	.+66     	; 0x3058 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3016:	89 81       	ldd	r24, Y+1	; 0x01
    3018:	48 2f       	mov	r20, r24
    301a:	50 e0       	ldi	r21, 0x00	; 0
    301c:	89 81       	ldd	r24, Y+1	; 0x01
    301e:	28 2f       	mov	r18, r24
    3020:	30 e0       	ldi	r19, 0x00	; 0
    3022:	8e 81       	ldd	r24, Y+6	; 0x06
    3024:	9f 81       	ldd	r25, Y+7	; 0x07
    3026:	fc 01       	movw	r30, r24
    3028:	e2 0f       	add	r30, r18
    302a:	f3 1f       	adc	r31, r19
    302c:	20 81       	ld	r18, Z
    302e:	89 89       	ldd	r24, Y+17	; 0x11
    3030:	9a 89       	ldd	r25, Y+18	; 0x12
    3032:	84 0f       	add	r24, r20
    3034:	95 1f       	adc	r25, r21
    3036:	fc 01       	movw	r30, r24
    3038:	79 96       	adiw	r30, 0x19	; 25
    303a:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    303c:	89 81       	ldd	r24, Y+1	; 0x01
    303e:	28 2f       	mov	r18, r24
    3040:	30 e0       	ldi	r19, 0x00	; 0
    3042:	8e 81       	ldd	r24, Y+6	; 0x06
    3044:	9f 81       	ldd	r25, Y+7	; 0x07
    3046:	fc 01       	movw	r30, r24
    3048:	e2 0f       	add	r30, r18
    304a:	f3 1f       	adc	r31, r19
    304c:	80 81       	ld	r24, Z
    304e:	88 23       	and	r24, r24
    3050:	31 f0       	breq	.+12     	; 0x305e <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3052:	89 81       	ldd	r24, Y+1	; 0x01
    3054:	8f 5f       	subi	r24, 0xFF	; 255
    3056:	89 83       	std	Y+1, r24	; 0x01
    3058:	89 81       	ldd	r24, Y+1	; 0x01
    305a:	88 30       	cpi	r24, 0x08	; 8
    305c:	e0 f2       	brcs	.-72     	; 0x3016 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    305e:	e9 89       	ldd	r30, Y+17	; 0x11
    3060:	fa 89       	ldd	r31, Y+18	; 0x12
    3062:	10 a2       	std	Z+32, r1	; 0x20
    3064:	03 c0       	rjmp	.+6      	; 0x306c <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3066:	e9 89       	ldd	r30, Y+17	; 0x11
    3068:	fa 89       	ldd	r31, Y+18	; 0x12
    306a:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    306c:	8e 85       	ldd	r24, Y+14	; 0x0e
    306e:	84 30       	cpi	r24, 0x04	; 4
    3070:	10 f0       	brcs	.+4      	; 0x3076 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    3072:	83 e0       	ldi	r24, 0x03	; 3
    3074:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    3076:	e9 89       	ldd	r30, Y+17	; 0x11
    3078:	fa 89       	ldd	r31, Y+18	; 0x12
    307a:	8e 85       	ldd	r24, Y+14	; 0x0e
    307c:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    307e:	89 89       	ldd	r24, Y+17	; 0x11
    3080:	9a 89       	ldd	r25, Y+18	; 0x12
    3082:	02 96       	adiw	r24, 0x02	; 2
    3084:	0e 94 81 04 	call	0x902	; 0x902 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3088:	89 89       	ldd	r24, Y+17	; 0x11
    308a:	9a 89       	ldd	r25, Y+18	; 0x12
    308c:	0c 96       	adiw	r24, 0x0c	; 12
    308e:	0e 94 81 04 	call	0x902	; 0x902 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    3092:	e9 89       	ldd	r30, Y+17	; 0x11
    3094:	fa 89       	ldd	r31, Y+18	; 0x12
    3096:	89 89       	ldd	r24, Y+17	; 0x11
    3098:	9a 89       	ldd	r25, Y+18	; 0x12
    309a:	91 87       	std	Z+9, r25	; 0x09
    309c:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    309e:	8e 85       	ldd	r24, Y+14	; 0x0e
    30a0:	28 2f       	mov	r18, r24
    30a2:	30 e0       	ldi	r19, 0x00	; 0
    30a4:	84 e0       	ldi	r24, 0x04	; 4
    30a6:	90 e0       	ldi	r25, 0x00	; 0
    30a8:	82 1b       	sub	r24, r18
    30aa:	93 0b       	sbc	r25, r19
    30ac:	e9 89       	ldd	r30, Y+17	; 0x11
    30ae:	fa 89       	ldd	r31, Y+18	; 0x12
    30b0:	95 87       	std	Z+13, r25	; 0x0d
    30b2:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    30b4:	e9 89       	ldd	r30, Y+17	; 0x11
    30b6:	fa 89       	ldd	r31, Y+18	; 0x12
    30b8:	89 89       	ldd	r24, Y+17	; 0x11
    30ba:	9a 89       	ldd	r25, Y+18	; 0x12
    30bc:	93 8b       	std	Z+19, r25	; 0x13
    30be:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    30c0:	89 89       	ldd	r24, Y+17	; 0x11
    30c2:	9a 89       	ldd	r25, Y+18	; 0x12
    30c4:	81 96       	adiw	r24, 0x21	; 33
    30c6:	60 e0       	ldi	r22, 0x00	; 0
    30c8:	70 e0       	ldi	r23, 0x00	; 0
    30ca:	44 e0       	ldi	r20, 0x04	; 4
    30cc:	50 e0       	ldi	r21, 0x00	; 0
    30ce:	0e 94 91 37 	call	0x6f22	; 0x6f22 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    30d2:	89 89       	ldd	r24, Y+17	; 0x11
    30d4:	9a 89       	ldd	r25, Y+18	; 0x12
    30d6:	85 96       	adiw	r24, 0x25	; 37
    30d8:	60 e0       	ldi	r22, 0x00	; 0
    30da:	70 e0       	ldi	r23, 0x00	; 0
    30dc:	41 e0       	ldi	r20, 0x01	; 1
    30de:	50 e0       	ldi	r21, 0x00	; 0
    30e0:	0e 94 91 37 	call	0x6f22	; 0x6f22 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    30e4:	8a 81       	ldd	r24, Y+2	; 0x02
    30e6:	9b 81       	ldd	r25, Y+3	; 0x03
    30e8:	2c 81       	ldd	r18, Y+4	; 0x04
    30ea:	3d 81       	ldd	r19, Y+5	; 0x05
    30ec:	4c 85       	ldd	r20, Y+12	; 0x0c
    30ee:	5d 85       	ldd	r21, Y+13	; 0x0d
    30f0:	b9 01       	movw	r22, r18
    30f2:	0e 94 8d 05 	call	0xb1a	; 0xb1a <pxPortInitialiseStack>
    30f6:	e9 89       	ldd	r30, Y+17	; 0x11
    30f8:	fa 89       	ldd	r31, Y+18	; 0x12
    30fa:	91 83       	std	Z+1, r25	; 0x01
    30fc:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    30fe:	8f 85       	ldd	r24, Y+15	; 0x0f
    3100:	98 89       	ldd	r25, Y+16	; 0x10
    3102:	00 97       	sbiw	r24, 0x00	; 0
    3104:	31 f0       	breq	.+12     	; 0x3112 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3106:	ef 85       	ldd	r30, Y+15	; 0x0f
    3108:	f8 89       	ldd	r31, Y+16	; 0x10
    310a:	89 89       	ldd	r24, Y+17	; 0x11
    310c:	9a 89       	ldd	r25, Y+18	; 0x12
    310e:	91 83       	std	Z+1, r25	; 0x01
    3110:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3112:	64 96       	adiw	r28, 0x14	; 20
    3114:	0f b6       	in	r0, 0x3f	; 63
    3116:	f8 94       	cli
    3118:	de bf       	out	0x3e, r29	; 62
    311a:	0f be       	out	0x3f, r0	; 63
    311c:	cd bf       	out	0x3d, r28	; 61
    311e:	cf 91       	pop	r28
    3120:	df 91       	pop	r29
    3122:	1f 91       	pop	r17
    3124:	0f 91       	pop	r16
    3126:	ef 90       	pop	r14
    3128:	df 90       	pop	r13
    312a:	cf 90       	pop	r12
    312c:	bf 90       	pop	r11
    312e:	af 90       	pop	r10
    3130:	9f 90       	pop	r9
    3132:	8f 90       	pop	r8
    3134:	08 95       	ret

00003136 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    3136:	df 93       	push	r29
    3138:	cf 93       	push	r28
    313a:	00 d0       	rcall	.+0      	; 0x313c <prvAddNewTaskToReadyList+0x6>
    313c:	00 d0       	rcall	.+0      	; 0x313e <prvAddNewTaskToReadyList+0x8>
    313e:	00 d0       	rcall	.+0      	; 0x3140 <prvAddNewTaskToReadyList+0xa>
    3140:	cd b7       	in	r28, 0x3d	; 61
    3142:	de b7       	in	r29, 0x3e	; 62
    3144:	9c 83       	std	Y+4, r25	; 0x04
    3146:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    3148:	0f b6       	in	r0, 0x3f	; 63
    314a:	f8 94       	cli
    314c:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    314e:	80 91 63 06 	lds	r24, 0x0663
    3152:	8f 5f       	subi	r24, 0xFF	; 255
    3154:	80 93 63 06 	sts	0x0663, r24

        if( pxCurrentTCB == NULL )
    3158:	80 91 60 06 	lds	r24, 0x0660
    315c:	90 91 61 06 	lds	r25, 0x0661
    3160:	00 97       	sbiw	r24, 0x00	; 0
    3162:	69 f4       	brne	.+26     	; 0x317e <prvAddNewTaskToReadyList+0x48>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    3164:	8b 81       	ldd	r24, Y+3	; 0x03
    3166:	9c 81       	ldd	r25, Y+4	; 0x04
    3168:	90 93 61 06 	sts	0x0661, r25
    316c:	80 93 60 06 	sts	0x0660, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3170:	80 91 63 06 	lds	r24, 0x0663
    3174:	81 30       	cpi	r24, 0x01	; 1
    3176:	b9 f4       	brne	.+46     	; 0x31a6 <prvAddNewTaskToReadyList+0x70>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    3178:	0e 94 74 21 	call	0x42e8	; 0x42e8 <prvInitialiseTaskLists>
    317c:	14 c0       	rjmp	.+40     	; 0x31a6 <prvAddNewTaskToReadyList+0x70>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    317e:	80 91 67 06 	lds	r24, 0x0667
    3182:	88 23       	and	r24, r24
    3184:	81 f4       	brne	.+32     	; 0x31a6 <prvAddNewTaskToReadyList+0x70>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    3186:	e0 91 60 06 	lds	r30, 0x0660
    318a:	f0 91 61 06 	lds	r31, 0x0661
    318e:	96 89       	ldd	r25, Z+22	; 0x16
    3190:	eb 81       	ldd	r30, Y+3	; 0x03
    3192:	fc 81       	ldd	r31, Y+4	; 0x04
    3194:	86 89       	ldd	r24, Z+22	; 0x16
    3196:	89 17       	cp	r24, r25
    3198:	30 f0       	brcs	.+12     	; 0x31a6 <prvAddNewTaskToReadyList+0x70>
                {
                    pxCurrentTCB = pxNewTCB;
    319a:	8b 81       	ldd	r24, Y+3	; 0x03
    319c:	9c 81       	ldd	r25, Y+4	; 0x04
    319e:	90 93 61 06 	sts	0x0661, r25
    31a2:	80 93 60 06 	sts	0x0660, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    31a6:	80 91 6c 06 	lds	r24, 0x066C
    31aa:	8f 5f       	subi	r24, 0xFF	; 255
    31ac:	80 93 6c 06 	sts	0x066C, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    31b0:	eb 81       	ldd	r30, Y+3	; 0x03
    31b2:	fc 81       	ldd	r31, Y+4	; 0x04
    31b4:	96 89       	ldd	r25, Z+22	; 0x16
    31b6:	80 91 66 06 	lds	r24, 0x0666
    31ba:	89 17       	cp	r24, r25
    31bc:	28 f4       	brcc	.+10     	; 0x31c8 <prvAddNewTaskToReadyList+0x92>
    31be:	eb 81       	ldd	r30, Y+3	; 0x03
    31c0:	fc 81       	ldd	r31, Y+4	; 0x04
    31c2:	86 89       	ldd	r24, Z+22	; 0x16
    31c4:	80 93 66 06 	sts	0x0666, r24
    31c8:	eb 81       	ldd	r30, Y+3	; 0x03
    31ca:	fc 81       	ldd	r31, Y+4	; 0x04
    31cc:	86 89       	ldd	r24, Z+22	; 0x16
    31ce:	28 2f       	mov	r18, r24
    31d0:	30 e0       	ldi	r19, 0x00	; 0
    31d2:	c9 01       	movw	r24, r18
    31d4:	88 0f       	add	r24, r24
    31d6:	99 1f       	adc	r25, r25
    31d8:	88 0f       	add	r24, r24
    31da:	99 1f       	adc	r25, r25
    31dc:	88 0f       	add	r24, r24
    31de:	99 1f       	adc	r25, r25
    31e0:	82 0f       	add	r24, r18
    31e2:	93 1f       	adc	r25, r19
    31e4:	fc 01       	movw	r30, r24
    31e6:	ee 58       	subi	r30, 0x8E	; 142
    31e8:	f9 4f       	sbci	r31, 0xF9	; 249
    31ea:	81 81       	ldd	r24, Z+1	; 0x01
    31ec:	92 81       	ldd	r25, Z+2	; 0x02
    31ee:	9a 83       	std	Y+2, r25	; 0x02
    31f0:	89 83       	std	Y+1, r24	; 0x01
    31f2:	eb 81       	ldd	r30, Y+3	; 0x03
    31f4:	fc 81       	ldd	r31, Y+4	; 0x04
    31f6:	89 81       	ldd	r24, Y+1	; 0x01
    31f8:	9a 81       	ldd	r25, Y+2	; 0x02
    31fa:	95 83       	std	Z+5, r25	; 0x05
    31fc:	84 83       	std	Z+4, r24	; 0x04
    31fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3200:	fa 81       	ldd	r31, Y+2	; 0x02
    3202:	84 81       	ldd	r24, Z+4	; 0x04
    3204:	95 81       	ldd	r25, Z+5	; 0x05
    3206:	eb 81       	ldd	r30, Y+3	; 0x03
    3208:	fc 81       	ldd	r31, Y+4	; 0x04
    320a:	97 83       	std	Z+7, r25	; 0x07
    320c:	86 83       	std	Z+6, r24	; 0x06
    320e:	e9 81       	ldd	r30, Y+1	; 0x01
    3210:	fa 81       	ldd	r31, Y+2	; 0x02
    3212:	04 80       	ldd	r0, Z+4	; 0x04
    3214:	f5 81       	ldd	r31, Z+5	; 0x05
    3216:	e0 2d       	mov	r30, r0
    3218:	8b 81       	ldd	r24, Y+3	; 0x03
    321a:	9c 81       	ldd	r25, Y+4	; 0x04
    321c:	02 96       	adiw	r24, 0x02	; 2
    321e:	93 83       	std	Z+3, r25	; 0x03
    3220:	82 83       	std	Z+2, r24	; 0x02
    3222:	8b 81       	ldd	r24, Y+3	; 0x03
    3224:	9c 81       	ldd	r25, Y+4	; 0x04
    3226:	02 96       	adiw	r24, 0x02	; 2
    3228:	e9 81       	ldd	r30, Y+1	; 0x01
    322a:	fa 81       	ldd	r31, Y+2	; 0x02
    322c:	95 83       	std	Z+5, r25	; 0x05
    322e:	84 83       	std	Z+4, r24	; 0x04
    3230:	eb 81       	ldd	r30, Y+3	; 0x03
    3232:	fc 81       	ldd	r31, Y+4	; 0x04
    3234:	86 89       	ldd	r24, Z+22	; 0x16
    3236:	28 2f       	mov	r18, r24
    3238:	30 e0       	ldi	r19, 0x00	; 0
    323a:	c9 01       	movw	r24, r18
    323c:	88 0f       	add	r24, r24
    323e:	99 1f       	adc	r25, r25
    3240:	88 0f       	add	r24, r24
    3242:	99 1f       	adc	r25, r25
    3244:	88 0f       	add	r24, r24
    3246:	99 1f       	adc	r25, r25
    3248:	82 0f       	add	r24, r18
    324a:	93 1f       	adc	r25, r19
    324c:	8e 58       	subi	r24, 0x8E	; 142
    324e:	99 4f       	sbci	r25, 0xF9	; 249
    3250:	eb 81       	ldd	r30, Y+3	; 0x03
    3252:	fc 81       	ldd	r31, Y+4	; 0x04
    3254:	93 87       	std	Z+11, r25	; 0x0b
    3256:	82 87       	std	Z+10, r24	; 0x0a
    3258:	eb 81       	ldd	r30, Y+3	; 0x03
    325a:	fc 81       	ldd	r31, Y+4	; 0x04
    325c:	86 89       	ldd	r24, Z+22	; 0x16
    325e:	28 2f       	mov	r18, r24
    3260:	30 e0       	ldi	r19, 0x00	; 0
    3262:	c9 01       	movw	r24, r18
    3264:	88 0f       	add	r24, r24
    3266:	99 1f       	adc	r25, r25
    3268:	88 0f       	add	r24, r24
    326a:	99 1f       	adc	r25, r25
    326c:	88 0f       	add	r24, r24
    326e:	99 1f       	adc	r25, r25
    3270:	82 0f       	add	r24, r18
    3272:	93 1f       	adc	r25, r19
    3274:	fc 01       	movw	r30, r24
    3276:	ee 58       	subi	r30, 0x8E	; 142
    3278:	f9 4f       	sbci	r31, 0xF9	; 249
    327a:	80 81       	ld	r24, Z
    327c:	8f 5f       	subi	r24, 0xFF	; 255
    327e:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    3280:	0f 90       	pop	r0
    3282:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    3284:	80 91 67 06 	lds	r24, 0x0667
    3288:	88 23       	and	r24, r24
    328a:	21 f0       	breq	.+8      	; 0x3294 <prvAddNewTaskToReadyList+0x15e>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    328c:	80 91 60 06 	lds	r24, 0x0660
    3290:	90 91 61 06 	lds	r25, 0x0661
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3294:	26 96       	adiw	r28, 0x06	; 6
    3296:	0f b6       	in	r0, 0x3f	; 63
    3298:	f8 94       	cli
    329a:	de bf       	out	0x3e, r29	; 62
    329c:	0f be       	out	0x3f, r0	; 63
    329e:	cd bf       	out	0x3d, r28	; 61
    32a0:	cf 91       	pop	r28
    32a2:	df 91       	pop	r29
    32a4:	08 95       	ret

000032a6 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    32a6:	df 93       	push	r29
    32a8:	cf 93       	push	r28
    32aa:	00 d0       	rcall	.+0      	; 0x32ac <vTaskDelete+0x6>
    32ac:	00 d0       	rcall	.+0      	; 0x32ae <vTaskDelete+0x8>
    32ae:	00 d0       	rcall	.+0      	; 0x32b0 <vTaskDelete+0xa>
    32b0:	cd b7       	in	r28, 0x3d	; 61
    32b2:	de b7       	in	r29, 0x3e	; 62
    32b4:	9c 83       	std	Y+4, r25	; 0x04
    32b6:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    32b8:	0f b6       	in	r0, 0x3f	; 63
    32ba:	f8 94       	cli
    32bc:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    32be:	8b 81       	ldd	r24, Y+3	; 0x03
    32c0:	9c 81       	ldd	r25, Y+4	; 0x04
    32c2:	00 97       	sbiw	r24, 0x00	; 0
    32c4:	39 f4       	brne	.+14     	; 0x32d4 <vTaskDelete+0x2e>
    32c6:	80 91 60 06 	lds	r24, 0x0660
    32ca:	90 91 61 06 	lds	r25, 0x0661
    32ce:	9e 83       	std	Y+6, r25	; 0x06
    32d0:	8d 83       	std	Y+5, r24	; 0x05
    32d2:	04 c0       	rjmp	.+8      	; 0x32dc <vTaskDelete+0x36>
    32d4:	8b 81       	ldd	r24, Y+3	; 0x03
    32d6:	9c 81       	ldd	r25, Y+4	; 0x04
    32d8:	9e 83       	std	Y+6, r25	; 0x06
    32da:	8d 83       	std	Y+5, r24	; 0x05
    32dc:	8d 81       	ldd	r24, Y+5	; 0x05
    32de:	9e 81       	ldd	r25, Y+6	; 0x06
    32e0:	9a 83       	std	Y+2, r25	; 0x02
    32e2:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    32e4:	89 81       	ldd	r24, Y+1	; 0x01
    32e6:	9a 81       	ldd	r25, Y+2	; 0x02
    32e8:	02 96       	adiw	r24, 0x02	; 2
    32ea:	0e 94 41 05 	call	0xa82	; 0xa82 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    32ee:	e9 81       	ldd	r30, Y+1	; 0x01
    32f0:	fa 81       	ldd	r31, Y+2	; 0x02
    32f2:	84 89       	ldd	r24, Z+20	; 0x14
    32f4:	95 89       	ldd	r25, Z+21	; 0x15
    32f6:	00 97       	sbiw	r24, 0x00	; 0
    32f8:	29 f0       	breq	.+10     	; 0x3304 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    32fa:	89 81       	ldd	r24, Y+1	; 0x01
    32fc:	9a 81       	ldd	r25, Y+2	; 0x02
    32fe:	0c 96       	adiw	r24, 0x0c	; 12
    3300:	0e 94 41 05 	call	0xa82	; 0xa82 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    3304:	80 91 6c 06 	lds	r24, 0x066C
    3308:	8f 5f       	subi	r24, 0xFF	; 255
    330a:	80 93 6c 06 	sts	0x066C, r24

            if( pxTCB == pxCurrentTCB )
    330e:	20 91 60 06 	lds	r18, 0x0660
    3312:	30 91 61 06 	lds	r19, 0x0661
    3316:	89 81       	ldd	r24, Y+1	; 0x01
    3318:	9a 81       	ldd	r25, Y+2	; 0x02
    331a:	82 17       	cp	r24, r18
    331c:	93 07       	cpc	r25, r19
    331e:	81 f4       	brne	.+32     	; 0x3340 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3320:	89 81       	ldd	r24, Y+1	; 0x01
    3322:	9a 81       	ldd	r25, Y+2	; 0x02
    3324:	9c 01       	movw	r18, r24
    3326:	2e 5f       	subi	r18, 0xFE	; 254
    3328:	3f 4f       	sbci	r19, 0xFF	; 255
    332a:	85 eb       	ldi	r24, 0xB5	; 181
    332c:	96 e0       	ldi	r25, 0x06	; 6
    332e:	b9 01       	movw	r22, r18
    3330:	0e 94 91 04 	call	0x922	; 0x922 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3334:	80 91 62 06 	lds	r24, 0x0662
    3338:	8f 5f       	subi	r24, 0xFF	; 255
    333a:	80 93 62 06 	sts	0x0662, r24
    333e:	07 c0       	rjmp	.+14     	; 0x334e <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3340:	80 91 63 06 	lds	r24, 0x0663
    3344:	81 50       	subi	r24, 0x01	; 1
    3346:	80 93 63 06 	sts	0x0663, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    334a:	0e 94 f6 21 	call	0x43ec	; 0x43ec <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    334e:	0f 90       	pop	r0
    3350:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3352:	20 91 60 06 	lds	r18, 0x0660
    3356:	30 91 61 06 	lds	r19, 0x0661
    335a:	89 81       	ldd	r24, Y+1	; 0x01
    335c:	9a 81       	ldd	r25, Y+2	; 0x02
    335e:	82 17       	cp	r24, r18
    3360:	93 07       	cpc	r25, r19
    3362:	21 f0       	breq	.+8      	; 0x336c <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    3364:	89 81       	ldd	r24, Y+1	; 0x01
    3366:	9a 81       	ldd	r25, Y+2	; 0x02
    3368:	0e 94 e0 21 	call	0x43c0	; 0x43c0 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    336c:	80 91 67 06 	lds	r24, 0x0667
    3370:	88 23       	and	r24, r24
    3372:	59 f0       	breq	.+22     	; 0x338a <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    3374:	20 91 60 06 	lds	r18, 0x0660
    3378:	30 91 61 06 	lds	r19, 0x0661
    337c:	89 81       	ldd	r24, Y+1	; 0x01
    337e:	9a 81       	ldd	r25, Y+2	; 0x02
    3380:	82 17       	cp	r24, r18
    3382:	93 07       	cpc	r25, r19
    3384:	11 f4       	brne	.+4      	; 0x338a <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    3386:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    338a:	26 96       	adiw	r28, 0x06	; 6
    338c:	0f b6       	in	r0, 0x3f	; 63
    338e:	f8 94       	cli
    3390:	de bf       	out	0x3e, r29	; 62
    3392:	0f be       	out	0x3f, r0	; 63
    3394:	cd bf       	out	0x3d, r28	; 61
    3396:	cf 91       	pop	r28
    3398:	df 91       	pop	r29
    339a:	08 95       	ret

0000339c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    339c:	df 93       	push	r29
    339e:	cf 93       	push	r28
    33a0:	00 d0       	rcall	.+0      	; 0x33a2 <vTaskDelay+0x6>
    33a2:	0f 92       	push	r0
    33a4:	cd b7       	in	r28, 0x3d	; 61
    33a6:	de b7       	in	r29, 0x3e	; 62
    33a8:	9b 83       	std	Y+3, r25	; 0x03
    33aa:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    33ac:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    33ae:	8a 81       	ldd	r24, Y+2	; 0x02
    33b0:	9b 81       	ldd	r25, Y+3	; 0x03
    33b2:	00 97       	sbiw	r24, 0x00	; 0
    33b4:	51 f0       	breq	.+20     	; 0x33ca <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    33b6:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    33ba:	8a 81       	ldd	r24, Y+2	; 0x02
    33bc:	9b 81       	ldd	r25, Y+3	; 0x03
    33be:	60 e0       	ldi	r22, 0x00	; 0
    33c0:	0e 94 ce 29 	call	0x539c	; 0x539c <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    33c4:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    33c8:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    33ca:	89 81       	ldd	r24, Y+1	; 0x01
    33cc:	88 23       	and	r24, r24
    33ce:	11 f4       	brne	.+4      	; 0x33d4 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    33d0:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    33d4:	0f 90       	pop	r0
    33d6:	0f 90       	pop	r0
    33d8:	0f 90       	pop	r0
    33da:	cf 91       	pop	r28
    33dc:	df 91       	pop	r29
    33de:	08 95       	ret

000033e0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    33e0:	ef 92       	push	r14
    33e2:	ff 92       	push	r15
    33e4:	0f 93       	push	r16
    33e6:	df 93       	push	r29
    33e8:	cf 93       	push	r28
    33ea:	00 d0       	rcall	.+0      	; 0x33ec <vTaskStartScheduler+0xc>
    33ec:	cd b7       	in	r28, 0x3d	; 61
    33ee:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    33f0:	88 e6       	ldi	r24, 0x68	; 104
    33f2:	91 e2       	ldi	r25, 0x21	; 33
    33f4:	27 e6       	ldi	r18, 0x67	; 103
    33f6:	30 e0       	ldi	r19, 0x00	; 0
    33f8:	ef e6       	ldi	r30, 0x6F	; 111
    33fa:	f6 e0       	ldi	r31, 0x06	; 6
    33fc:	b9 01       	movw	r22, r18
    33fe:	45 e5       	ldi	r20, 0x55	; 85
    3400:	50 e0       	ldi	r21, 0x00	; 0
    3402:	20 e0       	ldi	r18, 0x00	; 0
    3404:	30 e0       	ldi	r19, 0x00	; 0
    3406:	00 e0       	ldi	r16, 0x00	; 0
    3408:	7f 01       	movw	r14, r30
    340a:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <xTaskCreate>
    340e:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    3410:	89 81       	ldd	r24, Y+1	; 0x01
    3412:	81 30       	cpi	r24, 0x01	; 1
    3414:	81 f4       	brne	.+32     	; 0x3436 <vTaskStartScheduler+0x56>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3416:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    3418:	8f ef       	ldi	r24, 0xFF	; 255
    341a:	9f ef       	ldi	r25, 0xFF	; 255
    341c:	90 93 6e 06 	sts	0x066E, r25
    3420:	80 93 6d 06 	sts	0x066D, r24
        xSchedulerRunning = pdTRUE;
    3424:	81 e0       	ldi	r24, 0x01	; 1
    3426:	80 93 67 06 	sts	0x0667, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    342a:	10 92 65 06 	sts	0x0665, r1
    342e:	10 92 64 06 	sts	0x0664, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    3432:	0e 94 10 07 	call	0xe20	; 0xe20 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3436:	80 91 6c 00 	lds	r24, 0x006C
}
    343a:	0f 90       	pop	r0
    343c:	0f 90       	pop	r0
    343e:	cf 91       	pop	r28
    3440:	df 91       	pop	r29
    3442:	0f 91       	pop	r16
    3444:	ff 90       	pop	r15
    3446:	ef 90       	pop	r14
    3448:	08 95       	ret

0000344a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    344a:	df 93       	push	r29
    344c:	cf 93       	push	r28
    344e:	cd b7       	in	r28, 0x3d	; 61
    3450:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3452:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3454:	10 92 67 06 	sts	0x0667, r1
    vPortEndScheduler();
    3458:	0e 94 5f 07 	call	0xebe	; 0xebe <vPortEndScheduler>
}
    345c:	cf 91       	pop	r28
    345e:	df 91       	pop	r29
    3460:	08 95       	ret

00003462 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3462:	df 93       	push	r29
    3464:	cf 93       	push	r28
    3466:	cd b7       	in	r28, 0x3d	; 61
    3468:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    346a:	80 91 71 06 	lds	r24, 0x0671
    346e:	8f 5f       	subi	r24, 0xFF	; 255
    3470:	80 93 71 06 	sts	0x0671, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3474:	cf 91       	pop	r28
    3476:	df 91       	pop	r29
    3478:	08 95       	ret

0000347a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    347a:	df 93       	push	r29
    347c:	cf 93       	push	r28
    347e:	cd b7       	in	r28, 0x3d	; 61
    3480:	de b7       	in	r29, 0x3e	; 62
    3482:	2c 97       	sbiw	r28, 0x0c	; 12
    3484:	0f b6       	in	r0, 0x3f	; 63
    3486:	f8 94       	cli
    3488:	de bf       	out	0x3e, r29	; 62
    348a:	0f be       	out	0x3f, r0	; 63
    348c:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    348e:	1b 86       	std	Y+11, r1	; 0x0b
    3490:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    3492:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3494:	0f b6       	in	r0, 0x3f	; 63
    3496:	f8 94       	cli
    3498:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    349a:	80 91 71 06 	lds	r24, 0x0671
    349e:	81 50       	subi	r24, 0x01	; 1
    34a0:	80 93 71 06 	sts	0x0671, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    34a4:	80 91 71 06 	lds	r24, 0x0671
    34a8:	88 23       	and	r24, r24
    34aa:	09 f0       	breq	.+2      	; 0x34ae <xTaskResumeAll+0x34>
    34ac:	24 c1       	rjmp	.+584    	; 0x36f6 <xTaskResumeAll+0x27c>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    34ae:	80 91 63 06 	lds	r24, 0x0663
    34b2:	88 23       	and	r24, r24
    34b4:	09 f4       	brne	.+2      	; 0x34b8 <xTaskResumeAll+0x3e>
    34b6:	1f c1       	rjmp	.+574    	; 0x36f6 <xTaskResumeAll+0x27c>
    34b8:	f3 c0       	rjmp	.+486    	; 0x36a0 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    34ba:	e0 91 b1 06 	lds	r30, 0x06B1
    34be:	f0 91 b2 06 	lds	r31, 0x06B2
    34c2:	86 81       	ldd	r24, Z+6	; 0x06
    34c4:	97 81       	ldd	r25, Z+7	; 0x07
    34c6:	9b 87       	std	Y+11, r25	; 0x0b
    34c8:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    34ca:	ea 85       	ldd	r30, Y+10	; 0x0a
    34cc:	fb 85       	ldd	r31, Y+11	; 0x0b
    34ce:	84 89       	ldd	r24, Z+20	; 0x14
    34d0:	95 89       	ldd	r25, Z+21	; 0x15
    34d2:	98 87       	std	Y+8, r25	; 0x08
    34d4:	8f 83       	std	Y+7, r24	; 0x07
    34d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    34d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    34da:	a6 85       	ldd	r26, Z+14	; 0x0e
    34dc:	b7 85       	ldd	r27, Z+15	; 0x0f
    34de:	ea 85       	ldd	r30, Y+10	; 0x0a
    34e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    34e2:	80 89       	ldd	r24, Z+16	; 0x10
    34e4:	91 89       	ldd	r25, Z+17	; 0x11
    34e6:	15 96       	adiw	r26, 0x05	; 5
    34e8:	9c 93       	st	X, r25
    34ea:	8e 93       	st	-X, r24
    34ec:	14 97       	sbiw	r26, 0x04	; 4
    34ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    34f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    34f2:	a0 89       	ldd	r26, Z+16	; 0x10
    34f4:	b1 89       	ldd	r27, Z+17	; 0x11
    34f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    34f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    34fa:	86 85       	ldd	r24, Z+14	; 0x0e
    34fc:	97 85       	ldd	r25, Z+15	; 0x0f
    34fe:	13 96       	adiw	r26, 0x03	; 3
    3500:	9c 93       	st	X, r25
    3502:	8e 93       	st	-X, r24
    3504:	12 97       	sbiw	r26, 0x02	; 2
    3506:	ef 81       	ldd	r30, Y+7	; 0x07
    3508:	f8 85       	ldd	r31, Y+8	; 0x08
    350a:	21 81       	ldd	r18, Z+1	; 0x01
    350c:	32 81       	ldd	r19, Z+2	; 0x02
    350e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3510:	9b 85       	ldd	r25, Y+11	; 0x0b
    3512:	0c 96       	adiw	r24, 0x0c	; 12
    3514:	28 17       	cp	r18, r24
    3516:	39 07       	cpc	r19, r25
    3518:	41 f4       	brne	.+16     	; 0x352a <xTaskResumeAll+0xb0>
    351a:	ea 85       	ldd	r30, Y+10	; 0x0a
    351c:	fb 85       	ldd	r31, Y+11	; 0x0b
    351e:	80 89       	ldd	r24, Z+16	; 0x10
    3520:	91 89       	ldd	r25, Z+17	; 0x11
    3522:	ef 81       	ldd	r30, Y+7	; 0x07
    3524:	f8 85       	ldd	r31, Y+8	; 0x08
    3526:	92 83       	std	Z+2, r25	; 0x02
    3528:	81 83       	std	Z+1, r24	; 0x01
    352a:	ea 85       	ldd	r30, Y+10	; 0x0a
    352c:	fb 85       	ldd	r31, Y+11	; 0x0b
    352e:	15 8a       	std	Z+21, r1	; 0x15
    3530:	14 8a       	std	Z+20, r1	; 0x14
    3532:	ef 81       	ldd	r30, Y+7	; 0x07
    3534:	f8 85       	ldd	r31, Y+8	; 0x08
    3536:	80 81       	ld	r24, Z
    3538:	81 50       	subi	r24, 0x01	; 1
    353a:	ef 81       	ldd	r30, Y+7	; 0x07
    353c:	f8 85       	ldd	r31, Y+8	; 0x08
    353e:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3540:	ea 85       	ldd	r30, Y+10	; 0x0a
    3542:	fb 85       	ldd	r31, Y+11	; 0x0b
    3544:	82 85       	ldd	r24, Z+10	; 0x0a
    3546:	93 85       	ldd	r25, Z+11	; 0x0b
    3548:	9e 83       	std	Y+6, r25	; 0x06
    354a:	8d 83       	std	Y+5, r24	; 0x05
    354c:	ea 85       	ldd	r30, Y+10	; 0x0a
    354e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3550:	a4 81       	ldd	r26, Z+4	; 0x04
    3552:	b5 81       	ldd	r27, Z+5	; 0x05
    3554:	ea 85       	ldd	r30, Y+10	; 0x0a
    3556:	fb 85       	ldd	r31, Y+11	; 0x0b
    3558:	86 81       	ldd	r24, Z+6	; 0x06
    355a:	97 81       	ldd	r25, Z+7	; 0x07
    355c:	15 96       	adiw	r26, 0x05	; 5
    355e:	9c 93       	st	X, r25
    3560:	8e 93       	st	-X, r24
    3562:	14 97       	sbiw	r26, 0x04	; 4
    3564:	ea 85       	ldd	r30, Y+10	; 0x0a
    3566:	fb 85       	ldd	r31, Y+11	; 0x0b
    3568:	a6 81       	ldd	r26, Z+6	; 0x06
    356a:	b7 81       	ldd	r27, Z+7	; 0x07
    356c:	ea 85       	ldd	r30, Y+10	; 0x0a
    356e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3570:	84 81       	ldd	r24, Z+4	; 0x04
    3572:	95 81       	ldd	r25, Z+5	; 0x05
    3574:	13 96       	adiw	r26, 0x03	; 3
    3576:	9c 93       	st	X, r25
    3578:	8e 93       	st	-X, r24
    357a:	12 97       	sbiw	r26, 0x02	; 2
    357c:	ed 81       	ldd	r30, Y+5	; 0x05
    357e:	fe 81       	ldd	r31, Y+6	; 0x06
    3580:	21 81       	ldd	r18, Z+1	; 0x01
    3582:	32 81       	ldd	r19, Z+2	; 0x02
    3584:	8a 85       	ldd	r24, Y+10	; 0x0a
    3586:	9b 85       	ldd	r25, Y+11	; 0x0b
    3588:	02 96       	adiw	r24, 0x02	; 2
    358a:	28 17       	cp	r18, r24
    358c:	39 07       	cpc	r19, r25
    358e:	41 f4       	brne	.+16     	; 0x35a0 <xTaskResumeAll+0x126>
    3590:	ea 85       	ldd	r30, Y+10	; 0x0a
    3592:	fb 85       	ldd	r31, Y+11	; 0x0b
    3594:	86 81       	ldd	r24, Z+6	; 0x06
    3596:	97 81       	ldd	r25, Z+7	; 0x07
    3598:	ed 81       	ldd	r30, Y+5	; 0x05
    359a:	fe 81       	ldd	r31, Y+6	; 0x06
    359c:	92 83       	std	Z+2, r25	; 0x02
    359e:	81 83       	std	Z+1, r24	; 0x01
    35a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    35a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    35a4:	13 86       	std	Z+11, r1	; 0x0b
    35a6:	12 86       	std	Z+10, r1	; 0x0a
    35a8:	ed 81       	ldd	r30, Y+5	; 0x05
    35aa:	fe 81       	ldd	r31, Y+6	; 0x06
    35ac:	80 81       	ld	r24, Z
    35ae:	81 50       	subi	r24, 0x01	; 1
    35b0:	ed 81       	ldd	r30, Y+5	; 0x05
    35b2:	fe 81       	ldd	r31, Y+6	; 0x06
    35b4:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    35b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    35b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    35ba:	96 89       	ldd	r25, Z+22	; 0x16
    35bc:	80 91 66 06 	lds	r24, 0x0666
    35c0:	89 17       	cp	r24, r25
    35c2:	28 f4       	brcc	.+10     	; 0x35ce <xTaskResumeAll+0x154>
    35c4:	ea 85       	ldd	r30, Y+10	; 0x0a
    35c6:	fb 85       	ldd	r31, Y+11	; 0x0b
    35c8:	86 89       	ldd	r24, Z+22	; 0x16
    35ca:	80 93 66 06 	sts	0x0666, r24
    35ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    35d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    35d2:	86 89       	ldd	r24, Z+22	; 0x16
    35d4:	28 2f       	mov	r18, r24
    35d6:	30 e0       	ldi	r19, 0x00	; 0
    35d8:	c9 01       	movw	r24, r18
    35da:	88 0f       	add	r24, r24
    35dc:	99 1f       	adc	r25, r25
    35de:	88 0f       	add	r24, r24
    35e0:	99 1f       	adc	r25, r25
    35e2:	88 0f       	add	r24, r24
    35e4:	99 1f       	adc	r25, r25
    35e6:	82 0f       	add	r24, r18
    35e8:	93 1f       	adc	r25, r19
    35ea:	fc 01       	movw	r30, r24
    35ec:	ee 58       	subi	r30, 0x8E	; 142
    35ee:	f9 4f       	sbci	r31, 0xF9	; 249
    35f0:	81 81       	ldd	r24, Z+1	; 0x01
    35f2:	92 81       	ldd	r25, Z+2	; 0x02
    35f4:	9c 83       	std	Y+4, r25	; 0x04
    35f6:	8b 83       	std	Y+3, r24	; 0x03
    35f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    35fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    35fc:	8b 81       	ldd	r24, Y+3	; 0x03
    35fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3600:	95 83       	std	Z+5, r25	; 0x05
    3602:	84 83       	std	Z+4, r24	; 0x04
    3604:	eb 81       	ldd	r30, Y+3	; 0x03
    3606:	fc 81       	ldd	r31, Y+4	; 0x04
    3608:	84 81       	ldd	r24, Z+4	; 0x04
    360a:	95 81       	ldd	r25, Z+5	; 0x05
    360c:	ea 85       	ldd	r30, Y+10	; 0x0a
    360e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3610:	97 83       	std	Z+7, r25	; 0x07
    3612:	86 83       	std	Z+6, r24	; 0x06
    3614:	eb 81       	ldd	r30, Y+3	; 0x03
    3616:	fc 81       	ldd	r31, Y+4	; 0x04
    3618:	04 80       	ldd	r0, Z+4	; 0x04
    361a:	f5 81       	ldd	r31, Z+5	; 0x05
    361c:	e0 2d       	mov	r30, r0
    361e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3620:	9b 85       	ldd	r25, Y+11	; 0x0b
    3622:	02 96       	adiw	r24, 0x02	; 2
    3624:	93 83       	std	Z+3, r25	; 0x03
    3626:	82 83       	std	Z+2, r24	; 0x02
    3628:	8a 85       	ldd	r24, Y+10	; 0x0a
    362a:	9b 85       	ldd	r25, Y+11	; 0x0b
    362c:	02 96       	adiw	r24, 0x02	; 2
    362e:	eb 81       	ldd	r30, Y+3	; 0x03
    3630:	fc 81       	ldd	r31, Y+4	; 0x04
    3632:	95 83       	std	Z+5, r25	; 0x05
    3634:	84 83       	std	Z+4, r24	; 0x04
    3636:	ea 85       	ldd	r30, Y+10	; 0x0a
    3638:	fb 85       	ldd	r31, Y+11	; 0x0b
    363a:	86 89       	ldd	r24, Z+22	; 0x16
    363c:	28 2f       	mov	r18, r24
    363e:	30 e0       	ldi	r19, 0x00	; 0
    3640:	c9 01       	movw	r24, r18
    3642:	88 0f       	add	r24, r24
    3644:	99 1f       	adc	r25, r25
    3646:	88 0f       	add	r24, r24
    3648:	99 1f       	adc	r25, r25
    364a:	88 0f       	add	r24, r24
    364c:	99 1f       	adc	r25, r25
    364e:	82 0f       	add	r24, r18
    3650:	93 1f       	adc	r25, r19
    3652:	8e 58       	subi	r24, 0x8E	; 142
    3654:	99 4f       	sbci	r25, 0xF9	; 249
    3656:	ea 85       	ldd	r30, Y+10	; 0x0a
    3658:	fb 85       	ldd	r31, Y+11	; 0x0b
    365a:	93 87       	std	Z+11, r25	; 0x0b
    365c:	82 87       	std	Z+10, r24	; 0x0a
    365e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3660:	fb 85       	ldd	r31, Y+11	; 0x0b
    3662:	86 89       	ldd	r24, Z+22	; 0x16
    3664:	28 2f       	mov	r18, r24
    3666:	30 e0       	ldi	r19, 0x00	; 0
    3668:	c9 01       	movw	r24, r18
    366a:	88 0f       	add	r24, r24
    366c:	99 1f       	adc	r25, r25
    366e:	88 0f       	add	r24, r24
    3670:	99 1f       	adc	r25, r25
    3672:	88 0f       	add	r24, r24
    3674:	99 1f       	adc	r25, r25
    3676:	82 0f       	add	r24, r18
    3678:	93 1f       	adc	r25, r19
    367a:	fc 01       	movw	r30, r24
    367c:	ee 58       	subi	r30, 0x8E	; 142
    367e:	f9 4f       	sbci	r31, 0xF9	; 249
    3680:	80 81       	ld	r24, Z
    3682:	8f 5f       	subi	r24, 0xFF	; 255
    3684:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3686:	ea 85       	ldd	r30, Y+10	; 0x0a
    3688:	fb 85       	ldd	r31, Y+11	; 0x0b
    368a:	96 89       	ldd	r25, Z+22	; 0x16
    368c:	e0 91 60 06 	lds	r30, 0x0660
    3690:	f0 91 61 06 	lds	r31, 0x0661
    3694:	86 89       	ldd	r24, Z+22	; 0x16
    3696:	98 17       	cp	r25, r24
    3698:	18 f0       	brcs	.+6      	; 0x36a0 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    369a:	81 e0       	ldi	r24, 0x01	; 1
    369c:	80 93 6a 06 	sts	0x066A, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    36a0:	80 91 ac 06 	lds	r24, 0x06AC
    36a4:	88 23       	and	r24, r24
    36a6:	09 f0       	breq	.+2      	; 0x36aa <xTaskResumeAll+0x230>
    36a8:	08 cf       	rjmp	.-496    	; 0x34ba <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    36aa:	8a 85       	ldd	r24, Y+10	; 0x0a
    36ac:	9b 85       	ldd	r25, Y+11	; 0x0b
    36ae:	00 97       	sbiw	r24, 0x00	; 0
    36b0:	11 f0       	breq	.+4      	; 0x36b6 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    36b2:	0e 94 f6 21 	call	0x43ec	; 0x43ec <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    36b6:	80 91 68 06 	lds	r24, 0x0668
    36ba:	90 91 69 06 	lds	r25, 0x0669
    36be:	9a 83       	std	Y+2, r25	; 0x02
    36c0:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    36c2:	89 81       	ldd	r24, Y+1	; 0x01
    36c4:	9a 81       	ldd	r25, Y+2	; 0x02
    36c6:	00 97       	sbiw	r24, 0x00	; 0
    36c8:	a1 f0       	breq	.+40     	; 0x36f2 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    36ca:	0e 94 04 1c 	call	0x3808	; 0x3808 <xTaskIncrementTick>
    36ce:	88 23       	and	r24, r24
    36d0:	19 f0       	breq	.+6      	; 0x36d8 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    36d2:	81 e0       	ldi	r24, 0x01	; 1
    36d4:	80 93 6a 06 	sts	0x066A, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    36d8:	89 81       	ldd	r24, Y+1	; 0x01
    36da:	9a 81       	ldd	r25, Y+2	; 0x02
    36dc:	01 97       	sbiw	r24, 0x01	; 1
    36de:	9a 83       	std	Y+2, r25	; 0x02
    36e0:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    36e2:	89 81       	ldd	r24, Y+1	; 0x01
    36e4:	9a 81       	ldd	r25, Y+2	; 0x02
    36e6:	00 97       	sbiw	r24, 0x00	; 0
    36e8:	81 f7       	brne	.-32     	; 0x36ca <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    36ea:	10 92 69 06 	sts	0x0669, r1
    36ee:	10 92 68 06 	sts	0x0668, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    36f2:	80 91 6a 06 	lds	r24, 0x066A
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    36f6:	0f 90       	pop	r0
    36f8:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    36fa:	89 85       	ldd	r24, Y+9	; 0x09
}
    36fc:	2c 96       	adiw	r28, 0x0c	; 12
    36fe:	0f b6       	in	r0, 0x3f	; 63
    3700:	f8 94       	cli
    3702:	de bf       	out	0x3e, r29	; 62
    3704:	0f be       	out	0x3f, r0	; 63
    3706:	cd bf       	out	0x3d, r28	; 61
    3708:	cf 91       	pop	r28
    370a:	df 91       	pop	r29
    370c:	08 95       	ret

0000370e <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    370e:	df 93       	push	r29
    3710:	cf 93       	push	r28
    3712:	00 d0       	rcall	.+0      	; 0x3714 <xTaskGetTickCount+0x6>
    3714:	cd b7       	in	r28, 0x3d	; 61
    3716:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3718:	0f b6       	in	r0, 0x3f	; 63
    371a:	f8 94       	cli
    371c:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    371e:	80 91 64 06 	lds	r24, 0x0664
    3722:	90 91 65 06 	lds	r25, 0x0665
    3726:	9a 83       	std	Y+2, r25	; 0x02
    3728:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    372a:	0f 90       	pop	r0
    372c:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    372e:	89 81       	ldd	r24, Y+1	; 0x01
    3730:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3732:	0f 90       	pop	r0
    3734:	0f 90       	pop	r0
    3736:	cf 91       	pop	r28
    3738:	df 91       	pop	r29
    373a:	08 95       	ret

0000373c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    373c:	df 93       	push	r29
    373e:	cf 93       	push	r28
    3740:	00 d0       	rcall	.+0      	; 0x3742 <xTaskGetTickCountFromISR+0x6>
    3742:	0f 92       	push	r0
    3744:	cd b7       	in	r28, 0x3d	; 61
    3746:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3748:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    374a:	80 91 64 06 	lds	r24, 0x0664
    374e:	90 91 65 06 	lds	r25, 0x0665
    3752:	9b 83       	std	Y+3, r25	; 0x03
    3754:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3756:	8a 81       	ldd	r24, Y+2	; 0x02
    3758:	9b 81       	ldd	r25, Y+3	; 0x03
}
    375a:	0f 90       	pop	r0
    375c:	0f 90       	pop	r0
    375e:	0f 90       	pop	r0
    3760:	cf 91       	pop	r28
    3762:	df 91       	pop	r29
    3764:	08 95       	ret

00003766 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3766:	df 93       	push	r29
    3768:	cf 93       	push	r28
    376a:	cd b7       	in	r28, 0x3d	; 61
    376c:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    376e:	80 91 63 06 	lds	r24, 0x0663
}
    3772:	cf 91       	pop	r28
    3774:	df 91       	pop	r29
    3776:	08 95       	ret

00003778 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3778:	df 93       	push	r29
    377a:	cf 93       	push	r28
    377c:	00 d0       	rcall	.+0      	; 0x377e <pcTaskGetName+0x6>
    377e:	00 d0       	rcall	.+0      	; 0x3780 <pcTaskGetName+0x8>
    3780:	00 d0       	rcall	.+0      	; 0x3782 <pcTaskGetName+0xa>
    3782:	cd b7       	in	r28, 0x3d	; 61
    3784:	de b7       	in	r29, 0x3e	; 62
    3786:	9c 83       	std	Y+4, r25	; 0x04
    3788:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    378a:	8b 81       	ldd	r24, Y+3	; 0x03
    378c:	9c 81       	ldd	r25, Y+4	; 0x04
    378e:	00 97       	sbiw	r24, 0x00	; 0
    3790:	39 f4       	brne	.+14     	; 0x37a0 <pcTaskGetName+0x28>
    3792:	80 91 60 06 	lds	r24, 0x0660
    3796:	90 91 61 06 	lds	r25, 0x0661
    379a:	9e 83       	std	Y+6, r25	; 0x06
    379c:	8d 83       	std	Y+5, r24	; 0x05
    379e:	04 c0       	rjmp	.+8      	; 0x37a8 <pcTaskGetName+0x30>
    37a0:	8b 81       	ldd	r24, Y+3	; 0x03
    37a2:	9c 81       	ldd	r25, Y+4	; 0x04
    37a4:	9e 83       	std	Y+6, r25	; 0x06
    37a6:	8d 83       	std	Y+5, r24	; 0x05
    37a8:	8d 81       	ldd	r24, Y+5	; 0x05
    37aa:	9e 81       	ldd	r25, Y+6	; 0x06
    37ac:	9a 83       	std	Y+2, r25	; 0x02
    37ae:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    37b0:	89 81       	ldd	r24, Y+1	; 0x01
    37b2:	9a 81       	ldd	r25, Y+2	; 0x02
    37b4:	49 96       	adiw	r24, 0x19	; 25
}
    37b6:	26 96       	adiw	r28, 0x06	; 6
    37b8:	0f b6       	in	r0, 0x3f	; 63
    37ba:	f8 94       	cli
    37bc:	de bf       	out	0x3e, r29	; 62
    37be:	0f be       	out	0x3f, r0	; 63
    37c0:	cd bf       	out	0x3d, r28	; 61
    37c2:	cf 91       	pop	r28
    37c4:	df 91       	pop	r29
    37c6:	08 95       	ret

000037c8 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    37c8:	df 93       	push	r29
    37ca:	cf 93       	push	r28
    37cc:	00 d0       	rcall	.+0      	; 0x37ce <xTaskCatchUpTicks+0x6>
    37ce:	0f 92       	push	r0
    37d0:	cd b7       	in	r28, 0x3d	; 61
    37d2:	de b7       	in	r29, 0x3e	; 62
    37d4:	9b 83       	std	Y+3, r25	; 0x03
    37d6:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    37d8:	0e 94 31 1a 	call	0x3462	; 0x3462 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    37dc:	20 91 68 06 	lds	r18, 0x0668
    37e0:	30 91 69 06 	lds	r19, 0x0669
    37e4:	8a 81       	ldd	r24, Y+2	; 0x02
    37e6:	9b 81       	ldd	r25, Y+3	; 0x03
    37e8:	82 0f       	add	r24, r18
    37ea:	93 1f       	adc	r25, r19
    37ec:	90 93 69 06 	sts	0x0669, r25
    37f0:	80 93 68 06 	sts	0x0668, r24
    xYieldOccurred = xTaskResumeAll();
    37f4:	0e 94 3d 1a 	call	0x347a	; 0x347a <xTaskResumeAll>
    37f8:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    37fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    37fc:	0f 90       	pop	r0
    37fe:	0f 90       	pop	r0
    3800:	0f 90       	pop	r0
    3802:	cf 91       	pop	r28
    3804:	df 91       	pop	r29
    3806:	08 95       	ret

00003808 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3808:	df 93       	push	r29
    380a:	cf 93       	push	r28
    380c:	cd b7       	in	r28, 0x3d	; 61
    380e:	de b7       	in	r29, 0x3e	; 62
    3810:	2f 97       	sbiw	r28, 0x0f	; 15
    3812:	0f b6       	in	r0, 0x3f	; 63
    3814:	f8 94       	cli
    3816:	de bf       	out	0x3e, r29	; 62
    3818:	0f be       	out	0x3f, r0	; 63
    381a:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    381c:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    381e:	80 91 71 06 	lds	r24, 0x0671
    3822:	88 23       	and	r24, r24
    3824:	09 f0       	breq	.+2      	; 0x3828 <xTaskIncrementTick+0x20>
    3826:	51 c1       	rjmp	.+674    	; 0x3aca <xTaskIncrementTick+0x2c2>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3828:	80 91 64 06 	lds	r24, 0x0664
    382c:	90 91 65 06 	lds	r25, 0x0665
    3830:	01 96       	adiw	r24, 0x01	; 1
    3832:	9a 87       	std	Y+10, r25	; 0x0a
    3834:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    3836:	89 85       	ldd	r24, Y+9	; 0x09
    3838:	9a 85       	ldd	r25, Y+10	; 0x0a
    383a:	90 93 65 06 	sts	0x0665, r25
    383e:	80 93 64 06 	sts	0x0664, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3842:	89 85       	ldd	r24, Y+9	; 0x09
    3844:	9a 85       	ldd	r25, Y+10	; 0x0a
    3846:	00 97       	sbiw	r24, 0x00	; 0
    3848:	d9 f4       	brne	.+54     	; 0x3880 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    384a:	80 91 a8 06 	lds	r24, 0x06A8
    384e:	90 91 a9 06 	lds	r25, 0x06A9
    3852:	98 87       	std	Y+8, r25	; 0x08
    3854:	8f 83       	std	Y+7, r24	; 0x07
    3856:	80 91 aa 06 	lds	r24, 0x06AA
    385a:	90 91 ab 06 	lds	r25, 0x06AB
    385e:	90 93 a9 06 	sts	0x06A9, r25
    3862:	80 93 a8 06 	sts	0x06A8, r24
    3866:	8f 81       	ldd	r24, Y+7	; 0x07
    3868:	98 85       	ldd	r25, Y+8	; 0x08
    386a:	90 93 ab 06 	sts	0x06AB, r25
    386e:	80 93 aa 06 	sts	0x06AA, r24
    3872:	80 91 6b 06 	lds	r24, 0x066B
    3876:	8f 5f       	subi	r24, 0xFF	; 255
    3878:	80 93 6b 06 	sts	0x066B, r24
    387c:	0e 94 f6 21 	call	0x43ec	; 0x43ec <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3880:	20 91 6d 06 	lds	r18, 0x066D
    3884:	30 91 6e 06 	lds	r19, 0x066E
    3888:	89 85       	ldd	r24, Y+9	; 0x09
    388a:	9a 85       	ldd	r25, Y+10	; 0x0a
    388c:	82 17       	cp	r24, r18
    388e:	93 07       	cpc	r25, r19
    3890:	08 f4       	brcc	.+2      	; 0x3894 <xTaskIncrementTick+0x8c>
    3892:	12 c1       	rjmp	.+548    	; 0x3ab8 <xTaskIncrementTick+0x2b0>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3894:	e0 91 a8 06 	lds	r30, 0x06A8
    3898:	f0 91 a9 06 	lds	r31, 0x06A9
    389c:	80 81       	ld	r24, Z
    389e:	88 23       	and	r24, r24
    38a0:	39 f4       	brne	.+14     	; 0x38b0 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    38a2:	8f ef       	ldi	r24, 0xFF	; 255
    38a4:	9f ef       	ldi	r25, 0xFF	; 255
    38a6:	90 93 6e 06 	sts	0x066E, r25
    38aa:	80 93 6d 06 	sts	0x066D, r24
    38ae:	04 c1       	rjmp	.+520    	; 0x3ab8 <xTaskIncrementTick+0x2b0>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    38b0:	e0 91 a8 06 	lds	r30, 0x06A8
    38b4:	f0 91 a9 06 	lds	r31, 0x06A9
    38b8:	05 80       	ldd	r0, Z+5	; 0x05
    38ba:	f6 81       	ldd	r31, Z+6	; 0x06
    38bc:	e0 2d       	mov	r30, r0
    38be:	86 81       	ldd	r24, Z+6	; 0x06
    38c0:	97 81       	ldd	r25, Z+7	; 0x07
    38c2:	9f 87       	std	Y+15, r25	; 0x0f
    38c4:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    38c6:	ee 85       	ldd	r30, Y+14	; 0x0e
    38c8:	ff 85       	ldd	r31, Y+15	; 0x0f
    38ca:	82 81       	ldd	r24, Z+2	; 0x02
    38cc:	93 81       	ldd	r25, Z+3	; 0x03
    38ce:	9d 87       	std	Y+13, r25	; 0x0d
    38d0:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    38d2:	29 85       	ldd	r18, Y+9	; 0x09
    38d4:	3a 85       	ldd	r19, Y+10	; 0x0a
    38d6:	8c 85       	ldd	r24, Y+12	; 0x0c
    38d8:	9d 85       	ldd	r25, Y+13	; 0x0d
    38da:	28 17       	cp	r18, r24
    38dc:	39 07       	cpc	r19, r25
    38de:	38 f4       	brcc	.+14     	; 0x38ee <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    38e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    38e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    38e4:	90 93 6e 06 	sts	0x066E, r25
    38e8:	80 93 6d 06 	sts	0x066D, r24
    38ec:	e5 c0       	rjmp	.+458    	; 0x3ab8 <xTaskIncrementTick+0x2b0>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    38ee:	ee 85       	ldd	r30, Y+14	; 0x0e
    38f0:	ff 85       	ldd	r31, Y+15	; 0x0f
    38f2:	82 85       	ldd	r24, Z+10	; 0x0a
    38f4:	93 85       	ldd	r25, Z+11	; 0x0b
    38f6:	9e 83       	std	Y+6, r25	; 0x06
    38f8:	8d 83       	std	Y+5, r24	; 0x05
    38fa:	ee 85       	ldd	r30, Y+14	; 0x0e
    38fc:	ff 85       	ldd	r31, Y+15	; 0x0f
    38fe:	a4 81       	ldd	r26, Z+4	; 0x04
    3900:	b5 81       	ldd	r27, Z+5	; 0x05
    3902:	ee 85       	ldd	r30, Y+14	; 0x0e
    3904:	ff 85       	ldd	r31, Y+15	; 0x0f
    3906:	86 81       	ldd	r24, Z+6	; 0x06
    3908:	97 81       	ldd	r25, Z+7	; 0x07
    390a:	15 96       	adiw	r26, 0x05	; 5
    390c:	9c 93       	st	X, r25
    390e:	8e 93       	st	-X, r24
    3910:	14 97       	sbiw	r26, 0x04	; 4
    3912:	ee 85       	ldd	r30, Y+14	; 0x0e
    3914:	ff 85       	ldd	r31, Y+15	; 0x0f
    3916:	a6 81       	ldd	r26, Z+6	; 0x06
    3918:	b7 81       	ldd	r27, Z+7	; 0x07
    391a:	ee 85       	ldd	r30, Y+14	; 0x0e
    391c:	ff 85       	ldd	r31, Y+15	; 0x0f
    391e:	84 81       	ldd	r24, Z+4	; 0x04
    3920:	95 81       	ldd	r25, Z+5	; 0x05
    3922:	13 96       	adiw	r26, 0x03	; 3
    3924:	9c 93       	st	X, r25
    3926:	8e 93       	st	-X, r24
    3928:	12 97       	sbiw	r26, 0x02	; 2
    392a:	ed 81       	ldd	r30, Y+5	; 0x05
    392c:	fe 81       	ldd	r31, Y+6	; 0x06
    392e:	21 81       	ldd	r18, Z+1	; 0x01
    3930:	32 81       	ldd	r19, Z+2	; 0x02
    3932:	8e 85       	ldd	r24, Y+14	; 0x0e
    3934:	9f 85       	ldd	r25, Y+15	; 0x0f
    3936:	02 96       	adiw	r24, 0x02	; 2
    3938:	28 17       	cp	r18, r24
    393a:	39 07       	cpc	r19, r25
    393c:	41 f4       	brne	.+16     	; 0x394e <xTaskIncrementTick+0x146>
    393e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3940:	ff 85       	ldd	r31, Y+15	; 0x0f
    3942:	86 81       	ldd	r24, Z+6	; 0x06
    3944:	97 81       	ldd	r25, Z+7	; 0x07
    3946:	ed 81       	ldd	r30, Y+5	; 0x05
    3948:	fe 81       	ldd	r31, Y+6	; 0x06
    394a:	92 83       	std	Z+2, r25	; 0x02
    394c:	81 83       	std	Z+1, r24	; 0x01
    394e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3950:	ff 85       	ldd	r31, Y+15	; 0x0f
    3952:	13 86       	std	Z+11, r1	; 0x0b
    3954:	12 86       	std	Z+10, r1	; 0x0a
    3956:	ed 81       	ldd	r30, Y+5	; 0x05
    3958:	fe 81       	ldd	r31, Y+6	; 0x06
    395a:	80 81       	ld	r24, Z
    395c:	81 50       	subi	r24, 0x01	; 1
    395e:	ed 81       	ldd	r30, Y+5	; 0x05
    3960:	fe 81       	ldd	r31, Y+6	; 0x06
    3962:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3964:	ee 85       	ldd	r30, Y+14	; 0x0e
    3966:	ff 85       	ldd	r31, Y+15	; 0x0f
    3968:	84 89       	ldd	r24, Z+20	; 0x14
    396a:	95 89       	ldd	r25, Z+21	; 0x15
    396c:	00 97       	sbiw	r24, 0x00	; 0
    396e:	d9 f1       	breq	.+118    	; 0x39e6 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3970:	ee 85       	ldd	r30, Y+14	; 0x0e
    3972:	ff 85       	ldd	r31, Y+15	; 0x0f
    3974:	84 89       	ldd	r24, Z+20	; 0x14
    3976:	95 89       	ldd	r25, Z+21	; 0x15
    3978:	9c 83       	std	Y+4, r25	; 0x04
    397a:	8b 83       	std	Y+3, r24	; 0x03
    397c:	ee 85       	ldd	r30, Y+14	; 0x0e
    397e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3980:	a6 85       	ldd	r26, Z+14	; 0x0e
    3982:	b7 85       	ldd	r27, Z+15	; 0x0f
    3984:	ee 85       	ldd	r30, Y+14	; 0x0e
    3986:	ff 85       	ldd	r31, Y+15	; 0x0f
    3988:	80 89       	ldd	r24, Z+16	; 0x10
    398a:	91 89       	ldd	r25, Z+17	; 0x11
    398c:	15 96       	adiw	r26, 0x05	; 5
    398e:	9c 93       	st	X, r25
    3990:	8e 93       	st	-X, r24
    3992:	14 97       	sbiw	r26, 0x04	; 4
    3994:	ee 85       	ldd	r30, Y+14	; 0x0e
    3996:	ff 85       	ldd	r31, Y+15	; 0x0f
    3998:	a0 89       	ldd	r26, Z+16	; 0x10
    399a:	b1 89       	ldd	r27, Z+17	; 0x11
    399c:	ee 85       	ldd	r30, Y+14	; 0x0e
    399e:	ff 85       	ldd	r31, Y+15	; 0x0f
    39a0:	86 85       	ldd	r24, Z+14	; 0x0e
    39a2:	97 85       	ldd	r25, Z+15	; 0x0f
    39a4:	13 96       	adiw	r26, 0x03	; 3
    39a6:	9c 93       	st	X, r25
    39a8:	8e 93       	st	-X, r24
    39aa:	12 97       	sbiw	r26, 0x02	; 2
    39ac:	eb 81       	ldd	r30, Y+3	; 0x03
    39ae:	fc 81       	ldd	r31, Y+4	; 0x04
    39b0:	21 81       	ldd	r18, Z+1	; 0x01
    39b2:	32 81       	ldd	r19, Z+2	; 0x02
    39b4:	8e 85       	ldd	r24, Y+14	; 0x0e
    39b6:	9f 85       	ldd	r25, Y+15	; 0x0f
    39b8:	0c 96       	adiw	r24, 0x0c	; 12
    39ba:	28 17       	cp	r18, r24
    39bc:	39 07       	cpc	r19, r25
    39be:	41 f4       	brne	.+16     	; 0x39d0 <xTaskIncrementTick+0x1c8>
    39c0:	ee 85       	ldd	r30, Y+14	; 0x0e
    39c2:	ff 85       	ldd	r31, Y+15	; 0x0f
    39c4:	80 89       	ldd	r24, Z+16	; 0x10
    39c6:	91 89       	ldd	r25, Z+17	; 0x11
    39c8:	eb 81       	ldd	r30, Y+3	; 0x03
    39ca:	fc 81       	ldd	r31, Y+4	; 0x04
    39cc:	92 83       	std	Z+2, r25	; 0x02
    39ce:	81 83       	std	Z+1, r24	; 0x01
    39d0:	ee 85       	ldd	r30, Y+14	; 0x0e
    39d2:	ff 85       	ldd	r31, Y+15	; 0x0f
    39d4:	15 8a       	std	Z+21, r1	; 0x15
    39d6:	14 8a       	std	Z+20, r1	; 0x14
    39d8:	eb 81       	ldd	r30, Y+3	; 0x03
    39da:	fc 81       	ldd	r31, Y+4	; 0x04
    39dc:	80 81       	ld	r24, Z
    39de:	81 50       	subi	r24, 0x01	; 1
    39e0:	eb 81       	ldd	r30, Y+3	; 0x03
    39e2:	fc 81       	ldd	r31, Y+4	; 0x04
    39e4:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    39e6:	ee 85       	ldd	r30, Y+14	; 0x0e
    39e8:	ff 85       	ldd	r31, Y+15	; 0x0f
    39ea:	96 89       	ldd	r25, Z+22	; 0x16
    39ec:	80 91 66 06 	lds	r24, 0x0666
    39f0:	89 17       	cp	r24, r25
    39f2:	28 f4       	brcc	.+10     	; 0x39fe <xTaskIncrementTick+0x1f6>
    39f4:	ee 85       	ldd	r30, Y+14	; 0x0e
    39f6:	ff 85       	ldd	r31, Y+15	; 0x0f
    39f8:	86 89       	ldd	r24, Z+22	; 0x16
    39fa:	80 93 66 06 	sts	0x0666, r24
    39fe:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a00:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a02:	86 89       	ldd	r24, Z+22	; 0x16
    3a04:	28 2f       	mov	r18, r24
    3a06:	30 e0       	ldi	r19, 0x00	; 0
    3a08:	c9 01       	movw	r24, r18
    3a0a:	88 0f       	add	r24, r24
    3a0c:	99 1f       	adc	r25, r25
    3a0e:	88 0f       	add	r24, r24
    3a10:	99 1f       	adc	r25, r25
    3a12:	88 0f       	add	r24, r24
    3a14:	99 1f       	adc	r25, r25
    3a16:	82 0f       	add	r24, r18
    3a18:	93 1f       	adc	r25, r19
    3a1a:	fc 01       	movw	r30, r24
    3a1c:	ee 58       	subi	r30, 0x8E	; 142
    3a1e:	f9 4f       	sbci	r31, 0xF9	; 249
    3a20:	81 81       	ldd	r24, Z+1	; 0x01
    3a22:	92 81       	ldd	r25, Z+2	; 0x02
    3a24:	9a 83       	std	Y+2, r25	; 0x02
    3a26:	89 83       	std	Y+1, r24	; 0x01
    3a28:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a2a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a2c:	89 81       	ldd	r24, Y+1	; 0x01
    3a2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3a30:	95 83       	std	Z+5, r25	; 0x05
    3a32:	84 83       	std	Z+4, r24	; 0x04
    3a34:	e9 81       	ldd	r30, Y+1	; 0x01
    3a36:	fa 81       	ldd	r31, Y+2	; 0x02
    3a38:	84 81       	ldd	r24, Z+4	; 0x04
    3a3a:	95 81       	ldd	r25, Z+5	; 0x05
    3a3c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a3e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a40:	97 83       	std	Z+7, r25	; 0x07
    3a42:	86 83       	std	Z+6, r24	; 0x06
    3a44:	e9 81       	ldd	r30, Y+1	; 0x01
    3a46:	fa 81       	ldd	r31, Y+2	; 0x02
    3a48:	04 80       	ldd	r0, Z+4	; 0x04
    3a4a:	f5 81       	ldd	r31, Z+5	; 0x05
    3a4c:	e0 2d       	mov	r30, r0
    3a4e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a50:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a52:	02 96       	adiw	r24, 0x02	; 2
    3a54:	93 83       	std	Z+3, r25	; 0x03
    3a56:	82 83       	std	Z+2, r24	; 0x02
    3a58:	8e 85       	ldd	r24, Y+14	; 0x0e
    3a5a:	9f 85       	ldd	r25, Y+15	; 0x0f
    3a5c:	02 96       	adiw	r24, 0x02	; 2
    3a5e:	e9 81       	ldd	r30, Y+1	; 0x01
    3a60:	fa 81       	ldd	r31, Y+2	; 0x02
    3a62:	95 83       	std	Z+5, r25	; 0x05
    3a64:	84 83       	std	Z+4, r24	; 0x04
    3a66:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a68:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a6a:	86 89       	ldd	r24, Z+22	; 0x16
    3a6c:	28 2f       	mov	r18, r24
    3a6e:	30 e0       	ldi	r19, 0x00	; 0
    3a70:	c9 01       	movw	r24, r18
    3a72:	88 0f       	add	r24, r24
    3a74:	99 1f       	adc	r25, r25
    3a76:	88 0f       	add	r24, r24
    3a78:	99 1f       	adc	r25, r25
    3a7a:	88 0f       	add	r24, r24
    3a7c:	99 1f       	adc	r25, r25
    3a7e:	82 0f       	add	r24, r18
    3a80:	93 1f       	adc	r25, r19
    3a82:	8e 58       	subi	r24, 0x8E	; 142
    3a84:	99 4f       	sbci	r25, 0xF9	; 249
    3a86:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a88:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a8a:	93 87       	std	Z+11, r25	; 0x0b
    3a8c:	82 87       	std	Z+10, r24	; 0x0a
    3a8e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3a90:	ff 85       	ldd	r31, Y+15	; 0x0f
    3a92:	86 89       	ldd	r24, Z+22	; 0x16
    3a94:	28 2f       	mov	r18, r24
    3a96:	30 e0       	ldi	r19, 0x00	; 0
    3a98:	c9 01       	movw	r24, r18
    3a9a:	88 0f       	add	r24, r24
    3a9c:	99 1f       	adc	r25, r25
    3a9e:	88 0f       	add	r24, r24
    3aa0:	99 1f       	adc	r25, r25
    3aa2:	88 0f       	add	r24, r24
    3aa4:	99 1f       	adc	r25, r25
    3aa6:	82 0f       	add	r24, r18
    3aa8:	93 1f       	adc	r25, r19
    3aaa:	fc 01       	movw	r30, r24
    3aac:	ee 58       	subi	r30, 0x8E	; 142
    3aae:	f9 4f       	sbci	r31, 0xF9	; 249
    3ab0:	80 81       	ld	r24, Z
    3ab2:	8f 5f       	subi	r24, 0xFF	; 255
    3ab4:	80 83       	st	Z, r24
    3ab6:	ee ce       	rjmp	.-548    	; 0x3894 <xTaskIncrementTick+0x8c>

        #if ( configUSE_TICK_HOOK == 1 )
            {
                /* Guard against the tick hook being called when the pended tick
                 * count is being unwound (when the scheduler is being unlocked). */
                if( xPendedTicks == ( TickType_t ) 0 )
    3ab8:	80 91 68 06 	lds	r24, 0x0668
    3abc:	90 91 69 06 	lds	r25, 0x0669
    3ac0:	00 97       	sbiw	r24, 0x00	; 0
    3ac2:	71 f4       	brne	.+28     	; 0x3ae0 <xTaskIncrementTick+0x2d8>
                {
                    vApplicationTickHook();
    3ac4:	0e 94 59 00 	call	0xb2	; 0xb2 <vApplicationTickHook>
    3ac8:	0b c0       	rjmp	.+22     	; 0x3ae0 <xTaskIncrementTick+0x2d8>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    3aca:	80 91 68 06 	lds	r24, 0x0668
    3ace:	90 91 69 06 	lds	r25, 0x0669
    3ad2:	01 96       	adiw	r24, 0x01	; 1
    3ad4:	90 93 69 06 	sts	0x0669, r25
    3ad8:	80 93 68 06 	sts	0x0668, r24

        /* The tick hook gets called at regular intervals, even if the
         * scheduler is locked. */
        #if ( configUSE_TICK_HOOK == 1 )
            {
                vApplicationTickHook();
    3adc:	0e 94 59 00 	call	0xb2	; 0xb2 <vApplicationTickHook>
            }
        #endif
    }

    return xSwitchRequired;
    3ae0:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    3ae2:	2f 96       	adiw	r28, 0x0f	; 15
    3ae4:	0f b6       	in	r0, 0x3f	; 63
    3ae6:	f8 94       	cli
    3ae8:	de bf       	out	0x3e, r29	; 62
    3aea:	0f be       	out	0x3f, r0	; 63
    3aec:	cd bf       	out	0x3d, r28	; 61
    3aee:	cf 91       	pop	r28
    3af0:	df 91       	pop	r29
    3af2:	08 95       	ret

00003af4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3af4:	df 93       	push	r29
    3af6:	cf 93       	push	r28
    3af8:	00 d0       	rcall	.+0      	; 0x3afa <vTaskSwitchContext+0x6>
    3afa:	0f 92       	push	r0
    3afc:	cd b7       	in	r28, 0x3d	; 61
    3afe:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3b00:	80 91 71 06 	lds	r24, 0x0671
    3b04:	88 23       	and	r24, r24
    3b06:	21 f0       	breq	.+8      	; 0x3b10 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    3b08:	81 e0       	ldi	r24, 0x01	; 1
    3b0a:	80 93 6a 06 	sts	0x066A, r24
    3b0e:	59 c0       	rjmp	.+178    	; 0x3bc2 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    3b10:	10 92 6a 06 	sts	0x066A, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3b14:	80 91 66 06 	lds	r24, 0x0666
    3b18:	8b 83       	std	Y+3, r24	; 0x03
    3b1a:	03 c0       	rjmp	.+6      	; 0x3b22 <vTaskSwitchContext+0x2e>
    3b1c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b1e:	81 50       	subi	r24, 0x01	; 1
    3b20:	8b 83       	std	Y+3, r24	; 0x03
    3b22:	8b 81       	ldd	r24, Y+3	; 0x03
    3b24:	28 2f       	mov	r18, r24
    3b26:	30 e0       	ldi	r19, 0x00	; 0
    3b28:	c9 01       	movw	r24, r18
    3b2a:	88 0f       	add	r24, r24
    3b2c:	99 1f       	adc	r25, r25
    3b2e:	88 0f       	add	r24, r24
    3b30:	99 1f       	adc	r25, r25
    3b32:	88 0f       	add	r24, r24
    3b34:	99 1f       	adc	r25, r25
    3b36:	82 0f       	add	r24, r18
    3b38:	93 1f       	adc	r25, r19
    3b3a:	fc 01       	movw	r30, r24
    3b3c:	ee 58       	subi	r30, 0x8E	; 142
    3b3e:	f9 4f       	sbci	r31, 0xF9	; 249
    3b40:	80 81       	ld	r24, Z
    3b42:	88 23       	and	r24, r24
    3b44:	59 f3       	breq	.-42     	; 0x3b1c <vTaskSwitchContext+0x28>
    3b46:	8b 81       	ldd	r24, Y+3	; 0x03
    3b48:	28 2f       	mov	r18, r24
    3b4a:	30 e0       	ldi	r19, 0x00	; 0
    3b4c:	c9 01       	movw	r24, r18
    3b4e:	88 0f       	add	r24, r24
    3b50:	99 1f       	adc	r25, r25
    3b52:	88 0f       	add	r24, r24
    3b54:	99 1f       	adc	r25, r25
    3b56:	88 0f       	add	r24, r24
    3b58:	99 1f       	adc	r25, r25
    3b5a:	82 0f       	add	r24, r18
    3b5c:	93 1f       	adc	r25, r19
    3b5e:	8e 58       	subi	r24, 0x8E	; 142
    3b60:	99 4f       	sbci	r25, 0xF9	; 249
    3b62:	9a 83       	std	Y+2, r25	; 0x02
    3b64:	89 83       	std	Y+1, r24	; 0x01
    3b66:	e9 81       	ldd	r30, Y+1	; 0x01
    3b68:	fa 81       	ldd	r31, Y+2	; 0x02
    3b6a:	01 80       	ldd	r0, Z+1	; 0x01
    3b6c:	f2 81       	ldd	r31, Z+2	; 0x02
    3b6e:	e0 2d       	mov	r30, r0
    3b70:	82 81       	ldd	r24, Z+2	; 0x02
    3b72:	93 81       	ldd	r25, Z+3	; 0x03
    3b74:	e9 81       	ldd	r30, Y+1	; 0x01
    3b76:	fa 81       	ldd	r31, Y+2	; 0x02
    3b78:	92 83       	std	Z+2, r25	; 0x02
    3b7a:	81 83       	std	Z+1, r24	; 0x01
    3b7c:	e9 81       	ldd	r30, Y+1	; 0x01
    3b7e:	fa 81       	ldd	r31, Y+2	; 0x02
    3b80:	21 81       	ldd	r18, Z+1	; 0x01
    3b82:	32 81       	ldd	r19, Z+2	; 0x02
    3b84:	89 81       	ldd	r24, Y+1	; 0x01
    3b86:	9a 81       	ldd	r25, Y+2	; 0x02
    3b88:	03 96       	adiw	r24, 0x03	; 3
    3b8a:	28 17       	cp	r18, r24
    3b8c:	39 07       	cpc	r19, r25
    3b8e:	59 f4       	brne	.+22     	; 0x3ba6 <vTaskSwitchContext+0xb2>
    3b90:	e9 81       	ldd	r30, Y+1	; 0x01
    3b92:	fa 81       	ldd	r31, Y+2	; 0x02
    3b94:	01 80       	ldd	r0, Z+1	; 0x01
    3b96:	f2 81       	ldd	r31, Z+2	; 0x02
    3b98:	e0 2d       	mov	r30, r0
    3b9a:	82 81       	ldd	r24, Z+2	; 0x02
    3b9c:	93 81       	ldd	r25, Z+3	; 0x03
    3b9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3ba0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ba2:	92 83       	std	Z+2, r25	; 0x02
    3ba4:	81 83       	std	Z+1, r24	; 0x01
    3ba6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ba8:	fa 81       	ldd	r31, Y+2	; 0x02
    3baa:	01 80       	ldd	r0, Z+1	; 0x01
    3bac:	f2 81       	ldd	r31, Z+2	; 0x02
    3bae:	e0 2d       	mov	r30, r0
    3bb0:	86 81       	ldd	r24, Z+6	; 0x06
    3bb2:	97 81       	ldd	r25, Z+7	; 0x07
    3bb4:	90 93 61 06 	sts	0x0661, r25
    3bb8:	80 93 60 06 	sts	0x0660, r24
    3bbc:	8b 81       	ldd	r24, Y+3	; 0x03
    3bbe:	80 93 66 06 	sts	0x0666, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    3bc2:	0f 90       	pop	r0
    3bc4:	0f 90       	pop	r0
    3bc6:	0f 90       	pop	r0
    3bc8:	cf 91       	pop	r28
    3bca:	df 91       	pop	r29
    3bcc:	08 95       	ret

00003bce <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    3bce:	df 93       	push	r29
    3bd0:	cf 93       	push	r28
    3bd2:	00 d0       	rcall	.+0      	; 0x3bd4 <vTaskPlaceOnEventList+0x6>
    3bd4:	00 d0       	rcall	.+0      	; 0x3bd6 <vTaskPlaceOnEventList+0x8>
    3bd6:	cd b7       	in	r28, 0x3d	; 61
    3bd8:	de b7       	in	r29, 0x3e	; 62
    3bda:	9a 83       	std	Y+2, r25	; 0x02
    3bdc:	89 83       	std	Y+1, r24	; 0x01
    3bde:	7c 83       	std	Y+4, r23	; 0x04
    3be0:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3be2:	80 91 60 06 	lds	r24, 0x0660
    3be6:	90 91 61 06 	lds	r25, 0x0661
    3bea:	9c 01       	movw	r18, r24
    3bec:	24 5f       	subi	r18, 0xF4	; 244
    3bee:	3f 4f       	sbci	r19, 0xFF	; 255
    3bf0:	89 81       	ldd	r24, Y+1	; 0x01
    3bf2:	9a 81       	ldd	r25, Y+2	; 0x02
    3bf4:	b9 01       	movw	r22, r18
    3bf6:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3bfa:	8b 81       	ldd	r24, Y+3	; 0x03
    3bfc:	9c 81       	ldd	r25, Y+4	; 0x04
    3bfe:	61 e0       	ldi	r22, 0x01	; 1
    3c00:	0e 94 ce 29 	call	0x539c	; 0x539c <prvAddCurrentTaskToDelayedList>
}
    3c04:	0f 90       	pop	r0
    3c06:	0f 90       	pop	r0
    3c08:	0f 90       	pop	r0
    3c0a:	0f 90       	pop	r0
    3c0c:	cf 91       	pop	r28
    3c0e:	df 91       	pop	r29
    3c10:	08 95       	ret

00003c12 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    3c12:	df 93       	push	r29
    3c14:	cf 93       	push	r28
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
    3c1a:	28 97       	sbiw	r28, 0x08	; 8
    3c1c:	0f b6       	in	r0, 0x3f	; 63
    3c1e:	f8 94       	cli
    3c20:	de bf       	out	0x3e, r29	; 62
    3c22:	0f be       	out	0x3f, r0	; 63
    3c24:	cd bf       	out	0x3d, r28	; 61
    3c26:	9c 83       	std	Y+4, r25	; 0x04
    3c28:	8b 83       	std	Y+3, r24	; 0x03
    3c2a:	7e 83       	std	Y+6, r23	; 0x06
    3c2c:	6d 83       	std	Y+5, r22	; 0x05
    3c2e:	58 87       	std	Y+8, r21	; 0x08
    3c30:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3c32:	e0 91 60 06 	lds	r30, 0x0660
    3c36:	f0 91 61 06 	lds	r31, 0x0661
    3c3a:	8d 81       	ldd	r24, Y+5	; 0x05
    3c3c:	9e 81       	ldd	r25, Y+6	; 0x06
    3c3e:	90 68       	ori	r25, 0x80	; 128
    3c40:	95 87       	std	Z+13, r25	; 0x0d
    3c42:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3c44:	eb 81       	ldd	r30, Y+3	; 0x03
    3c46:	fc 81       	ldd	r31, Y+4	; 0x04
    3c48:	81 81       	ldd	r24, Z+1	; 0x01
    3c4a:	92 81       	ldd	r25, Z+2	; 0x02
    3c4c:	9a 83       	std	Y+2, r25	; 0x02
    3c4e:	89 83       	std	Y+1, r24	; 0x01
    3c50:	e0 91 60 06 	lds	r30, 0x0660
    3c54:	f0 91 61 06 	lds	r31, 0x0661
    3c58:	89 81       	ldd	r24, Y+1	; 0x01
    3c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c5c:	97 87       	std	Z+15, r25	; 0x0f
    3c5e:	86 87       	std	Z+14, r24	; 0x0e
    3c60:	a0 91 60 06 	lds	r26, 0x0660
    3c64:	b0 91 61 06 	lds	r27, 0x0661
    3c68:	e9 81       	ldd	r30, Y+1	; 0x01
    3c6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c6c:	84 81       	ldd	r24, Z+4	; 0x04
    3c6e:	95 81       	ldd	r25, Z+5	; 0x05
    3c70:	51 96       	adiw	r26, 0x11	; 17
    3c72:	9c 93       	st	X, r25
    3c74:	8e 93       	st	-X, r24
    3c76:	50 97       	sbiw	r26, 0x10	; 16
    3c78:	e9 81       	ldd	r30, Y+1	; 0x01
    3c7a:	fa 81       	ldd	r31, Y+2	; 0x02
    3c7c:	04 80       	ldd	r0, Z+4	; 0x04
    3c7e:	f5 81       	ldd	r31, Z+5	; 0x05
    3c80:	e0 2d       	mov	r30, r0
    3c82:	80 91 60 06 	lds	r24, 0x0660
    3c86:	90 91 61 06 	lds	r25, 0x0661
    3c8a:	0c 96       	adiw	r24, 0x0c	; 12
    3c8c:	93 83       	std	Z+3, r25	; 0x03
    3c8e:	82 83       	std	Z+2, r24	; 0x02
    3c90:	80 91 60 06 	lds	r24, 0x0660
    3c94:	90 91 61 06 	lds	r25, 0x0661
    3c98:	0c 96       	adiw	r24, 0x0c	; 12
    3c9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c9e:	95 83       	std	Z+5, r25	; 0x05
    3ca0:	84 83       	std	Z+4, r24	; 0x04
    3ca2:	e0 91 60 06 	lds	r30, 0x0660
    3ca6:	f0 91 61 06 	lds	r31, 0x0661
    3caa:	8b 81       	ldd	r24, Y+3	; 0x03
    3cac:	9c 81       	ldd	r25, Y+4	; 0x04
    3cae:	95 8b       	std	Z+21, r25	; 0x15
    3cb0:	84 8b       	std	Z+20, r24	; 0x14
    3cb2:	eb 81       	ldd	r30, Y+3	; 0x03
    3cb4:	fc 81       	ldd	r31, Y+4	; 0x04
    3cb6:	80 81       	ld	r24, Z
    3cb8:	8f 5f       	subi	r24, 0xFF	; 255
    3cba:	eb 81       	ldd	r30, Y+3	; 0x03
    3cbc:	fc 81       	ldd	r31, Y+4	; 0x04
    3cbe:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3cc0:	8f 81       	ldd	r24, Y+7	; 0x07
    3cc2:	98 85       	ldd	r25, Y+8	; 0x08
    3cc4:	61 e0       	ldi	r22, 0x01	; 1
    3cc6:	0e 94 ce 29 	call	0x539c	; 0x539c <prvAddCurrentTaskToDelayedList>
}
    3cca:	28 96       	adiw	r28, 0x08	; 8
    3ccc:	0f b6       	in	r0, 0x3f	; 63
    3cce:	f8 94       	cli
    3cd0:	de bf       	out	0x3e, r29	; 62
    3cd2:	0f be       	out	0x3f, r0	; 63
    3cd4:	cd bf       	out	0x3d, r28	; 61
    3cd6:	cf 91       	pop	r28
    3cd8:	df 91       	pop	r29
    3cda:	08 95       	ret

00003cdc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3cdc:	df 93       	push	r29
    3cde:	cf 93       	push	r28
    3ce0:	cd b7       	in	r28, 0x3d	; 61
    3ce2:	de b7       	in	r29, 0x3e	; 62
    3ce4:	2d 97       	sbiw	r28, 0x0d	; 13
    3ce6:	0f b6       	in	r0, 0x3f	; 63
    3ce8:	f8 94       	cli
    3cea:	de bf       	out	0x3e, r29	; 62
    3cec:	0f be       	out	0x3f, r0	; 63
    3cee:	cd bf       	out	0x3d, r28	; 61
    3cf0:	9d 87       	std	Y+13, r25	; 0x0d
    3cf2:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3cf4:	ec 85       	ldd	r30, Y+12	; 0x0c
    3cf6:	fd 85       	ldd	r31, Y+13	; 0x0d
    3cf8:	05 80       	ldd	r0, Z+5	; 0x05
    3cfa:	f6 81       	ldd	r31, Z+6	; 0x06
    3cfc:	e0 2d       	mov	r30, r0
    3cfe:	86 81       	ldd	r24, Z+6	; 0x06
    3d00:	97 81       	ldd	r25, Z+7	; 0x07
    3d02:	9b 87       	std	Y+11, r25	; 0x0b
    3d04:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    3d06:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d08:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d0a:	84 89       	ldd	r24, Z+20	; 0x14
    3d0c:	95 89       	ldd	r25, Z+21	; 0x15
    3d0e:	98 87       	std	Y+8, r25	; 0x08
    3d10:	8f 83       	std	Y+7, r24	; 0x07
    3d12:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d14:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d16:	a6 85       	ldd	r26, Z+14	; 0x0e
    3d18:	b7 85       	ldd	r27, Z+15	; 0x0f
    3d1a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d1c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d1e:	80 89       	ldd	r24, Z+16	; 0x10
    3d20:	91 89       	ldd	r25, Z+17	; 0x11
    3d22:	15 96       	adiw	r26, 0x05	; 5
    3d24:	9c 93       	st	X, r25
    3d26:	8e 93       	st	-X, r24
    3d28:	14 97       	sbiw	r26, 0x04	; 4
    3d2a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d2c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d2e:	a0 89       	ldd	r26, Z+16	; 0x10
    3d30:	b1 89       	ldd	r27, Z+17	; 0x11
    3d32:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d34:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d36:	86 85       	ldd	r24, Z+14	; 0x0e
    3d38:	97 85       	ldd	r25, Z+15	; 0x0f
    3d3a:	13 96       	adiw	r26, 0x03	; 3
    3d3c:	9c 93       	st	X, r25
    3d3e:	8e 93       	st	-X, r24
    3d40:	12 97       	sbiw	r26, 0x02	; 2
    3d42:	ef 81       	ldd	r30, Y+7	; 0x07
    3d44:	f8 85       	ldd	r31, Y+8	; 0x08
    3d46:	21 81       	ldd	r18, Z+1	; 0x01
    3d48:	32 81       	ldd	r19, Z+2	; 0x02
    3d4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d4c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3d4e:	0c 96       	adiw	r24, 0x0c	; 12
    3d50:	28 17       	cp	r18, r24
    3d52:	39 07       	cpc	r19, r25
    3d54:	41 f4       	brne	.+16     	; 0x3d66 <xTaskRemoveFromEventList+0x8a>
    3d56:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d58:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d5a:	80 89       	ldd	r24, Z+16	; 0x10
    3d5c:	91 89       	ldd	r25, Z+17	; 0x11
    3d5e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d60:	f8 85       	ldd	r31, Y+8	; 0x08
    3d62:	92 83       	std	Z+2, r25	; 0x02
    3d64:	81 83       	std	Z+1, r24	; 0x01
    3d66:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d68:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d6a:	15 8a       	std	Z+21, r1	; 0x15
    3d6c:	14 8a       	std	Z+20, r1	; 0x14
    3d6e:	ef 81       	ldd	r30, Y+7	; 0x07
    3d70:	f8 85       	ldd	r31, Y+8	; 0x08
    3d72:	80 81       	ld	r24, Z
    3d74:	81 50       	subi	r24, 0x01	; 1
    3d76:	ef 81       	ldd	r30, Y+7	; 0x07
    3d78:	f8 85       	ldd	r31, Y+8	; 0x08
    3d7a:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3d7c:	80 91 71 06 	lds	r24, 0x0671
    3d80:	88 23       	and	r24, r24
    3d82:	09 f0       	breq	.+2      	; 0x3d86 <xTaskRemoveFromEventList+0xaa>
    3d84:	a4 c0       	rjmp	.+328    	; 0x3ece <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    3d86:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d88:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d8a:	82 85       	ldd	r24, Z+10	; 0x0a
    3d8c:	93 85       	ldd	r25, Z+11	; 0x0b
    3d8e:	9e 83       	std	Y+6, r25	; 0x06
    3d90:	8d 83       	std	Y+5, r24	; 0x05
    3d92:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d94:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d96:	a4 81       	ldd	r26, Z+4	; 0x04
    3d98:	b5 81       	ldd	r27, Z+5	; 0x05
    3d9a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3d9c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3d9e:	86 81       	ldd	r24, Z+6	; 0x06
    3da0:	97 81       	ldd	r25, Z+7	; 0x07
    3da2:	15 96       	adiw	r26, 0x05	; 5
    3da4:	9c 93       	st	X, r25
    3da6:	8e 93       	st	-X, r24
    3da8:	14 97       	sbiw	r26, 0x04	; 4
    3daa:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dac:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dae:	a6 81       	ldd	r26, Z+6	; 0x06
    3db0:	b7 81       	ldd	r27, Z+7	; 0x07
    3db2:	ea 85       	ldd	r30, Y+10	; 0x0a
    3db4:	fb 85       	ldd	r31, Y+11	; 0x0b
    3db6:	84 81       	ldd	r24, Z+4	; 0x04
    3db8:	95 81       	ldd	r25, Z+5	; 0x05
    3dba:	13 96       	adiw	r26, 0x03	; 3
    3dbc:	9c 93       	st	X, r25
    3dbe:	8e 93       	st	-X, r24
    3dc0:	12 97       	sbiw	r26, 0x02	; 2
    3dc2:	ed 81       	ldd	r30, Y+5	; 0x05
    3dc4:	fe 81       	ldd	r31, Y+6	; 0x06
    3dc6:	21 81       	ldd	r18, Z+1	; 0x01
    3dc8:	32 81       	ldd	r19, Z+2	; 0x02
    3dca:	8a 85       	ldd	r24, Y+10	; 0x0a
    3dcc:	9b 85       	ldd	r25, Y+11	; 0x0b
    3dce:	02 96       	adiw	r24, 0x02	; 2
    3dd0:	28 17       	cp	r18, r24
    3dd2:	39 07       	cpc	r19, r25
    3dd4:	41 f4       	brne	.+16     	; 0x3de6 <xTaskRemoveFromEventList+0x10a>
    3dd6:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dd8:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dda:	86 81       	ldd	r24, Z+6	; 0x06
    3ddc:	97 81       	ldd	r25, Z+7	; 0x07
    3dde:	ed 81       	ldd	r30, Y+5	; 0x05
    3de0:	fe 81       	ldd	r31, Y+6	; 0x06
    3de2:	92 83       	std	Z+2, r25	; 0x02
    3de4:	81 83       	std	Z+1, r24	; 0x01
    3de6:	ea 85       	ldd	r30, Y+10	; 0x0a
    3de8:	fb 85       	ldd	r31, Y+11	; 0x0b
    3dea:	13 86       	std	Z+11, r1	; 0x0b
    3dec:	12 86       	std	Z+10, r1	; 0x0a
    3dee:	ed 81       	ldd	r30, Y+5	; 0x05
    3df0:	fe 81       	ldd	r31, Y+6	; 0x06
    3df2:	80 81       	ld	r24, Z
    3df4:	81 50       	subi	r24, 0x01	; 1
    3df6:	ed 81       	ldd	r30, Y+5	; 0x05
    3df8:	fe 81       	ldd	r31, Y+6	; 0x06
    3dfa:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    3dfc:	ea 85       	ldd	r30, Y+10	; 0x0a
    3dfe:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e00:	96 89       	ldd	r25, Z+22	; 0x16
    3e02:	80 91 66 06 	lds	r24, 0x0666
    3e06:	89 17       	cp	r24, r25
    3e08:	28 f4       	brcc	.+10     	; 0x3e14 <xTaskRemoveFromEventList+0x138>
    3e0a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e0c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e0e:	86 89       	ldd	r24, Z+22	; 0x16
    3e10:	80 93 66 06 	sts	0x0666, r24
    3e14:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e16:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e18:	86 89       	ldd	r24, Z+22	; 0x16
    3e1a:	28 2f       	mov	r18, r24
    3e1c:	30 e0       	ldi	r19, 0x00	; 0
    3e1e:	c9 01       	movw	r24, r18
    3e20:	88 0f       	add	r24, r24
    3e22:	99 1f       	adc	r25, r25
    3e24:	88 0f       	add	r24, r24
    3e26:	99 1f       	adc	r25, r25
    3e28:	88 0f       	add	r24, r24
    3e2a:	99 1f       	adc	r25, r25
    3e2c:	82 0f       	add	r24, r18
    3e2e:	93 1f       	adc	r25, r19
    3e30:	fc 01       	movw	r30, r24
    3e32:	ee 58       	subi	r30, 0x8E	; 142
    3e34:	f9 4f       	sbci	r31, 0xF9	; 249
    3e36:	81 81       	ldd	r24, Z+1	; 0x01
    3e38:	92 81       	ldd	r25, Z+2	; 0x02
    3e3a:	9c 83       	std	Y+4, r25	; 0x04
    3e3c:	8b 83       	std	Y+3, r24	; 0x03
    3e3e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e40:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e42:	8b 81       	ldd	r24, Y+3	; 0x03
    3e44:	9c 81       	ldd	r25, Y+4	; 0x04
    3e46:	95 83       	std	Z+5, r25	; 0x05
    3e48:	84 83       	std	Z+4, r24	; 0x04
    3e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e4e:	84 81       	ldd	r24, Z+4	; 0x04
    3e50:	95 81       	ldd	r25, Z+5	; 0x05
    3e52:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e54:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e56:	97 83       	std	Z+7, r25	; 0x07
    3e58:	86 83       	std	Z+6, r24	; 0x06
    3e5a:	eb 81       	ldd	r30, Y+3	; 0x03
    3e5c:	fc 81       	ldd	r31, Y+4	; 0x04
    3e5e:	04 80       	ldd	r0, Z+4	; 0x04
    3e60:	f5 81       	ldd	r31, Z+5	; 0x05
    3e62:	e0 2d       	mov	r30, r0
    3e64:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e66:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e68:	02 96       	adiw	r24, 0x02	; 2
    3e6a:	93 83       	std	Z+3, r25	; 0x03
    3e6c:	82 83       	std	Z+2, r24	; 0x02
    3e6e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3e70:	9b 85       	ldd	r25, Y+11	; 0x0b
    3e72:	02 96       	adiw	r24, 0x02	; 2
    3e74:	eb 81       	ldd	r30, Y+3	; 0x03
    3e76:	fc 81       	ldd	r31, Y+4	; 0x04
    3e78:	95 83       	std	Z+5, r25	; 0x05
    3e7a:	84 83       	std	Z+4, r24	; 0x04
    3e7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3e80:	86 89       	ldd	r24, Z+22	; 0x16
    3e82:	28 2f       	mov	r18, r24
    3e84:	30 e0       	ldi	r19, 0x00	; 0
    3e86:	c9 01       	movw	r24, r18
    3e88:	88 0f       	add	r24, r24
    3e8a:	99 1f       	adc	r25, r25
    3e8c:	88 0f       	add	r24, r24
    3e8e:	99 1f       	adc	r25, r25
    3e90:	88 0f       	add	r24, r24
    3e92:	99 1f       	adc	r25, r25
    3e94:	82 0f       	add	r24, r18
    3e96:	93 1f       	adc	r25, r19
    3e98:	8e 58       	subi	r24, 0x8E	; 142
    3e9a:	99 4f       	sbci	r25, 0xF9	; 249
    3e9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3e9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ea0:	93 87       	std	Z+11, r25	; 0x0b
    3ea2:	82 87       	std	Z+10, r24	; 0x0a
    3ea4:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ea6:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ea8:	86 89       	ldd	r24, Z+22	; 0x16
    3eaa:	28 2f       	mov	r18, r24
    3eac:	30 e0       	ldi	r19, 0x00	; 0
    3eae:	c9 01       	movw	r24, r18
    3eb0:	88 0f       	add	r24, r24
    3eb2:	99 1f       	adc	r25, r25
    3eb4:	88 0f       	add	r24, r24
    3eb6:	99 1f       	adc	r25, r25
    3eb8:	88 0f       	add	r24, r24
    3eba:	99 1f       	adc	r25, r25
    3ebc:	82 0f       	add	r24, r18
    3ebe:	93 1f       	adc	r25, r19
    3ec0:	fc 01       	movw	r30, r24
    3ec2:	ee 58       	subi	r30, 0x8E	; 142
    3ec4:	f9 4f       	sbci	r31, 0xF9	; 249
    3ec6:	80 81       	ld	r24, Z
    3ec8:	8f 5f       	subi	r24, 0xFF	; 255
    3eca:	80 83       	st	Z, r24
    3ecc:	30 c0       	rjmp	.+96     	; 0x3f2e <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3ece:	80 91 ad 06 	lds	r24, 0x06AD
    3ed2:	90 91 ae 06 	lds	r25, 0x06AE
    3ed6:	9a 83       	std	Y+2, r25	; 0x02
    3ed8:	89 83       	std	Y+1, r24	; 0x01
    3eda:	ea 85       	ldd	r30, Y+10	; 0x0a
    3edc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ede:	89 81       	ldd	r24, Y+1	; 0x01
    3ee0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ee2:	97 87       	std	Z+15, r25	; 0x0f
    3ee4:	86 87       	std	Z+14, r24	; 0x0e
    3ee6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ee8:	fa 81       	ldd	r31, Y+2	; 0x02
    3eea:	84 81       	ldd	r24, Z+4	; 0x04
    3eec:	95 81       	ldd	r25, Z+5	; 0x05
    3eee:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ef0:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ef2:	91 8b       	std	Z+17, r25	; 0x11
    3ef4:	80 8b       	std	Z+16, r24	; 0x10
    3ef6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef8:	fa 81       	ldd	r31, Y+2	; 0x02
    3efa:	04 80       	ldd	r0, Z+4	; 0x04
    3efc:	f5 81       	ldd	r31, Z+5	; 0x05
    3efe:	e0 2d       	mov	r30, r0
    3f00:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f02:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f04:	0c 96       	adiw	r24, 0x0c	; 12
    3f06:	93 83       	std	Z+3, r25	; 0x03
    3f08:	82 83       	std	Z+2, r24	; 0x02
    3f0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f0e:	0c 96       	adiw	r24, 0x0c	; 12
    3f10:	e9 81       	ldd	r30, Y+1	; 0x01
    3f12:	fa 81       	ldd	r31, Y+2	; 0x02
    3f14:	95 83       	std	Z+5, r25	; 0x05
    3f16:	84 83       	std	Z+4, r24	; 0x04
    3f18:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f1a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f1c:	8c ea       	ldi	r24, 0xAC	; 172
    3f1e:	96 e0       	ldi	r25, 0x06	; 6
    3f20:	95 8b       	std	Z+21, r25	; 0x15
    3f22:	84 8b       	std	Z+20, r24	; 0x14
    3f24:	80 91 ac 06 	lds	r24, 0x06AC
    3f28:	8f 5f       	subi	r24, 0xFF	; 255
    3f2a:	80 93 ac 06 	sts	0x06AC, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3f2e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f30:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f32:	96 89       	ldd	r25, Z+22	; 0x16
    3f34:	e0 91 60 06 	lds	r30, 0x0660
    3f38:	f0 91 61 06 	lds	r31, 0x0661
    3f3c:	86 89       	ldd	r24, Z+22	; 0x16
    3f3e:	89 17       	cp	r24, r25
    3f40:	30 f4       	brcc	.+12     	; 0x3f4e <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    3f42:	81 e0       	ldi	r24, 0x01	; 1
    3f44:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    3f46:	81 e0       	ldi	r24, 0x01	; 1
    3f48:	80 93 6a 06 	sts	0x066A, r24
    3f4c:	01 c0       	rjmp	.+2      	; 0x3f50 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    3f4e:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    3f50:	89 85       	ldd	r24, Y+9	; 0x09
}
    3f52:	2d 96       	adiw	r28, 0x0d	; 13
    3f54:	0f b6       	in	r0, 0x3f	; 63
    3f56:	f8 94       	cli
    3f58:	de bf       	out	0x3e, r29	; 62
    3f5a:	0f be       	out	0x3f, r0	; 63
    3f5c:	cd bf       	out	0x3d, r28	; 61
    3f5e:	cf 91       	pop	r28
    3f60:	df 91       	pop	r29
    3f62:	08 95       	ret

00003f64 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    3f64:	df 93       	push	r29
    3f66:	cf 93       	push	r28
    3f68:	cd b7       	in	r28, 0x3d	; 61
    3f6a:	de b7       	in	r29, 0x3e	; 62
    3f6c:	2c 97       	sbiw	r28, 0x0c	; 12
    3f6e:	0f b6       	in	r0, 0x3f	; 63
    3f70:	f8 94       	cli
    3f72:	de bf       	out	0x3e, r29	; 62
    3f74:	0f be       	out	0x3f, r0	; 63
    3f76:	cd bf       	out	0x3d, r28	; 61
    3f78:	9a 87       	std	Y+10, r25	; 0x0a
    3f7a:	89 87       	std	Y+9, r24	; 0x09
    3f7c:	7c 87       	std	Y+12, r23	; 0x0c
    3f7e:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3f80:	8b 85       	ldd	r24, Y+11	; 0x0b
    3f82:	9c 85       	ldd	r25, Y+12	; 0x0c
    3f84:	90 68       	ori	r25, 0x80	; 128
    3f86:	e9 85       	ldd	r30, Y+9	; 0x09
    3f88:	fa 85       	ldd	r31, Y+10	; 0x0a
    3f8a:	91 83       	std	Z+1, r25	; 0x01
    3f8c:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3f8e:	e9 85       	ldd	r30, Y+9	; 0x09
    3f90:	fa 85       	ldd	r31, Y+10	; 0x0a
    3f92:	86 81       	ldd	r24, Z+6	; 0x06
    3f94:	97 81       	ldd	r25, Z+7	; 0x07
    3f96:	98 87       	std	Y+8, r25	; 0x08
    3f98:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    3f9a:	e9 85       	ldd	r30, Y+9	; 0x09
    3f9c:	fa 85       	ldd	r31, Y+10	; 0x0a
    3f9e:	80 85       	ldd	r24, Z+8	; 0x08
    3fa0:	91 85       	ldd	r25, Z+9	; 0x09
    3fa2:	9e 83       	std	Y+6, r25	; 0x06
    3fa4:	8d 83       	std	Y+5, r24	; 0x05
    3fa6:	e9 85       	ldd	r30, Y+9	; 0x09
    3fa8:	fa 85       	ldd	r31, Y+10	; 0x0a
    3faa:	a2 81       	ldd	r26, Z+2	; 0x02
    3fac:	b3 81       	ldd	r27, Z+3	; 0x03
    3fae:	e9 85       	ldd	r30, Y+9	; 0x09
    3fb0:	fa 85       	ldd	r31, Y+10	; 0x0a
    3fb2:	84 81       	ldd	r24, Z+4	; 0x04
    3fb4:	95 81       	ldd	r25, Z+5	; 0x05
    3fb6:	15 96       	adiw	r26, 0x05	; 5
    3fb8:	9c 93       	st	X, r25
    3fba:	8e 93       	st	-X, r24
    3fbc:	14 97       	sbiw	r26, 0x04	; 4
    3fbe:	e9 85       	ldd	r30, Y+9	; 0x09
    3fc0:	fa 85       	ldd	r31, Y+10	; 0x0a
    3fc2:	a4 81       	ldd	r26, Z+4	; 0x04
    3fc4:	b5 81       	ldd	r27, Z+5	; 0x05
    3fc6:	e9 85       	ldd	r30, Y+9	; 0x09
    3fc8:	fa 85       	ldd	r31, Y+10	; 0x0a
    3fca:	82 81       	ldd	r24, Z+2	; 0x02
    3fcc:	93 81       	ldd	r25, Z+3	; 0x03
    3fce:	13 96       	adiw	r26, 0x03	; 3
    3fd0:	9c 93       	st	X, r25
    3fd2:	8e 93       	st	-X, r24
    3fd4:	12 97       	sbiw	r26, 0x02	; 2
    3fd6:	ed 81       	ldd	r30, Y+5	; 0x05
    3fd8:	fe 81       	ldd	r31, Y+6	; 0x06
    3fda:	21 81       	ldd	r18, Z+1	; 0x01
    3fdc:	32 81       	ldd	r19, Z+2	; 0x02
    3fde:	89 85       	ldd	r24, Y+9	; 0x09
    3fe0:	9a 85       	ldd	r25, Y+10	; 0x0a
    3fe2:	28 17       	cp	r18, r24
    3fe4:	39 07       	cpc	r19, r25
    3fe6:	41 f4       	brne	.+16     	; 0x3ff8 <vTaskRemoveFromUnorderedEventList+0x94>
    3fe8:	e9 85       	ldd	r30, Y+9	; 0x09
    3fea:	fa 85       	ldd	r31, Y+10	; 0x0a
    3fec:	84 81       	ldd	r24, Z+4	; 0x04
    3fee:	95 81       	ldd	r25, Z+5	; 0x05
    3ff0:	ed 81       	ldd	r30, Y+5	; 0x05
    3ff2:	fe 81       	ldd	r31, Y+6	; 0x06
    3ff4:	92 83       	std	Z+2, r25	; 0x02
    3ff6:	81 83       	std	Z+1, r24	; 0x01
    3ff8:	e9 85       	ldd	r30, Y+9	; 0x09
    3ffa:	fa 85       	ldd	r31, Y+10	; 0x0a
    3ffc:	11 86       	std	Z+9, r1	; 0x09
    3ffe:	10 86       	std	Z+8, r1	; 0x08
    4000:	ed 81       	ldd	r30, Y+5	; 0x05
    4002:	fe 81       	ldd	r31, Y+6	; 0x06
    4004:	80 81       	ld	r24, Z
    4006:	81 50       	subi	r24, 0x01	; 1
    4008:	ed 81       	ldd	r30, Y+5	; 0x05
    400a:	fe 81       	ldd	r31, Y+6	; 0x06
    400c:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    400e:	ef 81       	ldd	r30, Y+7	; 0x07
    4010:	f8 85       	ldd	r31, Y+8	; 0x08
    4012:	82 85       	ldd	r24, Z+10	; 0x0a
    4014:	93 85       	ldd	r25, Z+11	; 0x0b
    4016:	9c 83       	std	Y+4, r25	; 0x04
    4018:	8b 83       	std	Y+3, r24	; 0x03
    401a:	ef 81       	ldd	r30, Y+7	; 0x07
    401c:	f8 85       	ldd	r31, Y+8	; 0x08
    401e:	a4 81       	ldd	r26, Z+4	; 0x04
    4020:	b5 81       	ldd	r27, Z+5	; 0x05
    4022:	ef 81       	ldd	r30, Y+7	; 0x07
    4024:	f8 85       	ldd	r31, Y+8	; 0x08
    4026:	86 81       	ldd	r24, Z+6	; 0x06
    4028:	97 81       	ldd	r25, Z+7	; 0x07
    402a:	15 96       	adiw	r26, 0x05	; 5
    402c:	9c 93       	st	X, r25
    402e:	8e 93       	st	-X, r24
    4030:	14 97       	sbiw	r26, 0x04	; 4
    4032:	ef 81       	ldd	r30, Y+7	; 0x07
    4034:	f8 85       	ldd	r31, Y+8	; 0x08
    4036:	a6 81       	ldd	r26, Z+6	; 0x06
    4038:	b7 81       	ldd	r27, Z+7	; 0x07
    403a:	ef 81       	ldd	r30, Y+7	; 0x07
    403c:	f8 85       	ldd	r31, Y+8	; 0x08
    403e:	84 81       	ldd	r24, Z+4	; 0x04
    4040:	95 81       	ldd	r25, Z+5	; 0x05
    4042:	13 96       	adiw	r26, 0x03	; 3
    4044:	9c 93       	st	X, r25
    4046:	8e 93       	st	-X, r24
    4048:	12 97       	sbiw	r26, 0x02	; 2
    404a:	eb 81       	ldd	r30, Y+3	; 0x03
    404c:	fc 81       	ldd	r31, Y+4	; 0x04
    404e:	21 81       	ldd	r18, Z+1	; 0x01
    4050:	32 81       	ldd	r19, Z+2	; 0x02
    4052:	8f 81       	ldd	r24, Y+7	; 0x07
    4054:	98 85       	ldd	r25, Y+8	; 0x08
    4056:	02 96       	adiw	r24, 0x02	; 2
    4058:	28 17       	cp	r18, r24
    405a:	39 07       	cpc	r19, r25
    405c:	41 f4       	brne	.+16     	; 0x406e <vTaskRemoveFromUnorderedEventList+0x10a>
    405e:	ef 81       	ldd	r30, Y+7	; 0x07
    4060:	f8 85       	ldd	r31, Y+8	; 0x08
    4062:	86 81       	ldd	r24, Z+6	; 0x06
    4064:	97 81       	ldd	r25, Z+7	; 0x07
    4066:	eb 81       	ldd	r30, Y+3	; 0x03
    4068:	fc 81       	ldd	r31, Y+4	; 0x04
    406a:	92 83       	std	Z+2, r25	; 0x02
    406c:	81 83       	std	Z+1, r24	; 0x01
    406e:	ef 81       	ldd	r30, Y+7	; 0x07
    4070:	f8 85       	ldd	r31, Y+8	; 0x08
    4072:	13 86       	std	Z+11, r1	; 0x0b
    4074:	12 86       	std	Z+10, r1	; 0x0a
    4076:	eb 81       	ldd	r30, Y+3	; 0x03
    4078:	fc 81       	ldd	r31, Y+4	; 0x04
    407a:	80 81       	ld	r24, Z
    407c:	81 50       	subi	r24, 0x01	; 1
    407e:	eb 81       	ldd	r30, Y+3	; 0x03
    4080:	fc 81       	ldd	r31, Y+4	; 0x04
    4082:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4084:	ef 81       	ldd	r30, Y+7	; 0x07
    4086:	f8 85       	ldd	r31, Y+8	; 0x08
    4088:	96 89       	ldd	r25, Z+22	; 0x16
    408a:	80 91 66 06 	lds	r24, 0x0666
    408e:	89 17       	cp	r24, r25
    4090:	28 f4       	brcc	.+10     	; 0x409c <vTaskRemoveFromUnorderedEventList+0x138>
    4092:	ef 81       	ldd	r30, Y+7	; 0x07
    4094:	f8 85       	ldd	r31, Y+8	; 0x08
    4096:	86 89       	ldd	r24, Z+22	; 0x16
    4098:	80 93 66 06 	sts	0x0666, r24
    409c:	ef 81       	ldd	r30, Y+7	; 0x07
    409e:	f8 85       	ldd	r31, Y+8	; 0x08
    40a0:	86 89       	ldd	r24, Z+22	; 0x16
    40a2:	28 2f       	mov	r18, r24
    40a4:	30 e0       	ldi	r19, 0x00	; 0
    40a6:	c9 01       	movw	r24, r18
    40a8:	88 0f       	add	r24, r24
    40aa:	99 1f       	adc	r25, r25
    40ac:	88 0f       	add	r24, r24
    40ae:	99 1f       	adc	r25, r25
    40b0:	88 0f       	add	r24, r24
    40b2:	99 1f       	adc	r25, r25
    40b4:	82 0f       	add	r24, r18
    40b6:	93 1f       	adc	r25, r19
    40b8:	fc 01       	movw	r30, r24
    40ba:	ee 58       	subi	r30, 0x8E	; 142
    40bc:	f9 4f       	sbci	r31, 0xF9	; 249
    40be:	81 81       	ldd	r24, Z+1	; 0x01
    40c0:	92 81       	ldd	r25, Z+2	; 0x02
    40c2:	9a 83       	std	Y+2, r25	; 0x02
    40c4:	89 83       	std	Y+1, r24	; 0x01
    40c6:	ef 81       	ldd	r30, Y+7	; 0x07
    40c8:	f8 85       	ldd	r31, Y+8	; 0x08
    40ca:	89 81       	ldd	r24, Y+1	; 0x01
    40cc:	9a 81       	ldd	r25, Y+2	; 0x02
    40ce:	95 83       	std	Z+5, r25	; 0x05
    40d0:	84 83       	std	Z+4, r24	; 0x04
    40d2:	e9 81       	ldd	r30, Y+1	; 0x01
    40d4:	fa 81       	ldd	r31, Y+2	; 0x02
    40d6:	84 81       	ldd	r24, Z+4	; 0x04
    40d8:	95 81       	ldd	r25, Z+5	; 0x05
    40da:	ef 81       	ldd	r30, Y+7	; 0x07
    40dc:	f8 85       	ldd	r31, Y+8	; 0x08
    40de:	97 83       	std	Z+7, r25	; 0x07
    40e0:	86 83       	std	Z+6, r24	; 0x06
    40e2:	e9 81       	ldd	r30, Y+1	; 0x01
    40e4:	fa 81       	ldd	r31, Y+2	; 0x02
    40e6:	04 80       	ldd	r0, Z+4	; 0x04
    40e8:	f5 81       	ldd	r31, Z+5	; 0x05
    40ea:	e0 2d       	mov	r30, r0
    40ec:	8f 81       	ldd	r24, Y+7	; 0x07
    40ee:	98 85       	ldd	r25, Y+8	; 0x08
    40f0:	02 96       	adiw	r24, 0x02	; 2
    40f2:	93 83       	std	Z+3, r25	; 0x03
    40f4:	82 83       	std	Z+2, r24	; 0x02
    40f6:	8f 81       	ldd	r24, Y+7	; 0x07
    40f8:	98 85       	ldd	r25, Y+8	; 0x08
    40fa:	02 96       	adiw	r24, 0x02	; 2
    40fc:	e9 81       	ldd	r30, Y+1	; 0x01
    40fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4100:	95 83       	std	Z+5, r25	; 0x05
    4102:	84 83       	std	Z+4, r24	; 0x04
    4104:	ef 81       	ldd	r30, Y+7	; 0x07
    4106:	f8 85       	ldd	r31, Y+8	; 0x08
    4108:	86 89       	ldd	r24, Z+22	; 0x16
    410a:	28 2f       	mov	r18, r24
    410c:	30 e0       	ldi	r19, 0x00	; 0
    410e:	c9 01       	movw	r24, r18
    4110:	88 0f       	add	r24, r24
    4112:	99 1f       	adc	r25, r25
    4114:	88 0f       	add	r24, r24
    4116:	99 1f       	adc	r25, r25
    4118:	88 0f       	add	r24, r24
    411a:	99 1f       	adc	r25, r25
    411c:	82 0f       	add	r24, r18
    411e:	93 1f       	adc	r25, r19
    4120:	8e 58       	subi	r24, 0x8E	; 142
    4122:	99 4f       	sbci	r25, 0xF9	; 249
    4124:	ef 81       	ldd	r30, Y+7	; 0x07
    4126:	f8 85       	ldd	r31, Y+8	; 0x08
    4128:	93 87       	std	Z+11, r25	; 0x0b
    412a:	82 87       	std	Z+10, r24	; 0x0a
    412c:	ef 81       	ldd	r30, Y+7	; 0x07
    412e:	f8 85       	ldd	r31, Y+8	; 0x08
    4130:	86 89       	ldd	r24, Z+22	; 0x16
    4132:	28 2f       	mov	r18, r24
    4134:	30 e0       	ldi	r19, 0x00	; 0
    4136:	c9 01       	movw	r24, r18
    4138:	88 0f       	add	r24, r24
    413a:	99 1f       	adc	r25, r25
    413c:	88 0f       	add	r24, r24
    413e:	99 1f       	adc	r25, r25
    4140:	88 0f       	add	r24, r24
    4142:	99 1f       	adc	r25, r25
    4144:	82 0f       	add	r24, r18
    4146:	93 1f       	adc	r25, r19
    4148:	fc 01       	movw	r30, r24
    414a:	ee 58       	subi	r30, 0x8E	; 142
    414c:	f9 4f       	sbci	r31, 0xF9	; 249
    414e:	80 81       	ld	r24, Z
    4150:	8f 5f       	subi	r24, 0xFF	; 255
    4152:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4154:	ef 81       	ldd	r30, Y+7	; 0x07
    4156:	f8 85       	ldd	r31, Y+8	; 0x08
    4158:	96 89       	ldd	r25, Z+22	; 0x16
    415a:	e0 91 60 06 	lds	r30, 0x0660
    415e:	f0 91 61 06 	lds	r31, 0x0661
    4162:	86 89       	ldd	r24, Z+22	; 0x16
    4164:	89 17       	cp	r24, r25
    4166:	18 f4       	brcc	.+6      	; 0x416e <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4168:	81 e0       	ldi	r24, 0x01	; 1
    416a:	80 93 6a 06 	sts	0x066A, r24
    }
}
    416e:	2c 96       	adiw	r28, 0x0c	; 12
    4170:	0f b6       	in	r0, 0x3f	; 63
    4172:	f8 94       	cli
    4174:	de bf       	out	0x3e, r29	; 62
    4176:	0f be       	out	0x3f, r0	; 63
    4178:	cd bf       	out	0x3d, r28	; 61
    417a:	cf 91       	pop	r28
    417c:	df 91       	pop	r29
    417e:	08 95       	ret

00004180 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4180:	df 93       	push	r29
    4182:	cf 93       	push	r28
    4184:	00 d0       	rcall	.+0      	; 0x4186 <vTaskSetTimeOutState+0x6>
    4186:	cd b7       	in	r28, 0x3d	; 61
    4188:	de b7       	in	r29, 0x3e	; 62
    418a:	9a 83       	std	Y+2, r25	; 0x02
    418c:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    418e:	0f b6       	in	r0, 0x3f	; 63
    4190:	f8 94       	cli
    4192:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4194:	80 91 6b 06 	lds	r24, 0x066B
    4198:	e9 81       	ldd	r30, Y+1	; 0x01
    419a:	fa 81       	ldd	r31, Y+2	; 0x02
    419c:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    419e:	80 91 64 06 	lds	r24, 0x0664
    41a2:	90 91 65 06 	lds	r25, 0x0665
    41a6:	e9 81       	ldd	r30, Y+1	; 0x01
    41a8:	fa 81       	ldd	r31, Y+2	; 0x02
    41aa:	92 83       	std	Z+2, r25	; 0x02
    41ac:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    41ae:	0f 90       	pop	r0
    41b0:	0f be       	out	0x3f, r0	; 63
}
    41b2:	0f 90       	pop	r0
    41b4:	0f 90       	pop	r0
    41b6:	cf 91       	pop	r28
    41b8:	df 91       	pop	r29
    41ba:	08 95       	ret

000041bc <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    41bc:	df 93       	push	r29
    41be:	cf 93       	push	r28
    41c0:	00 d0       	rcall	.+0      	; 0x41c2 <vTaskInternalSetTimeOutState+0x6>
    41c2:	cd b7       	in	r28, 0x3d	; 61
    41c4:	de b7       	in	r29, 0x3e	; 62
    41c6:	9a 83       	std	Y+2, r25	; 0x02
    41c8:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    41ca:	80 91 6b 06 	lds	r24, 0x066B
    41ce:	e9 81       	ldd	r30, Y+1	; 0x01
    41d0:	fa 81       	ldd	r31, Y+2	; 0x02
    41d2:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    41d4:	80 91 64 06 	lds	r24, 0x0664
    41d8:	90 91 65 06 	lds	r25, 0x0665
    41dc:	e9 81       	ldd	r30, Y+1	; 0x01
    41de:	fa 81       	ldd	r31, Y+2	; 0x02
    41e0:	92 83       	std	Z+2, r25	; 0x02
    41e2:	81 83       	std	Z+1, r24	; 0x01
}
    41e4:	0f 90       	pop	r0
    41e6:	0f 90       	pop	r0
    41e8:	cf 91       	pop	r28
    41ea:	df 91       	pop	r29
    41ec:	08 95       	ret

000041ee <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    41ee:	df 93       	push	r29
    41f0:	cf 93       	push	r28
    41f2:	cd b7       	in	r28, 0x3d	; 61
    41f4:	de b7       	in	r29, 0x3e	; 62
    41f6:	29 97       	sbiw	r28, 0x09	; 9
    41f8:	0f b6       	in	r0, 0x3f	; 63
    41fa:	f8 94       	cli
    41fc:	de bf       	out	0x3e, r29	; 62
    41fe:	0f be       	out	0x3f, r0	; 63
    4200:	cd bf       	out	0x3d, r28	; 61
    4202:	9f 83       	std	Y+7, r25	; 0x07
    4204:	8e 83       	std	Y+6, r24	; 0x06
    4206:	79 87       	std	Y+9, r23	; 0x09
    4208:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    420a:	0f b6       	in	r0, 0x3f	; 63
    420c:	f8 94       	cli
    420e:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4210:	80 91 64 06 	lds	r24, 0x0664
    4214:	90 91 65 06 	lds	r25, 0x0665
    4218:	9c 83       	std	Y+4, r25	; 0x04
    421a:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    421c:	ee 81       	ldd	r30, Y+6	; 0x06
    421e:	ff 81       	ldd	r31, Y+7	; 0x07
    4220:	21 81       	ldd	r18, Z+1	; 0x01
    4222:	32 81       	ldd	r19, Z+2	; 0x02
    4224:	8b 81       	ldd	r24, Y+3	; 0x03
    4226:	9c 81       	ldd	r25, Y+4	; 0x04
    4228:	82 1b       	sub	r24, r18
    422a:	93 0b       	sbc	r25, r19
    422c:	9a 83       	std	Y+2, r25	; 0x02
    422e:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4230:	ee 81       	ldd	r30, Y+6	; 0x06
    4232:	ff 81       	ldd	r31, Y+7	; 0x07
    4234:	90 81       	ld	r25, Z
    4236:	80 91 6b 06 	lds	r24, 0x066B
    423a:	98 17       	cp	r25, r24
    423c:	81 f0       	breq	.+32     	; 0x425e <xTaskCheckForTimeOut+0x70>
    423e:	ee 81       	ldd	r30, Y+6	; 0x06
    4240:	ff 81       	ldd	r31, Y+7	; 0x07
    4242:	21 81       	ldd	r18, Z+1	; 0x01
    4244:	32 81       	ldd	r19, Z+2	; 0x02
    4246:	8b 81       	ldd	r24, Y+3	; 0x03
    4248:	9c 81       	ldd	r25, Y+4	; 0x04
    424a:	82 17       	cp	r24, r18
    424c:	93 07       	cpc	r25, r19
    424e:	38 f0       	brcs	.+14     	; 0x425e <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4250:	81 e0       	ldi	r24, 0x01	; 1
    4252:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    4254:	e8 85       	ldd	r30, Y+8	; 0x08
    4256:	f9 85       	ldd	r31, Y+9	; 0x09
    4258:	11 82       	std	Z+1, r1	; 0x01
    425a:	10 82       	st	Z, r1
    425c:	23 c0       	rjmp	.+70     	; 0x42a4 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    425e:	e8 85       	ldd	r30, Y+8	; 0x08
    4260:	f9 85       	ldd	r31, Y+9	; 0x09
    4262:	20 81       	ld	r18, Z
    4264:	31 81       	ldd	r19, Z+1	; 0x01
    4266:	89 81       	ldd	r24, Y+1	; 0x01
    4268:	9a 81       	ldd	r25, Y+2	; 0x02
    426a:	82 17       	cp	r24, r18
    426c:	93 07       	cpc	r25, r19
    426e:	a0 f4       	brcc	.+40     	; 0x4298 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4270:	e8 85       	ldd	r30, Y+8	; 0x08
    4272:	f9 85       	ldd	r31, Y+9	; 0x09
    4274:	20 81       	ld	r18, Z
    4276:	31 81       	ldd	r19, Z+1	; 0x01
    4278:	89 81       	ldd	r24, Y+1	; 0x01
    427a:	9a 81       	ldd	r25, Y+2	; 0x02
    427c:	a9 01       	movw	r20, r18
    427e:	48 1b       	sub	r20, r24
    4280:	59 0b       	sbc	r21, r25
    4282:	ca 01       	movw	r24, r20
    4284:	e8 85       	ldd	r30, Y+8	; 0x08
    4286:	f9 85       	ldd	r31, Y+9	; 0x09
    4288:	91 83       	std	Z+1, r25	; 0x01
    428a:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    428c:	8e 81       	ldd	r24, Y+6	; 0x06
    428e:	9f 81       	ldd	r25, Y+7	; 0x07
    4290:	0e 94 de 20 	call	0x41bc	; 0x41bc <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    4294:	1d 82       	std	Y+5, r1	; 0x05
    4296:	06 c0       	rjmp	.+12     	; 0x42a4 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4298:	e8 85       	ldd	r30, Y+8	; 0x08
    429a:	f9 85       	ldd	r31, Y+9	; 0x09
    429c:	11 82       	std	Z+1, r1	; 0x01
    429e:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    42a0:	81 e0       	ldi	r24, 0x01	; 1
    42a2:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    42a4:	0f 90       	pop	r0
    42a6:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    42a8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    42aa:	29 96       	adiw	r28, 0x09	; 9
    42ac:	0f b6       	in	r0, 0x3f	; 63
    42ae:	f8 94       	cli
    42b0:	de bf       	out	0x3e, r29	; 62
    42b2:	0f be       	out	0x3f, r0	; 63
    42b4:	cd bf       	out	0x3d, r28	; 61
    42b6:	cf 91       	pop	r28
    42b8:	df 91       	pop	r29
    42ba:	08 95       	ret

000042bc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    42bc:	df 93       	push	r29
    42be:	cf 93       	push	r28
    42c0:	cd b7       	in	r28, 0x3d	; 61
    42c2:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    42c4:	81 e0       	ldi	r24, 0x01	; 1
    42c6:	80 93 6a 06 	sts	0x066A, r24
}
    42ca:	cf 91       	pop	r28
    42cc:	df 91       	pop	r29
    42ce:	08 95       	ret

000042d0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    42d0:	df 93       	push	r29
    42d2:	cf 93       	push	r28
    42d4:	00 d0       	rcall	.+0      	; 0x42d6 <prvIdleTask+0x6>
    42d6:	cd b7       	in	r28, 0x3d	; 61
    42d8:	de b7       	in	r29, 0x3e	; 62
    42da:	9a 83       	std	Y+2, r25	; 0x02
    42dc:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    42de:	0e 94 b1 21 	call	0x4362	; 0x4362 <prvCheckTasksWaitingTermination>
            {
                /* If we are not using preemption we keep forcing a task switch to
                 * see if any other task has become available.  If we are using
                 * preemption we don't need to do this as any task becoming available
                 * will automatically get the processor anyway. */
                taskYIELD();
    42e2:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>
    42e6:	fb cf       	rjmp	.-10     	; 0x42de <prvIdleTask+0xe>

000042e8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    42e8:	df 93       	push	r29
    42ea:	cf 93       	push	r28
    42ec:	0f 92       	push	r0
    42ee:	cd b7       	in	r28, 0x3d	; 61
    42f0:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    42f2:	19 82       	std	Y+1, r1	; 0x01
    42f4:	13 c0       	rjmp	.+38     	; 0x431c <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    42f6:	89 81       	ldd	r24, Y+1	; 0x01
    42f8:	28 2f       	mov	r18, r24
    42fa:	30 e0       	ldi	r19, 0x00	; 0
    42fc:	c9 01       	movw	r24, r18
    42fe:	88 0f       	add	r24, r24
    4300:	99 1f       	adc	r25, r25
    4302:	88 0f       	add	r24, r24
    4304:	99 1f       	adc	r25, r25
    4306:	88 0f       	add	r24, r24
    4308:	99 1f       	adc	r25, r25
    430a:	82 0f       	add	r24, r18
    430c:	93 1f       	adc	r25, r19
    430e:	8e 58       	subi	r24, 0x8E	; 142
    4310:	99 4f       	sbci	r25, 0xF9	; 249
    4312:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4316:	89 81       	ldd	r24, Y+1	; 0x01
    4318:	8f 5f       	subi	r24, 0xFF	; 255
    431a:	89 83       	std	Y+1, r24	; 0x01
    431c:	89 81       	ldd	r24, Y+1	; 0x01
    431e:	84 30       	cpi	r24, 0x04	; 4
    4320:	50 f3       	brcs	.-44     	; 0x42f6 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4322:	86 e9       	ldi	r24, 0x96	; 150
    4324:	96 e0       	ldi	r25, 0x06	; 6
    4326:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    432a:	8f e9       	ldi	r24, 0x9F	; 159
    432c:	96 e0       	ldi	r25, 0x06	; 6
    432e:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4332:	8c ea       	ldi	r24, 0xAC	; 172
    4334:	96 e0       	ldi	r25, 0x06	; 6
    4336:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    433a:	85 eb       	ldi	r24, 0xB5	; 181
    433c:	96 e0       	ldi	r25, 0x06	; 6
    433e:	0e 94 57 04 	call	0x8ae	; 0x8ae <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4342:	86 e9       	ldi	r24, 0x96	; 150
    4344:	96 e0       	ldi	r25, 0x06	; 6
    4346:	90 93 a9 06 	sts	0x06A9, r25
    434a:	80 93 a8 06 	sts	0x06A8, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    434e:	8f e9       	ldi	r24, 0x9F	; 159
    4350:	96 e0       	ldi	r25, 0x06	; 6
    4352:	90 93 ab 06 	sts	0x06AB, r25
    4356:	80 93 aa 06 	sts	0x06AA, r24
}
    435a:	0f 90       	pop	r0
    435c:	cf 91       	pop	r28
    435e:	df 91       	pop	r29
    4360:	08 95       	ret

00004362 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4362:	df 93       	push	r29
    4364:	cf 93       	push	r28
    4366:	00 d0       	rcall	.+0      	; 0x4368 <prvCheckTasksWaitingTermination+0x6>
    4368:	cd b7       	in	r28, 0x3d	; 61
    436a:	de b7       	in	r29, 0x3e	; 62
    436c:	20 c0       	rjmp	.+64     	; 0x43ae <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    436e:	0f b6       	in	r0, 0x3f	; 63
    4370:	f8 94       	cli
    4372:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4374:	e0 91 ba 06 	lds	r30, 0x06BA
    4378:	f0 91 bb 06 	lds	r31, 0x06BB
    437c:	86 81       	ldd	r24, Z+6	; 0x06
    437e:	97 81       	ldd	r25, Z+7	; 0x07
    4380:	9a 83       	std	Y+2, r25	; 0x02
    4382:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4384:	89 81       	ldd	r24, Y+1	; 0x01
    4386:	9a 81       	ldd	r25, Y+2	; 0x02
    4388:	02 96       	adiw	r24, 0x02	; 2
    438a:	0e 94 41 05 	call	0xa82	; 0xa82 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    438e:	80 91 63 06 	lds	r24, 0x0663
    4392:	81 50       	subi	r24, 0x01	; 1
    4394:	80 93 63 06 	sts	0x0663, r24
                    --uxDeletedTasksWaitingCleanUp;
    4398:	80 91 62 06 	lds	r24, 0x0662
    439c:	81 50       	subi	r24, 0x01	; 1
    439e:	80 93 62 06 	sts	0x0662, r24
                }
                taskEXIT_CRITICAL();
    43a2:	0f 90       	pop	r0
    43a4:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    43a6:	89 81       	ldd	r24, Y+1	; 0x01
    43a8:	9a 81       	ldd	r25, Y+2	; 0x02
    43aa:	0e 94 e0 21 	call	0x43c0	; 0x43c0 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    43ae:	80 91 62 06 	lds	r24, 0x0662
    43b2:	88 23       	and	r24, r24
    43b4:	e1 f6       	brne	.-72     	; 0x436e <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    43b6:	0f 90       	pop	r0
    43b8:	0f 90       	pop	r0
    43ba:	cf 91       	pop	r28
    43bc:	df 91       	pop	r29
    43be:	08 95       	ret

000043c0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    43c0:	df 93       	push	r29
    43c2:	cf 93       	push	r28
    43c4:	00 d0       	rcall	.+0      	; 0x43c6 <prvDeleteTCB+0x6>
    43c6:	cd b7       	in	r28, 0x3d	; 61
    43c8:	de b7       	in	r29, 0x3e	; 62
    43ca:	9a 83       	std	Y+2, r25	; 0x02
    43cc:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    43ce:	e9 81       	ldd	r30, Y+1	; 0x01
    43d0:	fa 81       	ldd	r31, Y+2	; 0x02
    43d2:	87 89       	ldd	r24, Z+23	; 0x17
    43d4:	90 8d       	ldd	r25, Z+24	; 0x18
    43d6:	0e 94 31 04 	call	0x862	; 0x862 <vPortFree>
                vPortFree( pxTCB );
    43da:	89 81       	ldd	r24, Y+1	; 0x01
    43dc:	9a 81       	ldd	r25, Y+2	; 0x02
    43de:	0e 94 31 04 	call	0x862	; 0x862 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    43e2:	0f 90       	pop	r0
    43e4:	0f 90       	pop	r0
    43e6:	cf 91       	pop	r28
    43e8:	df 91       	pop	r29
    43ea:	08 95       	ret

000043ec <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    43ec:	df 93       	push	r29
    43ee:	cf 93       	push	r28
    43f0:	cd b7       	in	r28, 0x3d	; 61
    43f2:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    43f4:	e0 91 a8 06 	lds	r30, 0x06A8
    43f8:	f0 91 a9 06 	lds	r31, 0x06A9
    43fc:	80 81       	ld	r24, Z
    43fe:	88 23       	and	r24, r24
    4400:	39 f4       	brne	.+14     	; 0x4410 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4402:	8f ef       	ldi	r24, 0xFF	; 255
    4404:	9f ef       	ldi	r25, 0xFF	; 255
    4406:	90 93 6e 06 	sts	0x066E, r25
    440a:	80 93 6d 06 	sts	0x066D, r24
    440e:	0d c0       	rjmp	.+26     	; 0x442a <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4410:	e0 91 a8 06 	lds	r30, 0x06A8
    4414:	f0 91 a9 06 	lds	r31, 0x06A9
    4418:	05 80       	ldd	r0, Z+5	; 0x05
    441a:	f6 81       	ldd	r31, Z+6	; 0x06
    441c:	e0 2d       	mov	r30, r0
    441e:	80 81       	ld	r24, Z
    4420:	91 81       	ldd	r25, Z+1	; 0x01
    4422:	90 93 6e 06 	sts	0x066E, r25
    4426:	80 93 6d 06 	sts	0x066D, r24
    }
}
    442a:	cf 91       	pop	r28
    442c:	df 91       	pop	r29
    442e:	08 95       	ret

00004430 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

    TaskHandle_t xTaskGetCurrentTaskHandle( void )
    {
    4430:	df 93       	push	r29
    4432:	cf 93       	push	r28
    4434:	00 d0       	rcall	.+0      	; 0x4436 <xTaskGetCurrentTaskHandle+0x6>
    4436:	cd b7       	in	r28, 0x3d	; 61
    4438:	de b7       	in	r29, 0x3e	; 62
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    443a:	80 91 60 06 	lds	r24, 0x0660
    443e:	90 91 61 06 	lds	r25, 0x0661
    4442:	9a 83       	std	Y+2, r25	; 0x02
    4444:	89 83       	std	Y+1, r24	; 0x01

        return xReturn;
    4446:	89 81       	ldd	r24, Y+1	; 0x01
    4448:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    444a:	0f 90       	pop	r0
    444c:	0f 90       	pop	r0
    444e:	cf 91       	pop	r28
    4450:	df 91       	pop	r29
    4452:	08 95       	ret

00004454 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4454:	df 93       	push	r29
    4456:	cf 93       	push	r28
    4458:	00 d0       	rcall	.+0      	; 0x445a <uxTaskResetEventItemValue+0x6>
    445a:	cd b7       	in	r28, 0x3d	; 61
    445c:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    445e:	e0 91 60 06 	lds	r30, 0x0660
    4462:	f0 91 61 06 	lds	r31, 0x0661
    4466:	84 85       	ldd	r24, Z+12	; 0x0c
    4468:	95 85       	ldd	r25, Z+13	; 0x0d
    446a:	9a 83       	std	Y+2, r25	; 0x02
    446c:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    446e:	a0 91 60 06 	lds	r26, 0x0660
    4472:	b0 91 61 06 	lds	r27, 0x0661
    4476:	e0 91 60 06 	lds	r30, 0x0660
    447a:	f0 91 61 06 	lds	r31, 0x0661
    447e:	86 89       	ldd	r24, Z+22	; 0x16
    4480:	28 2f       	mov	r18, r24
    4482:	30 e0       	ldi	r19, 0x00	; 0
    4484:	84 e0       	ldi	r24, 0x04	; 4
    4486:	90 e0       	ldi	r25, 0x00	; 0
    4488:	82 1b       	sub	r24, r18
    448a:	93 0b       	sbc	r25, r19
    448c:	1d 96       	adiw	r26, 0x0d	; 13
    448e:	9c 93       	st	X, r25
    4490:	8e 93       	st	-X, r24
    4492:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4494:	89 81       	ldd	r24, Y+1	; 0x01
    4496:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4498:	0f 90       	pop	r0
    449a:	0f 90       	pop	r0
    449c:	cf 91       	pop	r28
    449e:	df 91       	pop	r29
    44a0:	08 95       	ret

000044a2 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    44a2:	df 93       	push	r29
    44a4:	cf 93       	push	r28
    44a6:	cd b7       	in	r28, 0x3d	; 61
    44a8:	de b7       	in	r29, 0x3e	; 62
    44aa:	28 97       	sbiw	r28, 0x08	; 8
    44ac:	0f b6       	in	r0, 0x3f	; 63
    44ae:	f8 94       	cli
    44b0:	de bf       	out	0x3e, r29	; 62
    44b2:	0f be       	out	0x3f, r0	; 63
    44b4:	cd bf       	out	0x3d, r28	; 61
    44b6:	8d 83       	std	Y+5, r24	; 0x05
    44b8:	6e 83       	std	Y+6, r22	; 0x06
    44ba:	58 87       	std	Y+8, r21	; 0x08
    44bc:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    44be:	0f b6       	in	r0, 0x3f	; 63
    44c0:	f8 94       	cli
    44c2:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    44c4:	20 91 60 06 	lds	r18, 0x0660
    44c8:	30 91 61 06 	lds	r19, 0x0661
    44cc:	8d 81       	ldd	r24, Y+5	; 0x05
    44ce:	88 2f       	mov	r24, r24
    44d0:	90 e0       	ldi	r25, 0x00	; 0
    44d2:	88 0f       	add	r24, r24
    44d4:	99 1f       	adc	r25, r25
    44d6:	88 0f       	add	r24, r24
    44d8:	99 1f       	adc	r25, r25
    44da:	82 0f       	add	r24, r18
    44dc:	93 1f       	adc	r25, r19
    44de:	fc 01       	movw	r30, r24
    44e0:	b1 96       	adiw	r30, 0x21	; 33
    44e2:	80 81       	ld	r24, Z
    44e4:	91 81       	ldd	r25, Z+1	; 0x01
    44e6:	a2 81       	ldd	r26, Z+2	; 0x02
    44e8:	b3 81       	ldd	r27, Z+3	; 0x03
    44ea:	00 97       	sbiw	r24, 0x00	; 0
    44ec:	a1 05       	cpc	r26, r1
    44ee:	b1 05       	cpc	r27, r1
    44f0:	c1 f4       	brne	.+48     	; 0x4522 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    44f2:	20 91 60 06 	lds	r18, 0x0660
    44f6:	30 91 61 06 	lds	r19, 0x0661
    44fa:	8d 81       	ldd	r24, Y+5	; 0x05
    44fc:	88 2f       	mov	r24, r24
    44fe:	90 e0       	ldi	r25, 0x00	; 0
    4500:	82 0f       	add	r24, r18
    4502:	93 1f       	adc	r25, r19
    4504:	fc 01       	movw	r30, r24
    4506:	b5 96       	adiw	r30, 0x25	; 37
    4508:	81 e0       	ldi	r24, 0x01	; 1
    450a:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    450c:	8f 81       	ldd	r24, Y+7	; 0x07
    450e:	98 85       	ldd	r25, Y+8	; 0x08
    4510:	00 97       	sbiw	r24, 0x00	; 0
    4512:	39 f0       	breq	.+14     	; 0x4522 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4514:	8f 81       	ldd	r24, Y+7	; 0x07
    4516:	98 85       	ldd	r25, Y+8	; 0x08
    4518:	61 e0       	ldi	r22, 0x01	; 1
    451a:	0e 94 ce 29 	call	0x539c	; 0x539c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    451e:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4522:	0f 90       	pop	r0
    4524:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4526:	0f b6       	in	r0, 0x3f	; 63
    4528:	f8 94       	cli
    452a:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    452c:	20 91 60 06 	lds	r18, 0x0660
    4530:	30 91 61 06 	lds	r19, 0x0661
    4534:	8d 81       	ldd	r24, Y+5	; 0x05
    4536:	88 2f       	mov	r24, r24
    4538:	90 e0       	ldi	r25, 0x00	; 0
    453a:	88 0f       	add	r24, r24
    453c:	99 1f       	adc	r25, r25
    453e:	88 0f       	add	r24, r24
    4540:	99 1f       	adc	r25, r25
    4542:	82 0f       	add	r24, r18
    4544:	93 1f       	adc	r25, r19
    4546:	fc 01       	movw	r30, r24
    4548:	b1 96       	adiw	r30, 0x21	; 33
    454a:	80 81       	ld	r24, Z
    454c:	91 81       	ldd	r25, Z+1	; 0x01
    454e:	a2 81       	ldd	r26, Z+2	; 0x02
    4550:	b3 81       	ldd	r27, Z+3	; 0x03
    4552:	89 83       	std	Y+1, r24	; 0x01
    4554:	9a 83       	std	Y+2, r25	; 0x02
    4556:	ab 83       	std	Y+3, r26	; 0x03
    4558:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    455a:	89 81       	ldd	r24, Y+1	; 0x01
    455c:	9a 81       	ldd	r25, Y+2	; 0x02
    455e:	ab 81       	ldd	r26, Y+3	; 0x03
    4560:	bc 81       	ldd	r27, Y+4	; 0x04
    4562:	00 97       	sbiw	r24, 0x00	; 0
    4564:	a1 05       	cpc	r26, r1
    4566:	b1 05       	cpc	r27, r1
    4568:	a9 f1       	breq	.+106    	; 0x45d4 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    456a:	8e 81       	ldd	r24, Y+6	; 0x06
    456c:	88 23       	and	r24, r24
    456e:	a1 f0       	breq	.+40     	; 0x4598 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4570:	20 91 60 06 	lds	r18, 0x0660
    4574:	30 91 61 06 	lds	r19, 0x0661
    4578:	8d 81       	ldd	r24, Y+5	; 0x05
    457a:	88 2f       	mov	r24, r24
    457c:	90 e0       	ldi	r25, 0x00	; 0
    457e:	88 0f       	add	r24, r24
    4580:	99 1f       	adc	r25, r25
    4582:	88 0f       	add	r24, r24
    4584:	99 1f       	adc	r25, r25
    4586:	82 0f       	add	r24, r18
    4588:	93 1f       	adc	r25, r19
    458a:	fc 01       	movw	r30, r24
    458c:	b1 96       	adiw	r30, 0x21	; 33
    458e:	10 82       	st	Z, r1
    4590:	11 82       	std	Z+1, r1	; 0x01
    4592:	12 82       	std	Z+2, r1	; 0x02
    4594:	13 82       	std	Z+3, r1	; 0x03
    4596:	1e c0       	rjmp	.+60     	; 0x45d4 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4598:	e0 91 60 06 	lds	r30, 0x0660
    459c:	f0 91 61 06 	lds	r31, 0x0661
    45a0:	8d 81       	ldd	r24, Y+5	; 0x05
    45a2:	68 2f       	mov	r22, r24
    45a4:	70 e0       	ldi	r23, 0x00	; 0
    45a6:	89 81       	ldd	r24, Y+1	; 0x01
    45a8:	9a 81       	ldd	r25, Y+2	; 0x02
    45aa:	ab 81       	ldd	r26, Y+3	; 0x03
    45ac:	bc 81       	ldd	r27, Y+4	; 0x04
    45ae:	9c 01       	movw	r18, r24
    45b0:	ad 01       	movw	r20, r26
    45b2:	21 50       	subi	r18, 0x01	; 1
    45b4:	30 40       	sbci	r19, 0x00	; 0
    45b6:	40 40       	sbci	r20, 0x00	; 0
    45b8:	50 40       	sbci	r21, 0x00	; 0
    45ba:	cb 01       	movw	r24, r22
    45bc:	88 0f       	add	r24, r24
    45be:	99 1f       	adc	r25, r25
    45c0:	88 0f       	add	r24, r24
    45c2:	99 1f       	adc	r25, r25
    45c4:	8e 0f       	add	r24, r30
    45c6:	9f 1f       	adc	r25, r31
    45c8:	fc 01       	movw	r30, r24
    45ca:	b1 96       	adiw	r30, 0x21	; 33
    45cc:	20 83       	st	Z, r18
    45ce:	31 83       	std	Z+1, r19	; 0x01
    45d0:	42 83       	std	Z+2, r20	; 0x02
    45d2:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    45d4:	20 91 60 06 	lds	r18, 0x0660
    45d8:	30 91 61 06 	lds	r19, 0x0661
    45dc:	8d 81       	ldd	r24, Y+5	; 0x05
    45de:	88 2f       	mov	r24, r24
    45e0:	90 e0       	ldi	r25, 0x00	; 0
    45e2:	82 0f       	add	r24, r18
    45e4:	93 1f       	adc	r25, r19
    45e6:	fc 01       	movw	r30, r24
    45e8:	b5 96       	adiw	r30, 0x25	; 37
    45ea:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    45ec:	0f 90       	pop	r0
    45ee:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    45f0:	89 81       	ldd	r24, Y+1	; 0x01
    45f2:	9a 81       	ldd	r25, Y+2	; 0x02
    45f4:	ab 81       	ldd	r26, Y+3	; 0x03
    45f6:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    45f8:	bc 01       	movw	r22, r24
    45fa:	cd 01       	movw	r24, r26
    45fc:	28 96       	adiw	r28, 0x08	; 8
    45fe:	0f b6       	in	r0, 0x3f	; 63
    4600:	f8 94       	cli
    4602:	de bf       	out	0x3e, r29	; 62
    4604:	0f be       	out	0x3f, r0	; 63
    4606:	cd bf       	out	0x3d, r28	; 61
    4608:	cf 91       	pop	r28
    460a:	df 91       	pop	r29
    460c:	08 95       	ret

0000460e <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    460e:	cf 92       	push	r12
    4610:	df 92       	push	r13
    4612:	ef 92       	push	r14
    4614:	ff 92       	push	r15
    4616:	0f 93       	push	r16
    4618:	1f 93       	push	r17
    461a:	df 93       	push	r29
    461c:	cf 93       	push	r28
    461e:	cd b7       	in	r28, 0x3d	; 61
    4620:	de b7       	in	r29, 0x3e	; 62
    4622:	2e 97       	sbiw	r28, 0x0e	; 14
    4624:	0f b6       	in	r0, 0x3f	; 63
    4626:	f8 94       	cli
    4628:	de bf       	out	0x3e, r29	; 62
    462a:	0f be       	out	0x3f, r0	; 63
    462c:	cd bf       	out	0x3d, r28	; 61
    462e:	8a 83       	std	Y+2, r24	; 0x02
    4630:	4b 83       	std	Y+3, r20	; 0x03
    4632:	5c 83       	std	Y+4, r21	; 0x04
    4634:	6d 83       	std	Y+5, r22	; 0x05
    4636:	7e 83       	std	Y+6, r23	; 0x06
    4638:	0f 83       	std	Y+7, r16	; 0x07
    463a:	18 87       	std	Y+8, r17	; 0x08
    463c:	29 87       	std	Y+9, r18	; 0x09
    463e:	3a 87       	std	Y+10, r19	; 0x0a
    4640:	fc 86       	std	Y+12, r15	; 0x0c
    4642:	eb 86       	std	Y+11, r14	; 0x0b
    4644:	de 86       	std	Y+14, r13	; 0x0e
    4646:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4648:	0f b6       	in	r0, 0x3f	; 63
    464a:	f8 94       	cli
    464c:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    464e:	20 91 60 06 	lds	r18, 0x0660
    4652:	30 91 61 06 	lds	r19, 0x0661
    4656:	8a 81       	ldd	r24, Y+2	; 0x02
    4658:	88 2f       	mov	r24, r24
    465a:	90 e0       	ldi	r25, 0x00	; 0
    465c:	82 0f       	add	r24, r18
    465e:	93 1f       	adc	r25, r19
    4660:	fc 01       	movw	r30, r24
    4662:	b5 96       	adiw	r30, 0x25	; 37
    4664:	80 81       	ld	r24, Z
    4666:	82 30       	cpi	r24, 0x02	; 2
    4668:	09 f4       	brne	.+2      	; 0x466c <xTaskGenericNotifyWait+0x5e>
    466a:	47 c0       	rjmp	.+142    	; 0x46fa <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    466c:	60 91 60 06 	lds	r22, 0x0660
    4670:	70 91 61 06 	lds	r23, 0x0661
    4674:	8a 81       	ldd	r24, Y+2	; 0x02
    4676:	08 2f       	mov	r16, r24
    4678:	10 e0       	ldi	r17, 0x00	; 0
    467a:	8a 81       	ldd	r24, Y+2	; 0x02
    467c:	88 2f       	mov	r24, r24
    467e:	90 e0       	ldi	r25, 0x00	; 0
    4680:	88 0f       	add	r24, r24
    4682:	99 1f       	adc	r25, r25
    4684:	88 0f       	add	r24, r24
    4686:	99 1f       	adc	r25, r25
    4688:	86 0f       	add	r24, r22
    468a:	97 1f       	adc	r25, r23
    468c:	fc 01       	movw	r30, r24
    468e:	b1 96       	adiw	r30, 0x21	; 33
    4690:	20 81       	ld	r18, Z
    4692:	31 81       	ldd	r19, Z+1	; 0x01
    4694:	42 81       	ldd	r20, Z+2	; 0x02
    4696:	53 81       	ldd	r21, Z+3	; 0x03
    4698:	8b 81       	ldd	r24, Y+3	; 0x03
    469a:	9c 81       	ldd	r25, Y+4	; 0x04
    469c:	ad 81       	ldd	r26, Y+5	; 0x05
    469e:	be 81       	ldd	r27, Y+6	; 0x06
    46a0:	80 95       	com	r24
    46a2:	90 95       	com	r25
    46a4:	a0 95       	com	r26
    46a6:	b0 95       	com	r27
    46a8:	28 23       	and	r18, r24
    46aa:	39 23       	and	r19, r25
    46ac:	4a 23       	and	r20, r26
    46ae:	5b 23       	and	r21, r27
    46b0:	c8 01       	movw	r24, r16
    46b2:	88 0f       	add	r24, r24
    46b4:	99 1f       	adc	r25, r25
    46b6:	88 0f       	add	r24, r24
    46b8:	99 1f       	adc	r25, r25
    46ba:	86 0f       	add	r24, r22
    46bc:	97 1f       	adc	r25, r23
    46be:	fc 01       	movw	r30, r24
    46c0:	b1 96       	adiw	r30, 0x21	; 33
    46c2:	20 83       	st	Z, r18
    46c4:	31 83       	std	Z+1, r19	; 0x01
    46c6:	42 83       	std	Z+2, r20	; 0x02
    46c8:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    46ca:	20 91 60 06 	lds	r18, 0x0660
    46ce:	30 91 61 06 	lds	r19, 0x0661
    46d2:	8a 81       	ldd	r24, Y+2	; 0x02
    46d4:	88 2f       	mov	r24, r24
    46d6:	90 e0       	ldi	r25, 0x00	; 0
    46d8:	82 0f       	add	r24, r18
    46da:	93 1f       	adc	r25, r19
    46dc:	fc 01       	movw	r30, r24
    46de:	b5 96       	adiw	r30, 0x25	; 37
    46e0:	81 e0       	ldi	r24, 0x01	; 1
    46e2:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    46e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    46e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    46e8:	00 97       	sbiw	r24, 0x00	; 0
    46ea:	39 f0       	breq	.+14     	; 0x46fa <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    46ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    46ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    46f0:	61 e0       	ldi	r22, 0x01	; 1
    46f2:	0e 94 ce 29 	call	0x539c	; 0x539c <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    46f6:	0e 94 66 07 	call	0xecc	; 0xecc <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    46fa:	0f 90       	pop	r0
    46fc:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    46fe:	0f b6       	in	r0, 0x3f	; 63
    4700:	f8 94       	cli
    4702:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4704:	8b 85       	ldd	r24, Y+11	; 0x0b
    4706:	9c 85       	ldd	r25, Y+12	; 0x0c
    4708:	00 97       	sbiw	r24, 0x00	; 0
    470a:	c9 f0       	breq	.+50     	; 0x473e <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    470c:	20 91 60 06 	lds	r18, 0x0660
    4710:	30 91 61 06 	lds	r19, 0x0661
    4714:	8a 81       	ldd	r24, Y+2	; 0x02
    4716:	88 2f       	mov	r24, r24
    4718:	90 e0       	ldi	r25, 0x00	; 0
    471a:	88 0f       	add	r24, r24
    471c:	99 1f       	adc	r25, r25
    471e:	88 0f       	add	r24, r24
    4720:	99 1f       	adc	r25, r25
    4722:	82 0f       	add	r24, r18
    4724:	93 1f       	adc	r25, r19
    4726:	fc 01       	movw	r30, r24
    4728:	b1 96       	adiw	r30, 0x21	; 33
    472a:	80 81       	ld	r24, Z
    472c:	91 81       	ldd	r25, Z+1	; 0x01
    472e:	a2 81       	ldd	r26, Z+2	; 0x02
    4730:	b3 81       	ldd	r27, Z+3	; 0x03
    4732:	eb 85       	ldd	r30, Y+11	; 0x0b
    4734:	fc 85       	ldd	r31, Y+12	; 0x0c
    4736:	80 83       	st	Z, r24
    4738:	91 83       	std	Z+1, r25	; 0x01
    473a:	a2 83       	std	Z+2, r26	; 0x02
    473c:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    473e:	20 91 60 06 	lds	r18, 0x0660
    4742:	30 91 61 06 	lds	r19, 0x0661
    4746:	8a 81       	ldd	r24, Y+2	; 0x02
    4748:	88 2f       	mov	r24, r24
    474a:	90 e0       	ldi	r25, 0x00	; 0
    474c:	82 0f       	add	r24, r18
    474e:	93 1f       	adc	r25, r19
    4750:	fc 01       	movw	r30, r24
    4752:	b5 96       	adiw	r30, 0x25	; 37
    4754:	80 81       	ld	r24, Z
    4756:	82 30       	cpi	r24, 0x02	; 2
    4758:	11 f0       	breq	.+4      	; 0x475e <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    475a:	19 82       	std	Y+1, r1	; 0x01
    475c:	31 c0       	rjmp	.+98     	; 0x47c0 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    475e:	60 91 60 06 	lds	r22, 0x0660
    4762:	70 91 61 06 	lds	r23, 0x0661
    4766:	8a 81       	ldd	r24, Y+2	; 0x02
    4768:	08 2f       	mov	r16, r24
    476a:	10 e0       	ldi	r17, 0x00	; 0
    476c:	8a 81       	ldd	r24, Y+2	; 0x02
    476e:	88 2f       	mov	r24, r24
    4770:	90 e0       	ldi	r25, 0x00	; 0
    4772:	88 0f       	add	r24, r24
    4774:	99 1f       	adc	r25, r25
    4776:	88 0f       	add	r24, r24
    4778:	99 1f       	adc	r25, r25
    477a:	86 0f       	add	r24, r22
    477c:	97 1f       	adc	r25, r23
    477e:	fc 01       	movw	r30, r24
    4780:	b1 96       	adiw	r30, 0x21	; 33
    4782:	20 81       	ld	r18, Z
    4784:	31 81       	ldd	r19, Z+1	; 0x01
    4786:	42 81       	ldd	r20, Z+2	; 0x02
    4788:	53 81       	ldd	r21, Z+3	; 0x03
    478a:	8f 81       	ldd	r24, Y+7	; 0x07
    478c:	98 85       	ldd	r25, Y+8	; 0x08
    478e:	a9 85       	ldd	r26, Y+9	; 0x09
    4790:	ba 85       	ldd	r27, Y+10	; 0x0a
    4792:	80 95       	com	r24
    4794:	90 95       	com	r25
    4796:	a0 95       	com	r26
    4798:	b0 95       	com	r27
    479a:	28 23       	and	r18, r24
    479c:	39 23       	and	r19, r25
    479e:	4a 23       	and	r20, r26
    47a0:	5b 23       	and	r21, r27
    47a2:	c8 01       	movw	r24, r16
    47a4:	88 0f       	add	r24, r24
    47a6:	99 1f       	adc	r25, r25
    47a8:	88 0f       	add	r24, r24
    47aa:	99 1f       	adc	r25, r25
    47ac:	86 0f       	add	r24, r22
    47ae:	97 1f       	adc	r25, r23
    47b0:	fc 01       	movw	r30, r24
    47b2:	b1 96       	adiw	r30, 0x21	; 33
    47b4:	20 83       	st	Z, r18
    47b6:	31 83       	std	Z+1, r19	; 0x01
    47b8:	42 83       	std	Z+2, r20	; 0x02
    47ba:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    47bc:	81 e0       	ldi	r24, 0x01	; 1
    47be:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    47c0:	20 91 60 06 	lds	r18, 0x0660
    47c4:	30 91 61 06 	lds	r19, 0x0661
    47c8:	8a 81       	ldd	r24, Y+2	; 0x02
    47ca:	88 2f       	mov	r24, r24
    47cc:	90 e0       	ldi	r25, 0x00	; 0
    47ce:	82 0f       	add	r24, r18
    47d0:	93 1f       	adc	r25, r19
    47d2:	fc 01       	movw	r30, r24
    47d4:	b5 96       	adiw	r30, 0x25	; 37
    47d6:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    47d8:	0f 90       	pop	r0
    47da:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    47dc:	89 81       	ldd	r24, Y+1	; 0x01
    }
    47de:	2e 96       	adiw	r28, 0x0e	; 14
    47e0:	0f b6       	in	r0, 0x3f	; 63
    47e2:	f8 94       	cli
    47e4:	de bf       	out	0x3e, r29	; 62
    47e6:	0f be       	out	0x3f, r0	; 63
    47e8:	cd bf       	out	0x3d, r28	; 61
    47ea:	cf 91       	pop	r28
    47ec:	df 91       	pop	r29
    47ee:	1f 91       	pop	r17
    47f0:	0f 91       	pop	r16
    47f2:	ff 90       	pop	r15
    47f4:	ef 90       	pop	r14
    47f6:	df 90       	pop	r13
    47f8:	cf 90       	pop	r12
    47fa:	08 95       	ret

000047fc <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    47fc:	ef 92       	push	r14
    47fe:	ff 92       	push	r15
    4800:	0f 93       	push	r16
    4802:	1f 93       	push	r17
    4804:	df 93       	push	r29
    4806:	cf 93       	push	r28
    4808:	cd b7       	in	r28, 0x3d	; 61
    480a:	de b7       	in	r29, 0x3e	; 62
    480c:	66 97       	sbiw	r28, 0x16	; 22
    480e:	0f b6       	in	r0, 0x3f	; 63
    4810:	f8 94       	cli
    4812:	de bf       	out	0x3e, r29	; 62
    4814:	0f be       	out	0x3f, r0	; 63
    4816:	cd bf       	out	0x3d, r28	; 61
    4818:	9a 87       	std	Y+10, r25	; 0x0a
    481a:	89 87       	std	Y+9, r24	; 0x09
    481c:	6b 87       	std	Y+11, r22	; 0x0b
    481e:	2c 87       	std	Y+12, r18	; 0x0c
    4820:	3d 87       	std	Y+13, r19	; 0x0d
    4822:	4e 87       	std	Y+14, r20	; 0x0e
    4824:	5f 87       	std	Y+15, r21	; 0x0f
    4826:	08 8b       	std	Y+16, r16	; 0x10
    4828:	fa 8a       	std	Y+18, r15	; 0x12
    482a:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    482c:	81 e0       	ldi	r24, 0x01	; 1
    482e:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    4830:	89 85       	ldd	r24, Y+9	; 0x09
    4832:	9a 85       	ldd	r25, Y+10	; 0x0a
    4834:	98 87       	std	Y+8, r25	; 0x08
    4836:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    4838:	0f b6       	in	r0, 0x3f	; 63
    483a:	f8 94       	cli
    483c:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    483e:	89 89       	ldd	r24, Y+17	; 0x11
    4840:	9a 89       	ldd	r25, Y+18	; 0x12
    4842:	00 97       	sbiw	r24, 0x00	; 0
    4844:	b9 f0       	breq	.+46     	; 0x4874 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4846:	8b 85       	ldd	r24, Y+11	; 0x0b
    4848:	88 2f       	mov	r24, r24
    484a:	90 e0       	ldi	r25, 0x00	; 0
    484c:	2f 81       	ldd	r18, Y+7	; 0x07
    484e:	38 85       	ldd	r19, Y+8	; 0x08
    4850:	88 0f       	add	r24, r24
    4852:	99 1f       	adc	r25, r25
    4854:	88 0f       	add	r24, r24
    4856:	99 1f       	adc	r25, r25
    4858:	82 0f       	add	r24, r18
    485a:	93 1f       	adc	r25, r19
    485c:	fc 01       	movw	r30, r24
    485e:	b1 96       	adiw	r30, 0x21	; 33
    4860:	80 81       	ld	r24, Z
    4862:	91 81       	ldd	r25, Z+1	; 0x01
    4864:	a2 81       	ldd	r26, Z+2	; 0x02
    4866:	b3 81       	ldd	r27, Z+3	; 0x03
    4868:	e9 89       	ldd	r30, Y+17	; 0x11
    486a:	fa 89       	ldd	r31, Y+18	; 0x12
    486c:	80 83       	st	Z, r24
    486e:	91 83       	std	Z+1, r25	; 0x01
    4870:	a2 83       	std	Z+2, r26	; 0x02
    4872:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4874:	8b 85       	ldd	r24, Y+11	; 0x0b
    4876:	28 2f       	mov	r18, r24
    4878:	30 e0       	ldi	r19, 0x00	; 0
    487a:	8f 81       	ldd	r24, Y+7	; 0x07
    487c:	98 85       	ldd	r25, Y+8	; 0x08
    487e:	82 0f       	add	r24, r18
    4880:	93 1f       	adc	r25, r19
    4882:	fc 01       	movw	r30, r24
    4884:	b5 96       	adiw	r30, 0x25	; 37
    4886:	80 81       	ld	r24, Z
    4888:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    488a:	8b 85       	ldd	r24, Y+11	; 0x0b
    488c:	28 2f       	mov	r18, r24
    488e:	30 e0       	ldi	r19, 0x00	; 0
    4890:	8f 81       	ldd	r24, Y+7	; 0x07
    4892:	98 85       	ldd	r25, Y+8	; 0x08
    4894:	82 0f       	add	r24, r18
    4896:	93 1f       	adc	r25, r19
    4898:	fc 01       	movw	r30, r24
    489a:	b5 96       	adiw	r30, 0x25	; 37
    489c:	82 e0       	ldi	r24, 0x02	; 2
    489e:	80 83       	st	Z, r24

            switch( eAction )
    48a0:	88 89       	ldd	r24, Y+16	; 0x10
    48a2:	28 2f       	mov	r18, r24
    48a4:	30 e0       	ldi	r19, 0x00	; 0
    48a6:	3e 8b       	std	Y+22, r19	; 0x16
    48a8:	2d 8b       	std	Y+21, r18	; 0x15
    48aa:	8d 89       	ldd	r24, Y+21	; 0x15
    48ac:	9e 89       	ldd	r25, Y+22	; 0x16
    48ae:	82 30       	cpi	r24, 0x02	; 2
    48b0:	91 05       	cpc	r25, r1
    48b2:	09 f4       	brne	.+2      	; 0x48b6 <xTaskGenericNotify+0xba>
    48b4:	46 c0       	rjmp	.+140    	; 0x4942 <xTaskGenericNotify+0x146>
    48b6:	2d 89       	ldd	r18, Y+21	; 0x15
    48b8:	3e 89       	ldd	r19, Y+22	; 0x16
    48ba:	23 30       	cpi	r18, 0x03	; 3
    48bc:	31 05       	cpc	r19, r1
    48be:	34 f4       	brge	.+12     	; 0x48cc <xTaskGenericNotify+0xd0>
    48c0:	8d 89       	ldd	r24, Y+21	; 0x15
    48c2:	9e 89       	ldd	r25, Y+22	; 0x16
    48c4:	81 30       	cpi	r24, 0x01	; 1
    48c6:	91 05       	cpc	r25, r1
    48c8:	71 f0       	breq	.+28     	; 0x48e6 <xTaskGenericNotify+0xea>
    48ca:	93 c0       	rjmp	.+294    	; 0x49f2 <xTaskGenericNotify+0x1f6>
    48cc:	2d 89       	ldd	r18, Y+21	; 0x15
    48ce:	3e 89       	ldd	r19, Y+22	; 0x16
    48d0:	23 30       	cpi	r18, 0x03	; 3
    48d2:	31 05       	cpc	r19, r1
    48d4:	09 f4       	brne	.+2      	; 0x48d8 <xTaskGenericNotify+0xdc>
    48d6:	5d c0       	rjmp	.+186    	; 0x4992 <xTaskGenericNotify+0x196>
    48d8:	8d 89       	ldd	r24, Y+21	; 0x15
    48da:	9e 89       	ldd	r25, Y+22	; 0x16
    48dc:	84 30       	cpi	r24, 0x04	; 4
    48de:	91 05       	cpc	r25, r1
    48e0:	09 f4       	brne	.+2      	; 0x48e4 <xTaskGenericNotify+0xe8>
    48e2:	6d c0       	rjmp	.+218    	; 0x49be <xTaskGenericNotify+0x1c2>
    48e4:	86 c0       	rjmp	.+268    	; 0x49f2 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    48e6:	8b 85       	ldd	r24, Y+11	; 0x0b
    48e8:	08 2f       	mov	r16, r24
    48ea:	10 e0       	ldi	r17, 0x00	; 0
    48ec:	8b 85       	ldd	r24, Y+11	; 0x0b
    48ee:	88 2f       	mov	r24, r24
    48f0:	90 e0       	ldi	r25, 0x00	; 0
    48f2:	2f 81       	ldd	r18, Y+7	; 0x07
    48f4:	38 85       	ldd	r19, Y+8	; 0x08
    48f6:	88 0f       	add	r24, r24
    48f8:	99 1f       	adc	r25, r25
    48fa:	88 0f       	add	r24, r24
    48fc:	99 1f       	adc	r25, r25
    48fe:	82 0f       	add	r24, r18
    4900:	93 1f       	adc	r25, r19
    4902:	fc 01       	movw	r30, r24
    4904:	b1 96       	adiw	r30, 0x21	; 33
    4906:	20 81       	ld	r18, Z
    4908:	31 81       	ldd	r19, Z+1	; 0x01
    490a:	42 81       	ldd	r20, Z+2	; 0x02
    490c:	53 81       	ldd	r21, Z+3	; 0x03
    490e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4910:	9d 85       	ldd	r25, Y+13	; 0x0d
    4912:	ae 85       	ldd	r26, Y+14	; 0x0e
    4914:	bf 85       	ldd	r27, Y+15	; 0x0f
    4916:	ba 01       	movw	r22, r20
    4918:	a9 01       	movw	r20, r18
    491a:	48 2b       	or	r20, r24
    491c:	59 2b       	or	r21, r25
    491e:	6a 2b       	or	r22, r26
    4920:	7b 2b       	or	r23, r27
    4922:	2f 81       	ldd	r18, Y+7	; 0x07
    4924:	38 85       	ldd	r19, Y+8	; 0x08
    4926:	c8 01       	movw	r24, r16
    4928:	88 0f       	add	r24, r24
    492a:	99 1f       	adc	r25, r25
    492c:	88 0f       	add	r24, r24
    492e:	99 1f       	adc	r25, r25
    4930:	82 0f       	add	r24, r18
    4932:	93 1f       	adc	r25, r19
    4934:	fc 01       	movw	r30, r24
    4936:	b1 96       	adiw	r30, 0x21	; 33
    4938:	40 83       	st	Z, r20
    493a:	51 83       	std	Z+1, r21	; 0x01
    493c:	62 83       	std	Z+2, r22	; 0x02
    493e:	73 83       	std	Z+3, r23	; 0x03
    4940:	58 c0       	rjmp	.+176    	; 0x49f2 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4942:	8b 85       	ldd	r24, Y+11	; 0x0b
    4944:	08 2f       	mov	r16, r24
    4946:	10 e0       	ldi	r17, 0x00	; 0
    4948:	2f 81       	ldd	r18, Y+7	; 0x07
    494a:	38 85       	ldd	r19, Y+8	; 0x08
    494c:	c8 01       	movw	r24, r16
    494e:	88 0f       	add	r24, r24
    4950:	99 1f       	adc	r25, r25
    4952:	88 0f       	add	r24, r24
    4954:	99 1f       	adc	r25, r25
    4956:	82 0f       	add	r24, r18
    4958:	93 1f       	adc	r25, r19
    495a:	fc 01       	movw	r30, r24
    495c:	b1 96       	adiw	r30, 0x21	; 33
    495e:	80 81       	ld	r24, Z
    4960:	91 81       	ldd	r25, Z+1	; 0x01
    4962:	a2 81       	ldd	r26, Z+2	; 0x02
    4964:	b3 81       	ldd	r27, Z+3	; 0x03
    4966:	ac 01       	movw	r20, r24
    4968:	bd 01       	movw	r22, r26
    496a:	4f 5f       	subi	r20, 0xFF	; 255
    496c:	5f 4f       	sbci	r21, 0xFF	; 255
    496e:	6f 4f       	sbci	r22, 0xFF	; 255
    4970:	7f 4f       	sbci	r23, 0xFF	; 255
    4972:	2f 81       	ldd	r18, Y+7	; 0x07
    4974:	38 85       	ldd	r19, Y+8	; 0x08
    4976:	c8 01       	movw	r24, r16
    4978:	88 0f       	add	r24, r24
    497a:	99 1f       	adc	r25, r25
    497c:	88 0f       	add	r24, r24
    497e:	99 1f       	adc	r25, r25
    4980:	82 0f       	add	r24, r18
    4982:	93 1f       	adc	r25, r19
    4984:	fc 01       	movw	r30, r24
    4986:	b1 96       	adiw	r30, 0x21	; 33
    4988:	40 83       	st	Z, r20
    498a:	51 83       	std	Z+1, r21	; 0x01
    498c:	62 83       	std	Z+2, r22	; 0x02
    498e:	73 83       	std	Z+3, r23	; 0x03
    4990:	30 c0       	rjmp	.+96     	; 0x49f2 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4992:	8b 85       	ldd	r24, Y+11	; 0x0b
    4994:	88 2f       	mov	r24, r24
    4996:	90 e0       	ldi	r25, 0x00	; 0
    4998:	2f 81       	ldd	r18, Y+7	; 0x07
    499a:	38 85       	ldd	r19, Y+8	; 0x08
    499c:	88 0f       	add	r24, r24
    499e:	99 1f       	adc	r25, r25
    49a0:	88 0f       	add	r24, r24
    49a2:	99 1f       	adc	r25, r25
    49a4:	82 0f       	add	r24, r18
    49a6:	93 1f       	adc	r25, r19
    49a8:	fc 01       	movw	r30, r24
    49aa:	b1 96       	adiw	r30, 0x21	; 33
    49ac:	8c 85       	ldd	r24, Y+12	; 0x0c
    49ae:	9d 85       	ldd	r25, Y+13	; 0x0d
    49b0:	ae 85       	ldd	r26, Y+14	; 0x0e
    49b2:	bf 85       	ldd	r27, Y+15	; 0x0f
    49b4:	80 83       	st	Z, r24
    49b6:	91 83       	std	Z+1, r25	; 0x01
    49b8:	a2 83       	std	Z+2, r26	; 0x02
    49ba:	b3 83       	std	Z+3, r27	; 0x03
    49bc:	1a c0       	rjmp	.+52     	; 0x49f2 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    49be:	8d 81       	ldd	r24, Y+5	; 0x05
    49c0:	82 30       	cpi	r24, 0x02	; 2
    49c2:	b1 f0       	breq	.+44     	; 0x49f0 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    49c4:	8b 85       	ldd	r24, Y+11	; 0x0b
    49c6:	88 2f       	mov	r24, r24
    49c8:	90 e0       	ldi	r25, 0x00	; 0
    49ca:	2f 81       	ldd	r18, Y+7	; 0x07
    49cc:	38 85       	ldd	r19, Y+8	; 0x08
    49ce:	88 0f       	add	r24, r24
    49d0:	99 1f       	adc	r25, r25
    49d2:	88 0f       	add	r24, r24
    49d4:	99 1f       	adc	r25, r25
    49d6:	82 0f       	add	r24, r18
    49d8:	93 1f       	adc	r25, r19
    49da:	fc 01       	movw	r30, r24
    49dc:	b1 96       	adiw	r30, 0x21	; 33
    49de:	8c 85       	ldd	r24, Y+12	; 0x0c
    49e0:	9d 85       	ldd	r25, Y+13	; 0x0d
    49e2:	ae 85       	ldd	r26, Y+14	; 0x0e
    49e4:	bf 85       	ldd	r27, Y+15	; 0x0f
    49e6:	80 83       	st	Z, r24
    49e8:	91 83       	std	Z+1, r25	; 0x01
    49ea:	a2 83       	std	Z+2, r26	; 0x02
    49ec:	b3 83       	std	Z+3, r27	; 0x03
    49ee:	01 c0       	rjmp	.+2      	; 0x49f2 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    49f0:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    49f2:	8d 81       	ldd	r24, Y+5	; 0x05
    49f4:	81 30       	cpi	r24, 0x01	; 1
    49f6:	09 f0       	breq	.+2      	; 0x49fa <xTaskGenericNotify+0x1fe>
    49f8:	a7 c0       	rjmp	.+334    	; 0x4b48 <xTaskGenericNotify+0x34c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    49fa:	ef 81       	ldd	r30, Y+7	; 0x07
    49fc:	f8 85       	ldd	r31, Y+8	; 0x08
    49fe:	82 85       	ldd	r24, Z+10	; 0x0a
    4a00:	93 85       	ldd	r25, Z+11	; 0x0b
    4a02:	9c 83       	std	Y+4, r25	; 0x04
    4a04:	8b 83       	std	Y+3, r24	; 0x03
    4a06:	ef 81       	ldd	r30, Y+7	; 0x07
    4a08:	f8 85       	ldd	r31, Y+8	; 0x08
    4a0a:	a4 81       	ldd	r26, Z+4	; 0x04
    4a0c:	b5 81       	ldd	r27, Z+5	; 0x05
    4a0e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a10:	f8 85       	ldd	r31, Y+8	; 0x08
    4a12:	86 81       	ldd	r24, Z+6	; 0x06
    4a14:	97 81       	ldd	r25, Z+7	; 0x07
    4a16:	15 96       	adiw	r26, 0x05	; 5
    4a18:	9c 93       	st	X, r25
    4a1a:	8e 93       	st	-X, r24
    4a1c:	14 97       	sbiw	r26, 0x04	; 4
    4a1e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a20:	f8 85       	ldd	r31, Y+8	; 0x08
    4a22:	a6 81       	ldd	r26, Z+6	; 0x06
    4a24:	b7 81       	ldd	r27, Z+7	; 0x07
    4a26:	ef 81       	ldd	r30, Y+7	; 0x07
    4a28:	f8 85       	ldd	r31, Y+8	; 0x08
    4a2a:	84 81       	ldd	r24, Z+4	; 0x04
    4a2c:	95 81       	ldd	r25, Z+5	; 0x05
    4a2e:	13 96       	adiw	r26, 0x03	; 3
    4a30:	9c 93       	st	X, r25
    4a32:	8e 93       	st	-X, r24
    4a34:	12 97       	sbiw	r26, 0x02	; 2
    4a36:	eb 81       	ldd	r30, Y+3	; 0x03
    4a38:	fc 81       	ldd	r31, Y+4	; 0x04
    4a3a:	21 81       	ldd	r18, Z+1	; 0x01
    4a3c:	32 81       	ldd	r19, Z+2	; 0x02
    4a3e:	8f 81       	ldd	r24, Y+7	; 0x07
    4a40:	98 85       	ldd	r25, Y+8	; 0x08
    4a42:	02 96       	adiw	r24, 0x02	; 2
    4a44:	28 17       	cp	r18, r24
    4a46:	39 07       	cpc	r19, r25
    4a48:	41 f4       	brne	.+16     	; 0x4a5a <xTaskGenericNotify+0x25e>
    4a4a:	ef 81       	ldd	r30, Y+7	; 0x07
    4a4c:	f8 85       	ldd	r31, Y+8	; 0x08
    4a4e:	86 81       	ldd	r24, Z+6	; 0x06
    4a50:	97 81       	ldd	r25, Z+7	; 0x07
    4a52:	eb 81       	ldd	r30, Y+3	; 0x03
    4a54:	fc 81       	ldd	r31, Y+4	; 0x04
    4a56:	92 83       	std	Z+2, r25	; 0x02
    4a58:	81 83       	std	Z+1, r24	; 0x01
    4a5a:	ef 81       	ldd	r30, Y+7	; 0x07
    4a5c:	f8 85       	ldd	r31, Y+8	; 0x08
    4a5e:	13 86       	std	Z+11, r1	; 0x0b
    4a60:	12 86       	std	Z+10, r1	; 0x0a
    4a62:	eb 81       	ldd	r30, Y+3	; 0x03
    4a64:	fc 81       	ldd	r31, Y+4	; 0x04
    4a66:	80 81       	ld	r24, Z
    4a68:	81 50       	subi	r24, 0x01	; 1
    4a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a6e:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    4a70:	ef 81       	ldd	r30, Y+7	; 0x07
    4a72:	f8 85       	ldd	r31, Y+8	; 0x08
    4a74:	96 89       	ldd	r25, Z+22	; 0x16
    4a76:	80 91 66 06 	lds	r24, 0x0666
    4a7a:	89 17       	cp	r24, r25
    4a7c:	28 f4       	brcc	.+10     	; 0x4a88 <xTaskGenericNotify+0x28c>
    4a7e:	ef 81       	ldd	r30, Y+7	; 0x07
    4a80:	f8 85       	ldd	r31, Y+8	; 0x08
    4a82:	86 89       	ldd	r24, Z+22	; 0x16
    4a84:	80 93 66 06 	sts	0x0666, r24
    4a88:	ef 81       	ldd	r30, Y+7	; 0x07
    4a8a:	f8 85       	ldd	r31, Y+8	; 0x08
    4a8c:	86 89       	ldd	r24, Z+22	; 0x16
    4a8e:	28 2f       	mov	r18, r24
    4a90:	30 e0       	ldi	r19, 0x00	; 0
    4a92:	c9 01       	movw	r24, r18
    4a94:	88 0f       	add	r24, r24
    4a96:	99 1f       	adc	r25, r25
    4a98:	88 0f       	add	r24, r24
    4a9a:	99 1f       	adc	r25, r25
    4a9c:	88 0f       	add	r24, r24
    4a9e:	99 1f       	adc	r25, r25
    4aa0:	82 0f       	add	r24, r18
    4aa2:	93 1f       	adc	r25, r19
    4aa4:	fc 01       	movw	r30, r24
    4aa6:	ee 58       	subi	r30, 0x8E	; 142
    4aa8:	f9 4f       	sbci	r31, 0xF9	; 249
    4aaa:	81 81       	ldd	r24, Z+1	; 0x01
    4aac:	92 81       	ldd	r25, Z+2	; 0x02
    4aae:	9a 83       	std	Y+2, r25	; 0x02
    4ab0:	89 83       	std	Y+1, r24	; 0x01
    4ab2:	ef 81       	ldd	r30, Y+7	; 0x07
    4ab4:	f8 85       	ldd	r31, Y+8	; 0x08
    4ab6:	89 81       	ldd	r24, Y+1	; 0x01
    4ab8:	9a 81       	ldd	r25, Y+2	; 0x02
    4aba:	95 83       	std	Z+5, r25	; 0x05
    4abc:	84 83       	std	Z+4, r24	; 0x04
    4abe:	e9 81       	ldd	r30, Y+1	; 0x01
    4ac0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac2:	84 81       	ldd	r24, Z+4	; 0x04
    4ac4:	95 81       	ldd	r25, Z+5	; 0x05
    4ac6:	ef 81       	ldd	r30, Y+7	; 0x07
    4ac8:	f8 85       	ldd	r31, Y+8	; 0x08
    4aca:	97 83       	std	Z+7, r25	; 0x07
    4acc:	86 83       	std	Z+6, r24	; 0x06
    4ace:	e9 81       	ldd	r30, Y+1	; 0x01
    4ad0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ad2:	04 80       	ldd	r0, Z+4	; 0x04
    4ad4:	f5 81       	ldd	r31, Z+5	; 0x05
    4ad6:	e0 2d       	mov	r30, r0
    4ad8:	8f 81       	ldd	r24, Y+7	; 0x07
    4ada:	98 85       	ldd	r25, Y+8	; 0x08
    4adc:	02 96       	adiw	r24, 0x02	; 2
    4ade:	93 83       	std	Z+3, r25	; 0x03
    4ae0:	82 83       	std	Z+2, r24	; 0x02
    4ae2:	8f 81       	ldd	r24, Y+7	; 0x07
    4ae4:	98 85       	ldd	r25, Y+8	; 0x08
    4ae6:	02 96       	adiw	r24, 0x02	; 2
    4ae8:	e9 81       	ldd	r30, Y+1	; 0x01
    4aea:	fa 81       	ldd	r31, Y+2	; 0x02
    4aec:	95 83       	std	Z+5, r25	; 0x05
    4aee:	84 83       	std	Z+4, r24	; 0x04
    4af0:	ef 81       	ldd	r30, Y+7	; 0x07
    4af2:	f8 85       	ldd	r31, Y+8	; 0x08
    4af4:	86 89       	ldd	r24, Z+22	; 0x16
    4af6:	28 2f       	mov	r18, r24
    4af8:	30 e0       	ldi	r19, 0x00	; 0
    4afa:	c9 01       	movw	r24, r18
    4afc:	88 0f       	add	r24, r24
    4afe:	99 1f       	adc	r25, r25
    4b00:	88 0f       	add	r24, r24
    4b02:	99 1f       	adc	r25, r25
    4b04:	88 0f       	add	r24, r24
    4b06:	99 1f       	adc	r25, r25
    4b08:	82 0f       	add	r24, r18
    4b0a:	93 1f       	adc	r25, r19
    4b0c:	8e 58       	subi	r24, 0x8E	; 142
    4b0e:	99 4f       	sbci	r25, 0xF9	; 249
    4b10:	ef 81       	ldd	r30, Y+7	; 0x07
    4b12:	f8 85       	ldd	r31, Y+8	; 0x08
    4b14:	93 87       	std	Z+11, r25	; 0x0b
    4b16:	82 87       	std	Z+10, r24	; 0x0a
    4b18:	ef 81       	ldd	r30, Y+7	; 0x07
    4b1a:	f8 85       	ldd	r31, Y+8	; 0x08
    4b1c:	86 89       	ldd	r24, Z+22	; 0x16
    4b1e:	28 2f       	mov	r18, r24
    4b20:	30 e0       	ldi	r19, 0x00	; 0
    4b22:	c9 01       	movw	r24, r18
    4b24:	88 0f       	add	r24, r24
    4b26:	99 1f       	adc	r25, r25
    4b28:	88 0f       	add	r24, r24
    4b2a:	99 1f       	adc	r25, r25
    4b2c:	88 0f       	add	r24, r24
    4b2e:	99 1f       	adc	r25, r25
    4b30:	82 0f       	add	r24, r18
    4b32:	93 1f       	adc	r25, r19
    4b34:	fc 01       	movw	r30, r24
    4b36:	ee 58       	subi	r30, 0x8E	; 142
    4b38:	f9 4f       	sbci	r31, 0xF9	; 249
    4b3a:	80 81       	ld	r24, Z
    4b3c:	8f 5f       	subi	r24, 0xFF	; 255
    4b3e:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4b40:	20 91 60 06 	lds	r18, 0x0660
    4b44:	30 91 61 06 	lds	r19, 0x0661
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4b48:	0f 90       	pop	r0
    4b4a:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4b4c:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    4b4e:	66 96       	adiw	r28, 0x16	; 22
    4b50:	0f b6       	in	r0, 0x3f	; 63
    4b52:	f8 94       	cli
    4b54:	de bf       	out	0x3e, r29	; 62
    4b56:	0f be       	out	0x3f, r0	; 63
    4b58:	cd bf       	out	0x3d, r28	; 61
    4b5a:	cf 91       	pop	r28
    4b5c:	df 91       	pop	r29
    4b5e:	1f 91       	pop	r17
    4b60:	0f 91       	pop	r16
    4b62:	ff 90       	pop	r15
    4b64:	ef 90       	pop	r14
    4b66:	08 95       	ret

00004b68 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    4b68:	cf 92       	push	r12
    4b6a:	df 92       	push	r13
    4b6c:	ef 92       	push	r14
    4b6e:	ff 92       	push	r15
    4b70:	0f 93       	push	r16
    4b72:	1f 93       	push	r17
    4b74:	df 93       	push	r29
    4b76:	cf 93       	push	r28
    4b78:	cd b7       	in	r28, 0x3d	; 61
    4b7a:	de b7       	in	r29, 0x3e	; 62
    4b7c:	69 97       	sbiw	r28, 0x19	; 25
    4b7e:	0f b6       	in	r0, 0x3f	; 63
    4b80:	f8 94       	cli
    4b82:	de bf       	out	0x3e, r29	; 62
    4b84:	0f be       	out	0x3f, r0	; 63
    4b86:	cd bf       	out	0x3d, r28	; 61
    4b88:	9d 87       	std	Y+13, r25	; 0x0d
    4b8a:	8c 87       	std	Y+12, r24	; 0x0c
    4b8c:	6e 87       	std	Y+14, r22	; 0x0e
    4b8e:	2f 87       	std	Y+15, r18	; 0x0f
    4b90:	38 8b       	std	Y+16, r19	; 0x10
    4b92:	49 8b       	std	Y+17, r20	; 0x11
    4b94:	5a 8b       	std	Y+18, r21	; 0x12
    4b96:	0b 8b       	std	Y+19, r16	; 0x13
    4b98:	fd 8a       	std	Y+21, r15	; 0x15
    4b9a:	ec 8a       	std	Y+20, r14	; 0x14
    4b9c:	df 8a       	std	Y+23, r13	; 0x17
    4b9e:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    4ba0:	81 e0       	ldi	r24, 0x01	; 1
    4ba2:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4ba4:	8c 85       	ldd	r24, Y+12	; 0x0c
    4ba6:	9d 85       	ldd	r25, Y+13	; 0x0d
    4ba8:	9b 87       	std	Y+11, r25	; 0x0b
    4baa:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4bac:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    4bae:	8c 89       	ldd	r24, Y+20	; 0x14
    4bb0:	9d 89       	ldd	r25, Y+21	; 0x15
    4bb2:	00 97       	sbiw	r24, 0x00	; 0
    4bb4:	b9 f0       	breq	.+46     	; 0x4be4 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4bb6:	8e 85       	ldd	r24, Y+14	; 0x0e
    4bb8:	88 2f       	mov	r24, r24
    4bba:	90 e0       	ldi	r25, 0x00	; 0
    4bbc:	2a 85       	ldd	r18, Y+10	; 0x0a
    4bbe:	3b 85       	ldd	r19, Y+11	; 0x0b
    4bc0:	88 0f       	add	r24, r24
    4bc2:	99 1f       	adc	r25, r25
    4bc4:	88 0f       	add	r24, r24
    4bc6:	99 1f       	adc	r25, r25
    4bc8:	82 0f       	add	r24, r18
    4bca:	93 1f       	adc	r25, r19
    4bcc:	fc 01       	movw	r30, r24
    4bce:	b1 96       	adiw	r30, 0x21	; 33
    4bd0:	80 81       	ld	r24, Z
    4bd2:	91 81       	ldd	r25, Z+1	; 0x01
    4bd4:	a2 81       	ldd	r26, Z+2	; 0x02
    4bd6:	b3 81       	ldd	r27, Z+3	; 0x03
    4bd8:	ec 89       	ldd	r30, Y+20	; 0x14
    4bda:	fd 89       	ldd	r31, Y+21	; 0x15
    4bdc:	80 83       	st	Z, r24
    4bde:	91 83       	std	Z+1, r25	; 0x01
    4be0:	a2 83       	std	Z+2, r26	; 0x02
    4be2:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4be4:	8e 85       	ldd	r24, Y+14	; 0x0e
    4be6:	28 2f       	mov	r18, r24
    4be8:	30 e0       	ldi	r19, 0x00	; 0
    4bea:	8a 85       	ldd	r24, Y+10	; 0x0a
    4bec:	9b 85       	ldd	r25, Y+11	; 0x0b
    4bee:	82 0f       	add	r24, r18
    4bf0:	93 1f       	adc	r25, r19
    4bf2:	fc 01       	movw	r30, r24
    4bf4:	b5 96       	adiw	r30, 0x25	; 37
    4bf6:	80 81       	ld	r24, Z
    4bf8:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4bfa:	8e 85       	ldd	r24, Y+14	; 0x0e
    4bfc:	28 2f       	mov	r18, r24
    4bfe:	30 e0       	ldi	r19, 0x00	; 0
    4c00:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c02:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c04:	82 0f       	add	r24, r18
    4c06:	93 1f       	adc	r25, r19
    4c08:	fc 01       	movw	r30, r24
    4c0a:	b5 96       	adiw	r30, 0x25	; 37
    4c0c:	82 e0       	ldi	r24, 0x02	; 2
    4c0e:	80 83       	st	Z, r24

            switch( eAction )
    4c10:	8b 89       	ldd	r24, Y+19	; 0x13
    4c12:	28 2f       	mov	r18, r24
    4c14:	30 e0       	ldi	r19, 0x00	; 0
    4c16:	39 8f       	std	Y+25, r19	; 0x19
    4c18:	28 8f       	std	Y+24, r18	; 0x18
    4c1a:	88 8d       	ldd	r24, Y+24	; 0x18
    4c1c:	99 8d       	ldd	r25, Y+25	; 0x19
    4c1e:	82 30       	cpi	r24, 0x02	; 2
    4c20:	91 05       	cpc	r25, r1
    4c22:	09 f4       	brne	.+2      	; 0x4c26 <xTaskGenericNotifyFromISR+0xbe>
    4c24:	46 c0       	rjmp	.+140    	; 0x4cb2 <xTaskGenericNotifyFromISR+0x14a>
    4c26:	28 8d       	ldd	r18, Y+24	; 0x18
    4c28:	39 8d       	ldd	r19, Y+25	; 0x19
    4c2a:	23 30       	cpi	r18, 0x03	; 3
    4c2c:	31 05       	cpc	r19, r1
    4c2e:	34 f4       	brge	.+12     	; 0x4c3c <xTaskGenericNotifyFromISR+0xd4>
    4c30:	88 8d       	ldd	r24, Y+24	; 0x18
    4c32:	99 8d       	ldd	r25, Y+25	; 0x19
    4c34:	81 30       	cpi	r24, 0x01	; 1
    4c36:	91 05       	cpc	r25, r1
    4c38:	71 f0       	breq	.+28     	; 0x4c56 <xTaskGenericNotifyFromISR+0xee>
    4c3a:	93 c0       	rjmp	.+294    	; 0x4d62 <xTaskGenericNotifyFromISR+0x1fa>
    4c3c:	28 8d       	ldd	r18, Y+24	; 0x18
    4c3e:	39 8d       	ldd	r19, Y+25	; 0x19
    4c40:	23 30       	cpi	r18, 0x03	; 3
    4c42:	31 05       	cpc	r19, r1
    4c44:	09 f4       	brne	.+2      	; 0x4c48 <xTaskGenericNotifyFromISR+0xe0>
    4c46:	5d c0       	rjmp	.+186    	; 0x4d02 <xTaskGenericNotifyFromISR+0x19a>
    4c48:	88 8d       	ldd	r24, Y+24	; 0x18
    4c4a:	99 8d       	ldd	r25, Y+25	; 0x19
    4c4c:	84 30       	cpi	r24, 0x04	; 4
    4c4e:	91 05       	cpc	r25, r1
    4c50:	09 f4       	brne	.+2      	; 0x4c54 <xTaskGenericNotifyFromISR+0xec>
    4c52:	6d c0       	rjmp	.+218    	; 0x4d2e <xTaskGenericNotifyFromISR+0x1c6>
    4c54:	86 c0       	rjmp	.+268    	; 0x4d62 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4c56:	8e 85       	ldd	r24, Y+14	; 0x0e
    4c58:	08 2f       	mov	r16, r24
    4c5a:	10 e0       	ldi	r17, 0x00	; 0
    4c5c:	8e 85       	ldd	r24, Y+14	; 0x0e
    4c5e:	88 2f       	mov	r24, r24
    4c60:	90 e0       	ldi	r25, 0x00	; 0
    4c62:	2a 85       	ldd	r18, Y+10	; 0x0a
    4c64:	3b 85       	ldd	r19, Y+11	; 0x0b
    4c66:	88 0f       	add	r24, r24
    4c68:	99 1f       	adc	r25, r25
    4c6a:	88 0f       	add	r24, r24
    4c6c:	99 1f       	adc	r25, r25
    4c6e:	82 0f       	add	r24, r18
    4c70:	93 1f       	adc	r25, r19
    4c72:	fc 01       	movw	r30, r24
    4c74:	b1 96       	adiw	r30, 0x21	; 33
    4c76:	20 81       	ld	r18, Z
    4c78:	31 81       	ldd	r19, Z+1	; 0x01
    4c7a:	42 81       	ldd	r20, Z+2	; 0x02
    4c7c:	53 81       	ldd	r21, Z+3	; 0x03
    4c7e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4c80:	98 89       	ldd	r25, Y+16	; 0x10
    4c82:	a9 89       	ldd	r26, Y+17	; 0x11
    4c84:	ba 89       	ldd	r27, Y+18	; 0x12
    4c86:	ba 01       	movw	r22, r20
    4c88:	a9 01       	movw	r20, r18
    4c8a:	48 2b       	or	r20, r24
    4c8c:	59 2b       	or	r21, r25
    4c8e:	6a 2b       	or	r22, r26
    4c90:	7b 2b       	or	r23, r27
    4c92:	2a 85       	ldd	r18, Y+10	; 0x0a
    4c94:	3b 85       	ldd	r19, Y+11	; 0x0b
    4c96:	c8 01       	movw	r24, r16
    4c98:	88 0f       	add	r24, r24
    4c9a:	99 1f       	adc	r25, r25
    4c9c:	88 0f       	add	r24, r24
    4c9e:	99 1f       	adc	r25, r25
    4ca0:	82 0f       	add	r24, r18
    4ca2:	93 1f       	adc	r25, r19
    4ca4:	fc 01       	movw	r30, r24
    4ca6:	b1 96       	adiw	r30, 0x21	; 33
    4ca8:	40 83       	st	Z, r20
    4caa:	51 83       	std	Z+1, r21	; 0x01
    4cac:	62 83       	std	Z+2, r22	; 0x02
    4cae:	73 83       	std	Z+3, r23	; 0x03
    4cb0:	58 c0       	rjmp	.+176    	; 0x4d62 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4cb2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4cb4:	08 2f       	mov	r16, r24
    4cb6:	10 e0       	ldi	r17, 0x00	; 0
    4cb8:	2a 85       	ldd	r18, Y+10	; 0x0a
    4cba:	3b 85       	ldd	r19, Y+11	; 0x0b
    4cbc:	c8 01       	movw	r24, r16
    4cbe:	88 0f       	add	r24, r24
    4cc0:	99 1f       	adc	r25, r25
    4cc2:	88 0f       	add	r24, r24
    4cc4:	99 1f       	adc	r25, r25
    4cc6:	82 0f       	add	r24, r18
    4cc8:	93 1f       	adc	r25, r19
    4cca:	fc 01       	movw	r30, r24
    4ccc:	b1 96       	adiw	r30, 0x21	; 33
    4cce:	80 81       	ld	r24, Z
    4cd0:	91 81       	ldd	r25, Z+1	; 0x01
    4cd2:	a2 81       	ldd	r26, Z+2	; 0x02
    4cd4:	b3 81       	ldd	r27, Z+3	; 0x03
    4cd6:	ac 01       	movw	r20, r24
    4cd8:	bd 01       	movw	r22, r26
    4cda:	4f 5f       	subi	r20, 0xFF	; 255
    4cdc:	5f 4f       	sbci	r21, 0xFF	; 255
    4cde:	6f 4f       	sbci	r22, 0xFF	; 255
    4ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    4ce2:	2a 85       	ldd	r18, Y+10	; 0x0a
    4ce4:	3b 85       	ldd	r19, Y+11	; 0x0b
    4ce6:	c8 01       	movw	r24, r16
    4ce8:	88 0f       	add	r24, r24
    4cea:	99 1f       	adc	r25, r25
    4cec:	88 0f       	add	r24, r24
    4cee:	99 1f       	adc	r25, r25
    4cf0:	82 0f       	add	r24, r18
    4cf2:	93 1f       	adc	r25, r19
    4cf4:	fc 01       	movw	r30, r24
    4cf6:	b1 96       	adiw	r30, 0x21	; 33
    4cf8:	40 83       	st	Z, r20
    4cfa:	51 83       	std	Z+1, r21	; 0x01
    4cfc:	62 83       	std	Z+2, r22	; 0x02
    4cfe:	73 83       	std	Z+3, r23	; 0x03
    4d00:	30 c0       	rjmp	.+96     	; 0x4d62 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4d02:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d04:	88 2f       	mov	r24, r24
    4d06:	90 e0       	ldi	r25, 0x00	; 0
    4d08:	2a 85       	ldd	r18, Y+10	; 0x0a
    4d0a:	3b 85       	ldd	r19, Y+11	; 0x0b
    4d0c:	88 0f       	add	r24, r24
    4d0e:	99 1f       	adc	r25, r25
    4d10:	88 0f       	add	r24, r24
    4d12:	99 1f       	adc	r25, r25
    4d14:	82 0f       	add	r24, r18
    4d16:	93 1f       	adc	r25, r19
    4d18:	fc 01       	movw	r30, r24
    4d1a:	b1 96       	adiw	r30, 0x21	; 33
    4d1c:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d1e:	98 89       	ldd	r25, Y+16	; 0x10
    4d20:	a9 89       	ldd	r26, Y+17	; 0x11
    4d22:	ba 89       	ldd	r27, Y+18	; 0x12
    4d24:	80 83       	st	Z, r24
    4d26:	91 83       	std	Z+1, r25	; 0x01
    4d28:	a2 83       	std	Z+2, r26	; 0x02
    4d2a:	b3 83       	std	Z+3, r27	; 0x03
    4d2c:	1a c0       	rjmp	.+52     	; 0x4d62 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4d2e:	89 85       	ldd	r24, Y+9	; 0x09
    4d30:	82 30       	cpi	r24, 0x02	; 2
    4d32:	b1 f0       	breq	.+44     	; 0x4d60 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4d34:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d36:	88 2f       	mov	r24, r24
    4d38:	90 e0       	ldi	r25, 0x00	; 0
    4d3a:	2a 85       	ldd	r18, Y+10	; 0x0a
    4d3c:	3b 85       	ldd	r19, Y+11	; 0x0b
    4d3e:	88 0f       	add	r24, r24
    4d40:	99 1f       	adc	r25, r25
    4d42:	88 0f       	add	r24, r24
    4d44:	99 1f       	adc	r25, r25
    4d46:	82 0f       	add	r24, r18
    4d48:	93 1f       	adc	r25, r19
    4d4a:	fc 01       	movw	r30, r24
    4d4c:	b1 96       	adiw	r30, 0x21	; 33
    4d4e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d50:	98 89       	ldd	r25, Y+16	; 0x10
    4d52:	a9 89       	ldd	r26, Y+17	; 0x11
    4d54:	ba 89       	ldd	r27, Y+18	; 0x12
    4d56:	80 83       	st	Z, r24
    4d58:	91 83       	std	Z+1, r25	; 0x01
    4d5a:	a2 83       	std	Z+2, r26	; 0x02
    4d5c:	b3 83       	std	Z+3, r27	; 0x03
    4d5e:	01 c0       	rjmp	.+2      	; 0x4d62 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4d60:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4d62:	89 85       	ldd	r24, Y+9	; 0x09
    4d64:	81 30       	cpi	r24, 0x01	; 1
    4d66:	09 f0       	breq	.+2      	; 0x4d6a <xTaskGenericNotifyFromISR+0x202>
    4d68:	ee c0       	rjmp	.+476    	; 0x4f46 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4d6a:	80 91 71 06 	lds	r24, 0x0671
    4d6e:	88 23       	and	r24, r24
    4d70:	09 f0       	breq	.+2      	; 0x4d74 <xTaskGenericNotifyFromISR+0x20c>
    4d72:	a4 c0       	rjmp	.+328    	; 0x4ebc <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4d74:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d76:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d78:	82 85       	ldd	r24, Z+10	; 0x0a
    4d7a:	93 85       	ldd	r25, Z+11	; 0x0b
    4d7c:	9e 83       	std	Y+6, r25	; 0x06
    4d7e:	8d 83       	std	Y+5, r24	; 0x05
    4d80:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d82:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d84:	a4 81       	ldd	r26, Z+4	; 0x04
    4d86:	b5 81       	ldd	r27, Z+5	; 0x05
    4d88:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d8a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d8c:	86 81       	ldd	r24, Z+6	; 0x06
    4d8e:	97 81       	ldd	r25, Z+7	; 0x07
    4d90:	15 96       	adiw	r26, 0x05	; 5
    4d92:	9c 93       	st	X, r25
    4d94:	8e 93       	st	-X, r24
    4d96:	14 97       	sbiw	r26, 0x04	; 4
    4d98:	ea 85       	ldd	r30, Y+10	; 0x0a
    4d9a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4d9c:	a6 81       	ldd	r26, Z+6	; 0x06
    4d9e:	b7 81       	ldd	r27, Z+7	; 0x07
    4da0:	ea 85       	ldd	r30, Y+10	; 0x0a
    4da2:	fb 85       	ldd	r31, Y+11	; 0x0b
    4da4:	84 81       	ldd	r24, Z+4	; 0x04
    4da6:	95 81       	ldd	r25, Z+5	; 0x05
    4da8:	13 96       	adiw	r26, 0x03	; 3
    4daa:	9c 93       	st	X, r25
    4dac:	8e 93       	st	-X, r24
    4dae:	12 97       	sbiw	r26, 0x02	; 2
    4db0:	ed 81       	ldd	r30, Y+5	; 0x05
    4db2:	fe 81       	ldd	r31, Y+6	; 0x06
    4db4:	21 81       	ldd	r18, Z+1	; 0x01
    4db6:	32 81       	ldd	r19, Z+2	; 0x02
    4db8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4dba:	9b 85       	ldd	r25, Y+11	; 0x0b
    4dbc:	02 96       	adiw	r24, 0x02	; 2
    4dbe:	28 17       	cp	r18, r24
    4dc0:	39 07       	cpc	r19, r25
    4dc2:	41 f4       	brne	.+16     	; 0x4dd4 <xTaskGenericNotifyFromISR+0x26c>
    4dc4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4dc6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4dc8:	86 81       	ldd	r24, Z+6	; 0x06
    4dca:	97 81       	ldd	r25, Z+7	; 0x07
    4dcc:	ed 81       	ldd	r30, Y+5	; 0x05
    4dce:	fe 81       	ldd	r31, Y+6	; 0x06
    4dd0:	92 83       	std	Z+2, r25	; 0x02
    4dd2:	81 83       	std	Z+1, r24	; 0x01
    4dd4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4dd6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4dd8:	13 86       	std	Z+11, r1	; 0x0b
    4dda:	12 86       	std	Z+10, r1	; 0x0a
    4ddc:	ed 81       	ldd	r30, Y+5	; 0x05
    4dde:	fe 81       	ldd	r31, Y+6	; 0x06
    4de0:	80 81       	ld	r24, Z
    4de2:	81 50       	subi	r24, 0x01	; 1
    4de4:	ed 81       	ldd	r30, Y+5	; 0x05
    4de6:	fe 81       	ldd	r31, Y+6	; 0x06
    4de8:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    4dea:	ea 85       	ldd	r30, Y+10	; 0x0a
    4dec:	fb 85       	ldd	r31, Y+11	; 0x0b
    4dee:	96 89       	ldd	r25, Z+22	; 0x16
    4df0:	80 91 66 06 	lds	r24, 0x0666
    4df4:	89 17       	cp	r24, r25
    4df6:	28 f4       	brcc	.+10     	; 0x4e02 <xTaskGenericNotifyFromISR+0x29a>
    4df8:	ea 85       	ldd	r30, Y+10	; 0x0a
    4dfa:	fb 85       	ldd	r31, Y+11	; 0x0b
    4dfc:	86 89       	ldd	r24, Z+22	; 0x16
    4dfe:	80 93 66 06 	sts	0x0666, r24
    4e02:	ea 85       	ldd	r30, Y+10	; 0x0a
    4e04:	fb 85       	ldd	r31, Y+11	; 0x0b
    4e06:	86 89       	ldd	r24, Z+22	; 0x16
    4e08:	28 2f       	mov	r18, r24
    4e0a:	30 e0       	ldi	r19, 0x00	; 0
    4e0c:	c9 01       	movw	r24, r18
    4e0e:	88 0f       	add	r24, r24
    4e10:	99 1f       	adc	r25, r25
    4e12:	88 0f       	add	r24, r24
    4e14:	99 1f       	adc	r25, r25
    4e16:	88 0f       	add	r24, r24
    4e18:	99 1f       	adc	r25, r25
    4e1a:	82 0f       	add	r24, r18
    4e1c:	93 1f       	adc	r25, r19
    4e1e:	fc 01       	movw	r30, r24
    4e20:	ee 58       	subi	r30, 0x8E	; 142
    4e22:	f9 4f       	sbci	r31, 0xF9	; 249
    4e24:	81 81       	ldd	r24, Z+1	; 0x01
    4e26:	92 81       	ldd	r25, Z+2	; 0x02
    4e28:	9c 83       	std	Y+4, r25	; 0x04
    4e2a:	8b 83       	std	Y+3, r24	; 0x03
    4e2c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4e2e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4e30:	8b 81       	ldd	r24, Y+3	; 0x03
    4e32:	9c 81       	ldd	r25, Y+4	; 0x04
    4e34:	95 83       	std	Z+5, r25	; 0x05
    4e36:	84 83       	std	Z+4, r24	; 0x04
    4e38:	eb 81       	ldd	r30, Y+3	; 0x03
    4e3a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e3c:	84 81       	ldd	r24, Z+4	; 0x04
    4e3e:	95 81       	ldd	r25, Z+5	; 0x05
    4e40:	ea 85       	ldd	r30, Y+10	; 0x0a
    4e42:	fb 85       	ldd	r31, Y+11	; 0x0b
    4e44:	97 83       	std	Z+7, r25	; 0x07
    4e46:	86 83       	std	Z+6, r24	; 0x06
    4e48:	eb 81       	ldd	r30, Y+3	; 0x03
    4e4a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e4c:	04 80       	ldd	r0, Z+4	; 0x04
    4e4e:	f5 81       	ldd	r31, Z+5	; 0x05
    4e50:	e0 2d       	mov	r30, r0
    4e52:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e54:	9b 85       	ldd	r25, Y+11	; 0x0b
    4e56:	02 96       	adiw	r24, 0x02	; 2
    4e58:	93 83       	std	Z+3, r25	; 0x03
    4e5a:	82 83       	std	Z+2, r24	; 0x02
    4e5c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e5e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4e60:	02 96       	adiw	r24, 0x02	; 2
    4e62:	eb 81       	ldd	r30, Y+3	; 0x03
    4e64:	fc 81       	ldd	r31, Y+4	; 0x04
    4e66:	95 83       	std	Z+5, r25	; 0x05
    4e68:	84 83       	std	Z+4, r24	; 0x04
    4e6a:	ea 85       	ldd	r30, Y+10	; 0x0a
    4e6c:	fb 85       	ldd	r31, Y+11	; 0x0b
    4e6e:	86 89       	ldd	r24, Z+22	; 0x16
    4e70:	28 2f       	mov	r18, r24
    4e72:	30 e0       	ldi	r19, 0x00	; 0
    4e74:	c9 01       	movw	r24, r18
    4e76:	88 0f       	add	r24, r24
    4e78:	99 1f       	adc	r25, r25
    4e7a:	88 0f       	add	r24, r24
    4e7c:	99 1f       	adc	r25, r25
    4e7e:	88 0f       	add	r24, r24
    4e80:	99 1f       	adc	r25, r25
    4e82:	82 0f       	add	r24, r18
    4e84:	93 1f       	adc	r25, r19
    4e86:	8e 58       	subi	r24, 0x8E	; 142
    4e88:	99 4f       	sbci	r25, 0xF9	; 249
    4e8a:	ea 85       	ldd	r30, Y+10	; 0x0a
    4e8c:	fb 85       	ldd	r31, Y+11	; 0x0b
    4e8e:	93 87       	std	Z+11, r25	; 0x0b
    4e90:	82 87       	std	Z+10, r24	; 0x0a
    4e92:	ea 85       	ldd	r30, Y+10	; 0x0a
    4e94:	fb 85       	ldd	r31, Y+11	; 0x0b
    4e96:	86 89       	ldd	r24, Z+22	; 0x16
    4e98:	28 2f       	mov	r18, r24
    4e9a:	30 e0       	ldi	r19, 0x00	; 0
    4e9c:	c9 01       	movw	r24, r18
    4e9e:	88 0f       	add	r24, r24
    4ea0:	99 1f       	adc	r25, r25
    4ea2:	88 0f       	add	r24, r24
    4ea4:	99 1f       	adc	r25, r25
    4ea6:	88 0f       	add	r24, r24
    4ea8:	99 1f       	adc	r25, r25
    4eaa:	82 0f       	add	r24, r18
    4eac:	93 1f       	adc	r25, r19
    4eae:	fc 01       	movw	r30, r24
    4eb0:	ee 58       	subi	r30, 0x8E	; 142
    4eb2:	f9 4f       	sbci	r31, 0xF9	; 249
    4eb4:	80 81       	ld	r24, Z
    4eb6:	8f 5f       	subi	r24, 0xFF	; 255
    4eb8:	80 83       	st	Z, r24
    4eba:	30 c0       	rjmp	.+96     	; 0x4f1c <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4ebc:	80 91 ad 06 	lds	r24, 0x06AD
    4ec0:	90 91 ae 06 	lds	r25, 0x06AE
    4ec4:	9a 83       	std	Y+2, r25	; 0x02
    4ec6:	89 83       	std	Y+1, r24	; 0x01
    4ec8:	ea 85       	ldd	r30, Y+10	; 0x0a
    4eca:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ecc:	89 81       	ldd	r24, Y+1	; 0x01
    4ece:	9a 81       	ldd	r25, Y+2	; 0x02
    4ed0:	97 87       	std	Z+15, r25	; 0x0f
    4ed2:	86 87       	std	Z+14, r24	; 0x0e
    4ed4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ed6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ed8:	84 81       	ldd	r24, Z+4	; 0x04
    4eda:	95 81       	ldd	r25, Z+5	; 0x05
    4edc:	ea 85       	ldd	r30, Y+10	; 0x0a
    4ede:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ee0:	91 8b       	std	Z+17, r25	; 0x11
    4ee2:	80 8b       	std	Z+16, r24	; 0x10
    4ee4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ee6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ee8:	04 80       	ldd	r0, Z+4	; 0x04
    4eea:	f5 81       	ldd	r31, Z+5	; 0x05
    4eec:	e0 2d       	mov	r30, r0
    4eee:	8a 85       	ldd	r24, Y+10	; 0x0a
    4ef0:	9b 85       	ldd	r25, Y+11	; 0x0b
    4ef2:	0c 96       	adiw	r24, 0x0c	; 12
    4ef4:	93 83       	std	Z+3, r25	; 0x03
    4ef6:	82 83       	std	Z+2, r24	; 0x02
    4ef8:	8a 85       	ldd	r24, Y+10	; 0x0a
    4efa:	9b 85       	ldd	r25, Y+11	; 0x0b
    4efc:	0c 96       	adiw	r24, 0x0c	; 12
    4efe:	e9 81       	ldd	r30, Y+1	; 0x01
    4f00:	fa 81       	ldd	r31, Y+2	; 0x02
    4f02:	95 83       	std	Z+5, r25	; 0x05
    4f04:	84 83       	std	Z+4, r24	; 0x04
    4f06:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f08:	fb 85       	ldd	r31, Y+11	; 0x0b
    4f0a:	8c ea       	ldi	r24, 0xAC	; 172
    4f0c:	96 e0       	ldi	r25, 0x06	; 6
    4f0e:	95 8b       	std	Z+21, r25	; 0x15
    4f10:	84 8b       	std	Z+20, r24	; 0x14
    4f12:	80 91 ac 06 	lds	r24, 0x06AC
    4f16:	8f 5f       	subi	r24, 0xFF	; 255
    4f18:	80 93 ac 06 	sts	0x06AC, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f1c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4f1e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4f20:	96 89       	ldd	r25, Z+22	; 0x16
    4f22:	e0 91 60 06 	lds	r30, 0x0660
    4f26:	f0 91 61 06 	lds	r31, 0x0661
    4f2a:	86 89       	ldd	r24, Z+22	; 0x16
    4f2c:	89 17       	cp	r24, r25
    4f2e:	58 f4       	brcc	.+22     	; 0x4f46 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    4f30:	8e 89       	ldd	r24, Y+22	; 0x16
    4f32:	9f 89       	ldd	r25, Y+23	; 0x17
    4f34:	00 97       	sbiw	r24, 0x00	; 0
    4f36:	21 f0       	breq	.+8      	; 0x4f40 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    4f38:	ee 89       	ldd	r30, Y+22	; 0x16
    4f3a:	ff 89       	ldd	r31, Y+23	; 0x17
    4f3c:	81 e0       	ldi	r24, 0x01	; 1
    4f3e:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    4f40:	81 e0       	ldi	r24, 0x01	; 1
    4f42:	80 93 6a 06 	sts	0x066A, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    4f46:	88 85       	ldd	r24, Y+8	; 0x08
    }
    4f48:	69 96       	adiw	r28, 0x19	; 25
    4f4a:	0f b6       	in	r0, 0x3f	; 63
    4f4c:	f8 94       	cli
    4f4e:	de bf       	out	0x3e, r29	; 62
    4f50:	0f be       	out	0x3f, r0	; 63
    4f52:	cd bf       	out	0x3d, r28	; 61
    4f54:	cf 91       	pop	r28
    4f56:	df 91       	pop	r29
    4f58:	1f 91       	pop	r17
    4f5a:	0f 91       	pop	r16
    4f5c:	ff 90       	pop	r15
    4f5e:	ef 90       	pop	r14
    4f60:	df 90       	pop	r13
    4f62:	cf 90       	pop	r12
    4f64:	08 95       	ret

00004f66 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    4f66:	0f 93       	push	r16
    4f68:	1f 93       	push	r17
    4f6a:	df 93       	push	r29
    4f6c:	cf 93       	push	r28
    4f6e:	cd b7       	in	r28, 0x3d	; 61
    4f70:	de b7       	in	r29, 0x3e	; 62
    4f72:	2f 97       	sbiw	r28, 0x0f	; 15
    4f74:	0f b6       	in	r0, 0x3f	; 63
    4f76:	f8 94       	cli
    4f78:	de bf       	out	0x3e, r29	; 62
    4f7a:	0f be       	out	0x3f, r0	; 63
    4f7c:	cd bf       	out	0x3d, r28	; 61
    4f7e:	9c 87       	std	Y+12, r25	; 0x0c
    4f80:	8b 87       	std	Y+11, r24	; 0x0b
    4f82:	6d 87       	std	Y+13, r22	; 0x0d
    4f84:	5f 87       	std	Y+15, r21	; 0x0f
    4f86:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4f88:	8b 85       	ldd	r24, Y+11	; 0x0b
    4f8a:	9c 85       	ldd	r25, Y+12	; 0x0c
    4f8c:	9a 87       	std	Y+10, r25	; 0x0a
    4f8e:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f90:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4f92:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f94:	28 2f       	mov	r18, r24
    4f96:	30 e0       	ldi	r19, 0x00	; 0
    4f98:	89 85       	ldd	r24, Y+9	; 0x09
    4f9a:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f9c:	82 0f       	add	r24, r18
    4f9e:	93 1f       	adc	r25, r19
    4fa0:	fc 01       	movw	r30, r24
    4fa2:	b5 96       	adiw	r30, 0x25	; 37
    4fa4:	80 81       	ld	r24, Z
    4fa6:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4fa8:	8d 85       	ldd	r24, Y+13	; 0x0d
    4faa:	28 2f       	mov	r18, r24
    4fac:	30 e0       	ldi	r19, 0x00	; 0
    4fae:	89 85       	ldd	r24, Y+9	; 0x09
    4fb0:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fb2:	82 0f       	add	r24, r18
    4fb4:	93 1f       	adc	r25, r19
    4fb6:	fc 01       	movw	r30, r24
    4fb8:	b5 96       	adiw	r30, 0x25	; 37
    4fba:	82 e0       	ldi	r24, 0x02	; 2
    4fbc:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4fbe:	8d 85       	ldd	r24, Y+13	; 0x0d
    4fc0:	08 2f       	mov	r16, r24
    4fc2:	10 e0       	ldi	r17, 0x00	; 0
    4fc4:	29 85       	ldd	r18, Y+9	; 0x09
    4fc6:	3a 85       	ldd	r19, Y+10	; 0x0a
    4fc8:	c8 01       	movw	r24, r16
    4fca:	88 0f       	add	r24, r24
    4fcc:	99 1f       	adc	r25, r25
    4fce:	88 0f       	add	r24, r24
    4fd0:	99 1f       	adc	r25, r25
    4fd2:	82 0f       	add	r24, r18
    4fd4:	93 1f       	adc	r25, r19
    4fd6:	fc 01       	movw	r30, r24
    4fd8:	b1 96       	adiw	r30, 0x21	; 33
    4fda:	80 81       	ld	r24, Z
    4fdc:	91 81       	ldd	r25, Z+1	; 0x01
    4fde:	a2 81       	ldd	r26, Z+2	; 0x02
    4fe0:	b3 81       	ldd	r27, Z+3	; 0x03
    4fe2:	ac 01       	movw	r20, r24
    4fe4:	bd 01       	movw	r22, r26
    4fe6:	4f 5f       	subi	r20, 0xFF	; 255
    4fe8:	5f 4f       	sbci	r21, 0xFF	; 255
    4fea:	6f 4f       	sbci	r22, 0xFF	; 255
    4fec:	7f 4f       	sbci	r23, 0xFF	; 255
    4fee:	29 85       	ldd	r18, Y+9	; 0x09
    4ff0:	3a 85       	ldd	r19, Y+10	; 0x0a
    4ff2:	c8 01       	movw	r24, r16
    4ff4:	88 0f       	add	r24, r24
    4ff6:	99 1f       	adc	r25, r25
    4ff8:	88 0f       	add	r24, r24
    4ffa:	99 1f       	adc	r25, r25
    4ffc:	82 0f       	add	r24, r18
    4ffe:	93 1f       	adc	r25, r19
    5000:	fc 01       	movw	r30, r24
    5002:	b1 96       	adiw	r30, 0x21	; 33
    5004:	40 83       	st	Z, r20
    5006:	51 83       	std	Z+1, r21	; 0x01
    5008:	62 83       	std	Z+2, r22	; 0x02
    500a:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    500c:	88 85       	ldd	r24, Y+8	; 0x08
    500e:	81 30       	cpi	r24, 0x01	; 1
    5010:	09 f0       	breq	.+2      	; 0x5014 <vTaskGenericNotifyGiveFromISR+0xae>
    5012:	ee c0       	rjmp	.+476    	; 0x51f0 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5014:	80 91 71 06 	lds	r24, 0x0671
    5018:	88 23       	and	r24, r24
    501a:	09 f0       	breq	.+2      	; 0x501e <vTaskGenericNotifyGiveFromISR+0xb8>
    501c:	a4 c0       	rjmp	.+328    	; 0x5166 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    501e:	e9 85       	ldd	r30, Y+9	; 0x09
    5020:	fa 85       	ldd	r31, Y+10	; 0x0a
    5022:	82 85       	ldd	r24, Z+10	; 0x0a
    5024:	93 85       	ldd	r25, Z+11	; 0x0b
    5026:	9e 83       	std	Y+6, r25	; 0x06
    5028:	8d 83       	std	Y+5, r24	; 0x05
    502a:	e9 85       	ldd	r30, Y+9	; 0x09
    502c:	fa 85       	ldd	r31, Y+10	; 0x0a
    502e:	a4 81       	ldd	r26, Z+4	; 0x04
    5030:	b5 81       	ldd	r27, Z+5	; 0x05
    5032:	e9 85       	ldd	r30, Y+9	; 0x09
    5034:	fa 85       	ldd	r31, Y+10	; 0x0a
    5036:	86 81       	ldd	r24, Z+6	; 0x06
    5038:	97 81       	ldd	r25, Z+7	; 0x07
    503a:	15 96       	adiw	r26, 0x05	; 5
    503c:	9c 93       	st	X, r25
    503e:	8e 93       	st	-X, r24
    5040:	14 97       	sbiw	r26, 0x04	; 4
    5042:	e9 85       	ldd	r30, Y+9	; 0x09
    5044:	fa 85       	ldd	r31, Y+10	; 0x0a
    5046:	a6 81       	ldd	r26, Z+6	; 0x06
    5048:	b7 81       	ldd	r27, Z+7	; 0x07
    504a:	e9 85       	ldd	r30, Y+9	; 0x09
    504c:	fa 85       	ldd	r31, Y+10	; 0x0a
    504e:	84 81       	ldd	r24, Z+4	; 0x04
    5050:	95 81       	ldd	r25, Z+5	; 0x05
    5052:	13 96       	adiw	r26, 0x03	; 3
    5054:	9c 93       	st	X, r25
    5056:	8e 93       	st	-X, r24
    5058:	12 97       	sbiw	r26, 0x02	; 2
    505a:	ed 81       	ldd	r30, Y+5	; 0x05
    505c:	fe 81       	ldd	r31, Y+6	; 0x06
    505e:	21 81       	ldd	r18, Z+1	; 0x01
    5060:	32 81       	ldd	r19, Z+2	; 0x02
    5062:	89 85       	ldd	r24, Y+9	; 0x09
    5064:	9a 85       	ldd	r25, Y+10	; 0x0a
    5066:	02 96       	adiw	r24, 0x02	; 2
    5068:	28 17       	cp	r18, r24
    506a:	39 07       	cpc	r19, r25
    506c:	41 f4       	brne	.+16     	; 0x507e <vTaskGenericNotifyGiveFromISR+0x118>
    506e:	e9 85       	ldd	r30, Y+9	; 0x09
    5070:	fa 85       	ldd	r31, Y+10	; 0x0a
    5072:	86 81       	ldd	r24, Z+6	; 0x06
    5074:	97 81       	ldd	r25, Z+7	; 0x07
    5076:	ed 81       	ldd	r30, Y+5	; 0x05
    5078:	fe 81       	ldd	r31, Y+6	; 0x06
    507a:	92 83       	std	Z+2, r25	; 0x02
    507c:	81 83       	std	Z+1, r24	; 0x01
    507e:	e9 85       	ldd	r30, Y+9	; 0x09
    5080:	fa 85       	ldd	r31, Y+10	; 0x0a
    5082:	13 86       	std	Z+11, r1	; 0x0b
    5084:	12 86       	std	Z+10, r1	; 0x0a
    5086:	ed 81       	ldd	r30, Y+5	; 0x05
    5088:	fe 81       	ldd	r31, Y+6	; 0x06
    508a:	80 81       	ld	r24, Z
    508c:	81 50       	subi	r24, 0x01	; 1
    508e:	ed 81       	ldd	r30, Y+5	; 0x05
    5090:	fe 81       	ldd	r31, Y+6	; 0x06
    5092:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5094:	e9 85       	ldd	r30, Y+9	; 0x09
    5096:	fa 85       	ldd	r31, Y+10	; 0x0a
    5098:	96 89       	ldd	r25, Z+22	; 0x16
    509a:	80 91 66 06 	lds	r24, 0x0666
    509e:	89 17       	cp	r24, r25
    50a0:	28 f4       	brcc	.+10     	; 0x50ac <vTaskGenericNotifyGiveFromISR+0x146>
    50a2:	e9 85       	ldd	r30, Y+9	; 0x09
    50a4:	fa 85       	ldd	r31, Y+10	; 0x0a
    50a6:	86 89       	ldd	r24, Z+22	; 0x16
    50a8:	80 93 66 06 	sts	0x0666, r24
    50ac:	e9 85       	ldd	r30, Y+9	; 0x09
    50ae:	fa 85       	ldd	r31, Y+10	; 0x0a
    50b0:	86 89       	ldd	r24, Z+22	; 0x16
    50b2:	28 2f       	mov	r18, r24
    50b4:	30 e0       	ldi	r19, 0x00	; 0
    50b6:	c9 01       	movw	r24, r18
    50b8:	88 0f       	add	r24, r24
    50ba:	99 1f       	adc	r25, r25
    50bc:	88 0f       	add	r24, r24
    50be:	99 1f       	adc	r25, r25
    50c0:	88 0f       	add	r24, r24
    50c2:	99 1f       	adc	r25, r25
    50c4:	82 0f       	add	r24, r18
    50c6:	93 1f       	adc	r25, r19
    50c8:	fc 01       	movw	r30, r24
    50ca:	ee 58       	subi	r30, 0x8E	; 142
    50cc:	f9 4f       	sbci	r31, 0xF9	; 249
    50ce:	81 81       	ldd	r24, Z+1	; 0x01
    50d0:	92 81       	ldd	r25, Z+2	; 0x02
    50d2:	9c 83       	std	Y+4, r25	; 0x04
    50d4:	8b 83       	std	Y+3, r24	; 0x03
    50d6:	e9 85       	ldd	r30, Y+9	; 0x09
    50d8:	fa 85       	ldd	r31, Y+10	; 0x0a
    50da:	8b 81       	ldd	r24, Y+3	; 0x03
    50dc:	9c 81       	ldd	r25, Y+4	; 0x04
    50de:	95 83       	std	Z+5, r25	; 0x05
    50e0:	84 83       	std	Z+4, r24	; 0x04
    50e2:	eb 81       	ldd	r30, Y+3	; 0x03
    50e4:	fc 81       	ldd	r31, Y+4	; 0x04
    50e6:	84 81       	ldd	r24, Z+4	; 0x04
    50e8:	95 81       	ldd	r25, Z+5	; 0x05
    50ea:	e9 85       	ldd	r30, Y+9	; 0x09
    50ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    50ee:	97 83       	std	Z+7, r25	; 0x07
    50f0:	86 83       	std	Z+6, r24	; 0x06
    50f2:	eb 81       	ldd	r30, Y+3	; 0x03
    50f4:	fc 81       	ldd	r31, Y+4	; 0x04
    50f6:	04 80       	ldd	r0, Z+4	; 0x04
    50f8:	f5 81       	ldd	r31, Z+5	; 0x05
    50fa:	e0 2d       	mov	r30, r0
    50fc:	89 85       	ldd	r24, Y+9	; 0x09
    50fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    5100:	02 96       	adiw	r24, 0x02	; 2
    5102:	93 83       	std	Z+3, r25	; 0x03
    5104:	82 83       	std	Z+2, r24	; 0x02
    5106:	89 85       	ldd	r24, Y+9	; 0x09
    5108:	9a 85       	ldd	r25, Y+10	; 0x0a
    510a:	02 96       	adiw	r24, 0x02	; 2
    510c:	eb 81       	ldd	r30, Y+3	; 0x03
    510e:	fc 81       	ldd	r31, Y+4	; 0x04
    5110:	95 83       	std	Z+5, r25	; 0x05
    5112:	84 83       	std	Z+4, r24	; 0x04
    5114:	e9 85       	ldd	r30, Y+9	; 0x09
    5116:	fa 85       	ldd	r31, Y+10	; 0x0a
    5118:	86 89       	ldd	r24, Z+22	; 0x16
    511a:	28 2f       	mov	r18, r24
    511c:	30 e0       	ldi	r19, 0x00	; 0
    511e:	c9 01       	movw	r24, r18
    5120:	88 0f       	add	r24, r24
    5122:	99 1f       	adc	r25, r25
    5124:	88 0f       	add	r24, r24
    5126:	99 1f       	adc	r25, r25
    5128:	88 0f       	add	r24, r24
    512a:	99 1f       	adc	r25, r25
    512c:	82 0f       	add	r24, r18
    512e:	93 1f       	adc	r25, r19
    5130:	8e 58       	subi	r24, 0x8E	; 142
    5132:	99 4f       	sbci	r25, 0xF9	; 249
    5134:	e9 85       	ldd	r30, Y+9	; 0x09
    5136:	fa 85       	ldd	r31, Y+10	; 0x0a
    5138:	93 87       	std	Z+11, r25	; 0x0b
    513a:	82 87       	std	Z+10, r24	; 0x0a
    513c:	e9 85       	ldd	r30, Y+9	; 0x09
    513e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5140:	86 89       	ldd	r24, Z+22	; 0x16
    5142:	28 2f       	mov	r18, r24
    5144:	30 e0       	ldi	r19, 0x00	; 0
    5146:	c9 01       	movw	r24, r18
    5148:	88 0f       	add	r24, r24
    514a:	99 1f       	adc	r25, r25
    514c:	88 0f       	add	r24, r24
    514e:	99 1f       	adc	r25, r25
    5150:	88 0f       	add	r24, r24
    5152:	99 1f       	adc	r25, r25
    5154:	82 0f       	add	r24, r18
    5156:	93 1f       	adc	r25, r19
    5158:	fc 01       	movw	r30, r24
    515a:	ee 58       	subi	r30, 0x8E	; 142
    515c:	f9 4f       	sbci	r31, 0xF9	; 249
    515e:	80 81       	ld	r24, Z
    5160:	8f 5f       	subi	r24, 0xFF	; 255
    5162:	80 83       	st	Z, r24
    5164:	30 c0       	rjmp	.+96     	; 0x51c6 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5166:	80 91 ad 06 	lds	r24, 0x06AD
    516a:	90 91 ae 06 	lds	r25, 0x06AE
    516e:	9a 83       	std	Y+2, r25	; 0x02
    5170:	89 83       	std	Y+1, r24	; 0x01
    5172:	e9 85       	ldd	r30, Y+9	; 0x09
    5174:	fa 85       	ldd	r31, Y+10	; 0x0a
    5176:	89 81       	ldd	r24, Y+1	; 0x01
    5178:	9a 81       	ldd	r25, Y+2	; 0x02
    517a:	97 87       	std	Z+15, r25	; 0x0f
    517c:	86 87       	std	Z+14, r24	; 0x0e
    517e:	e9 81       	ldd	r30, Y+1	; 0x01
    5180:	fa 81       	ldd	r31, Y+2	; 0x02
    5182:	84 81       	ldd	r24, Z+4	; 0x04
    5184:	95 81       	ldd	r25, Z+5	; 0x05
    5186:	e9 85       	ldd	r30, Y+9	; 0x09
    5188:	fa 85       	ldd	r31, Y+10	; 0x0a
    518a:	91 8b       	std	Z+17, r25	; 0x11
    518c:	80 8b       	std	Z+16, r24	; 0x10
    518e:	e9 81       	ldd	r30, Y+1	; 0x01
    5190:	fa 81       	ldd	r31, Y+2	; 0x02
    5192:	04 80       	ldd	r0, Z+4	; 0x04
    5194:	f5 81       	ldd	r31, Z+5	; 0x05
    5196:	e0 2d       	mov	r30, r0
    5198:	89 85       	ldd	r24, Y+9	; 0x09
    519a:	9a 85       	ldd	r25, Y+10	; 0x0a
    519c:	0c 96       	adiw	r24, 0x0c	; 12
    519e:	93 83       	std	Z+3, r25	; 0x03
    51a0:	82 83       	std	Z+2, r24	; 0x02
    51a2:	89 85       	ldd	r24, Y+9	; 0x09
    51a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    51a6:	0c 96       	adiw	r24, 0x0c	; 12
    51a8:	e9 81       	ldd	r30, Y+1	; 0x01
    51aa:	fa 81       	ldd	r31, Y+2	; 0x02
    51ac:	95 83       	std	Z+5, r25	; 0x05
    51ae:	84 83       	std	Z+4, r24	; 0x04
    51b0:	e9 85       	ldd	r30, Y+9	; 0x09
    51b2:	fa 85       	ldd	r31, Y+10	; 0x0a
    51b4:	8c ea       	ldi	r24, 0xAC	; 172
    51b6:	96 e0       	ldi	r25, 0x06	; 6
    51b8:	95 8b       	std	Z+21, r25	; 0x15
    51ba:	84 8b       	std	Z+20, r24	; 0x14
    51bc:	80 91 ac 06 	lds	r24, 0x06AC
    51c0:	8f 5f       	subi	r24, 0xFF	; 255
    51c2:	80 93 ac 06 	sts	0x06AC, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    51c6:	e9 85       	ldd	r30, Y+9	; 0x09
    51c8:	fa 85       	ldd	r31, Y+10	; 0x0a
    51ca:	96 89       	ldd	r25, Z+22	; 0x16
    51cc:	e0 91 60 06 	lds	r30, 0x0660
    51d0:	f0 91 61 06 	lds	r31, 0x0661
    51d4:	86 89       	ldd	r24, Z+22	; 0x16
    51d6:	89 17       	cp	r24, r25
    51d8:	58 f4       	brcc	.+22     	; 0x51f0 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    51da:	8e 85       	ldd	r24, Y+14	; 0x0e
    51dc:	9f 85       	ldd	r25, Y+15	; 0x0f
    51de:	00 97       	sbiw	r24, 0x00	; 0
    51e0:	21 f0       	breq	.+8      	; 0x51ea <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    51e2:	ee 85       	ldd	r30, Y+14	; 0x0e
    51e4:	ff 85       	ldd	r31, Y+15	; 0x0f
    51e6:	81 e0       	ldi	r24, 0x01	; 1
    51e8:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    51ea:	81 e0       	ldi	r24, 0x01	; 1
    51ec:	80 93 6a 06 	sts	0x066A, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    51f0:	2f 96       	adiw	r28, 0x0f	; 15
    51f2:	0f b6       	in	r0, 0x3f	; 63
    51f4:	f8 94       	cli
    51f6:	de bf       	out	0x3e, r29	; 62
    51f8:	0f be       	out	0x3f, r0	; 63
    51fa:	cd bf       	out	0x3d, r28	; 61
    51fc:	cf 91       	pop	r28
    51fe:	df 91       	pop	r29
    5200:	1f 91       	pop	r17
    5202:	0f 91       	pop	r16
    5204:	08 95       	ret

00005206 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5206:	df 93       	push	r29
    5208:	cf 93       	push	r28
    520a:	cd b7       	in	r28, 0x3d	; 61
    520c:	de b7       	in	r29, 0x3e	; 62
    520e:	28 97       	sbiw	r28, 0x08	; 8
    5210:	0f b6       	in	r0, 0x3f	; 63
    5212:	f8 94       	cli
    5214:	de bf       	out	0x3e, r29	; 62
    5216:	0f be       	out	0x3f, r0	; 63
    5218:	cd bf       	out	0x3d, r28	; 61
    521a:	9d 83       	std	Y+5, r25	; 0x05
    521c:	8c 83       	std	Y+4, r24	; 0x04
    521e:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5220:	8c 81       	ldd	r24, Y+4	; 0x04
    5222:	9d 81       	ldd	r25, Y+5	; 0x05
    5224:	00 97       	sbiw	r24, 0x00	; 0
    5226:	39 f4       	brne	.+14     	; 0x5236 <xTaskGenericNotifyStateClear+0x30>
    5228:	80 91 60 06 	lds	r24, 0x0660
    522c:	90 91 61 06 	lds	r25, 0x0661
    5230:	98 87       	std	Y+8, r25	; 0x08
    5232:	8f 83       	std	Y+7, r24	; 0x07
    5234:	04 c0       	rjmp	.+8      	; 0x523e <xTaskGenericNotifyStateClear+0x38>
    5236:	8c 81       	ldd	r24, Y+4	; 0x04
    5238:	9d 81       	ldd	r25, Y+5	; 0x05
    523a:	98 87       	std	Y+8, r25	; 0x08
    523c:	8f 83       	std	Y+7, r24	; 0x07
    523e:	8f 81       	ldd	r24, Y+7	; 0x07
    5240:	98 85       	ldd	r25, Y+8	; 0x08
    5242:	9b 83       	std	Y+3, r25	; 0x03
    5244:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5246:	0f b6       	in	r0, 0x3f	; 63
    5248:	f8 94       	cli
    524a:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    524c:	8e 81       	ldd	r24, Y+6	; 0x06
    524e:	28 2f       	mov	r18, r24
    5250:	30 e0       	ldi	r19, 0x00	; 0
    5252:	8a 81       	ldd	r24, Y+2	; 0x02
    5254:	9b 81       	ldd	r25, Y+3	; 0x03
    5256:	82 0f       	add	r24, r18
    5258:	93 1f       	adc	r25, r19
    525a:	fc 01       	movw	r30, r24
    525c:	b5 96       	adiw	r30, 0x25	; 37
    525e:	80 81       	ld	r24, Z
    5260:	82 30       	cpi	r24, 0x02	; 2
    5262:	69 f4       	brne	.+26     	; 0x527e <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5264:	8e 81       	ldd	r24, Y+6	; 0x06
    5266:	28 2f       	mov	r18, r24
    5268:	30 e0       	ldi	r19, 0x00	; 0
    526a:	8a 81       	ldd	r24, Y+2	; 0x02
    526c:	9b 81       	ldd	r25, Y+3	; 0x03
    526e:	82 0f       	add	r24, r18
    5270:	93 1f       	adc	r25, r19
    5272:	fc 01       	movw	r30, r24
    5274:	b5 96       	adiw	r30, 0x25	; 37
    5276:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5278:	81 e0       	ldi	r24, 0x01	; 1
    527a:	89 83       	std	Y+1, r24	; 0x01
    527c:	01 c0       	rjmp	.+2      	; 0x5280 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    527e:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5280:	0f 90       	pop	r0
    5282:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5284:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5286:	28 96       	adiw	r28, 0x08	; 8
    5288:	0f b6       	in	r0, 0x3f	; 63
    528a:	f8 94       	cli
    528c:	de bf       	out	0x3e, r29	; 62
    528e:	0f be       	out	0x3f, r0	; 63
    5290:	cd bf       	out	0x3d, r28	; 61
    5292:	cf 91       	pop	r28
    5294:	df 91       	pop	r29
    5296:	08 95       	ret

00005298 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5298:	0f 93       	push	r16
    529a:	1f 93       	push	r17
    529c:	df 93       	push	r29
    529e:	cf 93       	push	r28
    52a0:	cd b7       	in	r28, 0x3d	; 61
    52a2:	de b7       	in	r29, 0x3e	; 62
    52a4:	2f 97       	sbiw	r28, 0x0f	; 15
    52a6:	0f b6       	in	r0, 0x3f	; 63
    52a8:	f8 94       	cli
    52aa:	de bf       	out	0x3e, r29	; 62
    52ac:	0f be       	out	0x3f, r0	; 63
    52ae:	cd bf       	out	0x3d, r28	; 61
    52b0:	98 87       	std	Y+8, r25	; 0x08
    52b2:	8f 83       	std	Y+7, r24	; 0x07
    52b4:	69 87       	std	Y+9, r22	; 0x09
    52b6:	2a 87       	std	Y+10, r18	; 0x0a
    52b8:	3b 87       	std	Y+11, r19	; 0x0b
    52ba:	4c 87       	std	Y+12, r20	; 0x0c
    52bc:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    52be:	8f 81       	ldd	r24, Y+7	; 0x07
    52c0:	98 85       	ldd	r25, Y+8	; 0x08
    52c2:	00 97       	sbiw	r24, 0x00	; 0
    52c4:	39 f4       	brne	.+14     	; 0x52d4 <ulTaskGenericNotifyValueClear+0x3c>
    52c6:	80 91 60 06 	lds	r24, 0x0660
    52ca:	90 91 61 06 	lds	r25, 0x0661
    52ce:	9f 87       	std	Y+15, r25	; 0x0f
    52d0:	8e 87       	std	Y+14, r24	; 0x0e
    52d2:	04 c0       	rjmp	.+8      	; 0x52dc <ulTaskGenericNotifyValueClear+0x44>
    52d4:	8f 81       	ldd	r24, Y+7	; 0x07
    52d6:	98 85       	ldd	r25, Y+8	; 0x08
    52d8:	9f 87       	std	Y+15, r25	; 0x0f
    52da:	8e 87       	std	Y+14, r24	; 0x0e
    52dc:	8e 85       	ldd	r24, Y+14	; 0x0e
    52de:	9f 85       	ldd	r25, Y+15	; 0x0f
    52e0:	9e 83       	std	Y+6, r25	; 0x06
    52e2:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    52e4:	0f b6       	in	r0, 0x3f	; 63
    52e6:	f8 94       	cli
    52e8:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    52ea:	89 85       	ldd	r24, Y+9	; 0x09
    52ec:	88 2f       	mov	r24, r24
    52ee:	90 e0       	ldi	r25, 0x00	; 0
    52f0:	2d 81       	ldd	r18, Y+5	; 0x05
    52f2:	3e 81       	ldd	r19, Y+6	; 0x06
    52f4:	88 0f       	add	r24, r24
    52f6:	99 1f       	adc	r25, r25
    52f8:	88 0f       	add	r24, r24
    52fa:	99 1f       	adc	r25, r25
    52fc:	82 0f       	add	r24, r18
    52fe:	93 1f       	adc	r25, r19
    5300:	fc 01       	movw	r30, r24
    5302:	b1 96       	adiw	r30, 0x21	; 33
    5304:	80 81       	ld	r24, Z
    5306:	91 81       	ldd	r25, Z+1	; 0x01
    5308:	a2 81       	ldd	r26, Z+2	; 0x02
    530a:	b3 81       	ldd	r27, Z+3	; 0x03
    530c:	89 83       	std	Y+1, r24	; 0x01
    530e:	9a 83       	std	Y+2, r25	; 0x02
    5310:	ab 83       	std	Y+3, r26	; 0x03
    5312:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5314:	89 85       	ldd	r24, Y+9	; 0x09
    5316:	08 2f       	mov	r16, r24
    5318:	10 e0       	ldi	r17, 0x00	; 0
    531a:	89 85       	ldd	r24, Y+9	; 0x09
    531c:	88 2f       	mov	r24, r24
    531e:	90 e0       	ldi	r25, 0x00	; 0
    5320:	2d 81       	ldd	r18, Y+5	; 0x05
    5322:	3e 81       	ldd	r19, Y+6	; 0x06
    5324:	88 0f       	add	r24, r24
    5326:	99 1f       	adc	r25, r25
    5328:	88 0f       	add	r24, r24
    532a:	99 1f       	adc	r25, r25
    532c:	82 0f       	add	r24, r18
    532e:	93 1f       	adc	r25, r19
    5330:	fc 01       	movw	r30, r24
    5332:	b1 96       	adiw	r30, 0x21	; 33
    5334:	20 81       	ld	r18, Z
    5336:	31 81       	ldd	r19, Z+1	; 0x01
    5338:	42 81       	ldd	r20, Z+2	; 0x02
    533a:	53 81       	ldd	r21, Z+3	; 0x03
    533c:	8a 85       	ldd	r24, Y+10	; 0x0a
    533e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5340:	ac 85       	ldd	r26, Y+12	; 0x0c
    5342:	bd 85       	ldd	r27, Y+13	; 0x0d
    5344:	80 95       	com	r24
    5346:	90 95       	com	r25
    5348:	a0 95       	com	r26
    534a:	b0 95       	com	r27
    534c:	ba 01       	movw	r22, r20
    534e:	a9 01       	movw	r20, r18
    5350:	48 23       	and	r20, r24
    5352:	59 23       	and	r21, r25
    5354:	6a 23       	and	r22, r26
    5356:	7b 23       	and	r23, r27
    5358:	2d 81       	ldd	r18, Y+5	; 0x05
    535a:	3e 81       	ldd	r19, Y+6	; 0x06
    535c:	c8 01       	movw	r24, r16
    535e:	88 0f       	add	r24, r24
    5360:	99 1f       	adc	r25, r25
    5362:	88 0f       	add	r24, r24
    5364:	99 1f       	adc	r25, r25
    5366:	82 0f       	add	r24, r18
    5368:	93 1f       	adc	r25, r19
    536a:	fc 01       	movw	r30, r24
    536c:	b1 96       	adiw	r30, 0x21	; 33
    536e:	40 83       	st	Z, r20
    5370:	51 83       	std	Z+1, r21	; 0x01
    5372:	62 83       	std	Z+2, r22	; 0x02
    5374:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5376:	0f 90       	pop	r0
    5378:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    537a:	89 81       	ldd	r24, Y+1	; 0x01
    537c:	9a 81       	ldd	r25, Y+2	; 0x02
    537e:	ab 81       	ldd	r26, Y+3	; 0x03
    5380:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5382:	bc 01       	movw	r22, r24
    5384:	cd 01       	movw	r24, r26
    5386:	2f 96       	adiw	r28, 0x0f	; 15
    5388:	0f b6       	in	r0, 0x3f	; 63
    538a:	f8 94       	cli
    538c:	de bf       	out	0x3e, r29	; 62
    538e:	0f be       	out	0x3f, r0	; 63
    5390:	cd bf       	out	0x3d, r28	; 61
    5392:	cf 91       	pop	r28
    5394:	df 91       	pop	r29
    5396:	1f 91       	pop	r17
    5398:	0f 91       	pop	r16
    539a:	08 95       	ret

0000539c <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    539c:	df 93       	push	r29
    539e:	cf 93       	push	r28
    53a0:	cd b7       	in	r28, 0x3d	; 61
    53a2:	de b7       	in	r29, 0x3e	; 62
    53a4:	27 97       	sbiw	r28, 0x07	; 7
    53a6:	0f b6       	in	r0, 0x3f	; 63
    53a8:	f8 94       	cli
    53aa:	de bf       	out	0x3e, r29	; 62
    53ac:	0f be       	out	0x3f, r0	; 63
    53ae:	cd bf       	out	0x3d, r28	; 61
    53b0:	9e 83       	std	Y+6, r25	; 0x06
    53b2:	8d 83       	std	Y+5, r24	; 0x05
    53b4:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    53b6:	80 91 64 06 	lds	r24, 0x0664
    53ba:	90 91 65 06 	lds	r25, 0x0665
    53be:	9a 83       	std	Y+2, r25	; 0x02
    53c0:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    53c2:	80 91 60 06 	lds	r24, 0x0660
    53c6:	90 91 61 06 	lds	r25, 0x0661
    53ca:	02 96       	adiw	r24, 0x02	; 2
    53cc:	0e 94 41 05 	call	0xa82	; 0xa82 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    53d0:	29 81       	ldd	r18, Y+1	; 0x01
    53d2:	3a 81       	ldd	r19, Y+2	; 0x02
    53d4:	8d 81       	ldd	r24, Y+5	; 0x05
    53d6:	9e 81       	ldd	r25, Y+6	; 0x06
    53d8:	82 0f       	add	r24, r18
    53da:	93 1f       	adc	r25, r19
    53dc:	9c 83       	std	Y+4, r25	; 0x04
    53de:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    53e0:	e0 91 60 06 	lds	r30, 0x0660
    53e4:	f0 91 61 06 	lds	r31, 0x0661
    53e8:	8b 81       	ldd	r24, Y+3	; 0x03
    53ea:	9c 81       	ldd	r25, Y+4	; 0x04
    53ec:	93 83       	std	Z+3, r25	; 0x03
    53ee:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    53f0:	2b 81       	ldd	r18, Y+3	; 0x03
    53f2:	3c 81       	ldd	r19, Y+4	; 0x04
    53f4:	89 81       	ldd	r24, Y+1	; 0x01
    53f6:	9a 81       	ldd	r25, Y+2	; 0x02
    53f8:	28 17       	cp	r18, r24
    53fa:	39 07       	cpc	r19, r25
    53fc:	70 f4       	brcc	.+28     	; 0x541a <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    53fe:	80 91 aa 06 	lds	r24, 0x06AA
    5402:	90 91 ab 06 	lds	r25, 0x06AB
    5406:	20 91 60 06 	lds	r18, 0x0660
    540a:	30 91 61 06 	lds	r19, 0x0661
    540e:	2e 5f       	subi	r18, 0xFE	; 254
    5410:	3f 4f       	sbci	r19, 0xFF	; 255
    5412:	b9 01       	movw	r22, r18
    5414:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListInsert>
    5418:	1e c0       	rjmp	.+60     	; 0x5456 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    541a:	40 91 a8 06 	lds	r20, 0x06A8
    541e:	50 91 a9 06 	lds	r21, 0x06A9
    5422:	80 91 60 06 	lds	r24, 0x0660
    5426:	90 91 61 06 	lds	r25, 0x0661
    542a:	9c 01       	movw	r18, r24
    542c:	2e 5f       	subi	r18, 0xFE	; 254
    542e:	3f 4f       	sbci	r19, 0xFF	; 255
    5430:	ca 01       	movw	r24, r20
    5432:	b9 01       	movw	r22, r18
    5434:	0e 94 d5 04 	call	0x9aa	; 0x9aa <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    5438:	20 91 6d 06 	lds	r18, 0x066D
    543c:	30 91 6e 06 	lds	r19, 0x066E
    5440:	8b 81       	ldd	r24, Y+3	; 0x03
    5442:	9c 81       	ldd	r25, Y+4	; 0x04
    5444:	82 17       	cp	r24, r18
    5446:	93 07       	cpc	r25, r19
    5448:	30 f4       	brcc	.+12     	; 0x5456 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    544a:	8b 81       	ldd	r24, Y+3	; 0x03
    544c:	9c 81       	ldd	r25, Y+4	; 0x04
    544e:	90 93 6e 06 	sts	0x066E, r25
    5452:	80 93 6d 06 	sts	0x066D, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    5456:	27 96       	adiw	r28, 0x07	; 7
    5458:	0f b6       	in	r0, 0x3f	; 63
    545a:	f8 94       	cli
    545c:	de bf       	out	0x3e, r29	; 62
    545e:	0f be       	out	0x3f, r0	; 63
    5460:	cd bf       	out	0x3d, r28	; 61
    5462:	cf 91       	pop	r28
    5464:	df 91       	pop	r29
    5466:	08 95       	ret

00005468 <DIO_enuInit>:


/*****************************************************************/

ES_t DIO_enuInit(void)
{
    5468:	df 93       	push	r29
    546a:	cf 93       	push	r28
    546c:	0f 92       	push	r0
    546e:	cd b7       	in	r28, 0x3d	; 61
    5470:	de b7       	in	r29, 0x3e	; 62
	/*At first set the error state variable by "NOT OK" state*/
	ES_t Local_enuErrorState = ES_NOK;
    5472:	81 e0       	ldi	r24, 0x01	; 1
    5474:	89 83       	std	Y+1, r24	; 0x01

	/*Setting the directions of all pins*/
	DDRA=CONC(PA_PIN7_DIR,PA_PIN6_DIR,PA_PIN5_DIR,PA_PIN4_DIR,PA_PIN3_DIR,PA_PIN2_DIR,PA_PIN1_DIR,PA_PIN0_DIR);
    5476:	ea e3       	ldi	r30, 0x3A	; 58
    5478:	f0 e0       	ldi	r31, 0x00	; 0
    547a:	8f ef       	ldi	r24, 0xFF	; 255
    547c:	80 83       	st	Z, r24
	DDRB=CONC(PB_PIN7_DIR,PB_PIN6_DIR,PB_PIN5_DIR,PB_PIN4_DIR,PB_PIN3_DIR,PB_PIN2_DIR,PB_PIN1_DIR,PB_PIN0_DIR);
    547e:	e7 e3       	ldi	r30, 0x37	; 55
    5480:	f0 e0       	ldi	r31, 0x00	; 0
    5482:	8f ef       	ldi	r24, 0xFF	; 255
    5484:	80 83       	st	Z, r24
	DDRC=CONC(PC_PIN7_DIR,PC_PIN6_DIR,PC_PIN5_DIR,PC_PIN4_DIR,PC_PIN3_DIR,PC_PIN2_DIR,PC_PIN1_DIR,PC_PIN0_DIR);
    5486:	e4 e3       	ldi	r30, 0x34	; 52
    5488:	f0 e0       	ldi	r31, 0x00	; 0
    548a:	8f ef       	ldi	r24, 0xFF	; 255
    548c:	80 83       	st	Z, r24
	DDRD=CONC(PD_PIN7_DIR,PD_PIN6_DIR,PD_PIN5_DIR,PD_PIN4_DIR,PD_PIN3_DIR,PD_PIN2_DIR,PD_PIN1_DIR,PD_PIN0_DIR);
    548e:	e1 e3       	ldi	r30, 0x31	; 49
    5490:	f0 e0       	ldi	r31, 0x00	; 0
    5492:	10 82       	st	Z, r1

	/*Set a value for each pin*/
	PORTA=CONC(PA_PIN7_VAL,PA_PIN6_VAL,PA_PIN5_VAL,PA_PIN4_VAL,PA_PIN3_VAL,PA_PIN2_VAL,PA_PIN1_VAL,PA_PIN0_VAL);
    5494:	eb e3       	ldi	r30, 0x3B	; 59
    5496:	f0 e0       	ldi	r31, 0x00	; 0
    5498:	10 82       	st	Z, r1
	PORTB=CONC(PB_PIN7_VAL,PB_PIN6_VAL,PB_PIN5_VAL,PB_PIN4_VAL,PB_PIN3_VAL,PB_PIN2_VAL,PB_PIN1_VAL,PB_PIN0_VAL);
    549a:	e8 e3       	ldi	r30, 0x38	; 56
    549c:	f0 e0       	ldi	r31, 0x00	; 0
    549e:	8f ef       	ldi	r24, 0xFF	; 255
    54a0:	80 83       	st	Z, r24
	PORTC=CONC(PC_PIN7_VAL,PC_PIN6_VAL,PC_PIN5_VAL,PC_PIN4_VAL,PC_PIN3_VAL,PC_PIN2_VAL,PC_PIN1_VAL,PC_PIN0_VAL);
    54a2:	e5 e3       	ldi	r30, 0x35	; 53
    54a4:	f0 e0       	ldi	r31, 0x00	; 0
    54a6:	8f ef       	ldi	r24, 0xFF	; 255
    54a8:	80 83       	st	Z, r24
	PORTD=CONC(PD_PIN7_VAL,PD_PIN6_VAL,PD_PIN5_VAL,PD_PIN4_VAL,PD_PIN3_VAL,PD_PIN2_VAL,PD_PIN1_VAL,PD_PIN0_VAL);
    54aa:	e2 e3       	ldi	r30, 0x32	; 50
    54ac:	f0 e0       	ldi	r31, 0x00	; 0
    54ae:	8f ef       	ldi	r24, 0xFF	; 255
    54b0:	80 83       	st	Z, r24

	/*After all set the error state variable by "OK" state*/
	Local_enuErrorState = ES_OK;
    54b2:	19 82       	std	Y+1, r1	; 0x01

	/*Then return error state variable*/
	return Local_enuErrorState;
    54b4:	89 81       	ldd	r24, Y+1	; 0x01
}//End of DIO_enuInit()
    54b6:	0f 90       	pop	r0
    54b8:	cf 91       	pop	r28
    54ba:	df 91       	pop	r29
    54bc:	08 95       	ret

000054be <DIO_enuSetPortDirection>:


/*****************************************************************/

ES_t DIO_enuSetPortDirection(u8 Copy_u8PortID , u8 Copy_u8PortDir)
{
    54be:	df 93       	push	r29
    54c0:	cf 93       	push	r28
    54c2:	00 d0       	rcall	.+0      	; 0x54c4 <DIO_enuSetPortDirection+0x6>
    54c4:	00 d0       	rcall	.+0      	; 0x54c6 <DIO_enuSetPortDirection+0x8>
    54c6:	0f 92       	push	r0
    54c8:	cd b7       	in	r28, 0x3d	; 61
    54ca:	de b7       	in	r29, 0x3e	; 62
    54cc:	8a 83       	std	Y+2, r24	; 0x02
    54ce:	6b 83       	std	Y+3, r22	; 0x03
	ES_t Local_enuErrorState = ES_NOK;
    54d0:	81 e0       	ldi	r24, 0x01	; 1
    54d2:	89 83       	std	Y+1, r24	; 0x01

	switch(Copy_u8PortID)
    54d4:	8a 81       	ldd	r24, Y+2	; 0x02
    54d6:	28 2f       	mov	r18, r24
    54d8:	30 e0       	ldi	r19, 0x00	; 0
    54da:	3d 83       	std	Y+5, r19	; 0x05
    54dc:	2c 83       	std	Y+4, r18	; 0x04
    54de:	8c 81       	ldd	r24, Y+4	; 0x04
    54e0:	9d 81       	ldd	r25, Y+5	; 0x05
    54e2:	81 30       	cpi	r24, 0x01	; 1
    54e4:	91 05       	cpc	r25, r1
    54e6:	d9 f0       	breq	.+54     	; 0x551e <DIO_enuSetPortDirection+0x60>
    54e8:	2c 81       	ldd	r18, Y+4	; 0x04
    54ea:	3d 81       	ldd	r19, Y+5	; 0x05
    54ec:	22 30       	cpi	r18, 0x02	; 2
    54ee:	31 05       	cpc	r19, r1
    54f0:	2c f4       	brge	.+10     	; 0x54fc <DIO_enuSetPortDirection+0x3e>
    54f2:	8c 81       	ldd	r24, Y+4	; 0x04
    54f4:	9d 81       	ldd	r25, Y+5	; 0x05
    54f6:	00 97       	sbiw	r24, 0x00	; 0
    54f8:	61 f0       	breq	.+24     	; 0x5512 <DIO_enuSetPortDirection+0x54>
    54fa:	23 c0       	rjmp	.+70     	; 0x5542 <DIO_enuSetPortDirection+0x84>
    54fc:	2c 81       	ldd	r18, Y+4	; 0x04
    54fe:	3d 81       	ldd	r19, Y+5	; 0x05
    5500:	22 30       	cpi	r18, 0x02	; 2
    5502:	31 05       	cpc	r19, r1
    5504:	91 f0       	breq	.+36     	; 0x552a <DIO_enuSetPortDirection+0x6c>
    5506:	8c 81       	ldd	r24, Y+4	; 0x04
    5508:	9d 81       	ldd	r25, Y+5	; 0x05
    550a:	83 30       	cpi	r24, 0x03	; 3
    550c:	91 05       	cpc	r25, r1
    550e:	99 f0       	breq	.+38     	; 0x5536 <DIO_enuSetPortDirection+0x78>
    5510:	18 c0       	rjmp	.+48     	; 0x5542 <DIO_enuSetPortDirection+0x84>
	{
	case DIO_PORTA :
		DDRA =Copy_u8PortDir;
    5512:	ea e3       	ldi	r30, 0x3A	; 58
    5514:	f0 e0       	ldi	r31, 0x00	; 0
    5516:	8b 81       	ldd	r24, Y+3	; 0x03
    5518:	80 83       	st	Z, r24
		Local_enuErrorState = ES_OK;
    551a:	19 82       	std	Y+1, r1	; 0x01
    551c:	14 c0       	rjmp	.+40     	; 0x5546 <DIO_enuSetPortDirection+0x88>
		break;
	case DIO_PORTB :
		DDRB =Copy_u8PortDir;
    551e:	e7 e3       	ldi	r30, 0x37	; 55
    5520:	f0 e0       	ldi	r31, 0x00	; 0
    5522:	8b 81       	ldd	r24, Y+3	; 0x03
    5524:	80 83       	st	Z, r24
		Local_enuErrorState = ES_OK;
    5526:	19 82       	std	Y+1, r1	; 0x01
    5528:	0e c0       	rjmp	.+28     	; 0x5546 <DIO_enuSetPortDirection+0x88>
		break;
	case DIO_PORTC :
		DDRC =Copy_u8PortDir;
    552a:	e4 e3       	ldi	r30, 0x34	; 52
    552c:	f0 e0       	ldi	r31, 0x00	; 0
    552e:	8b 81       	ldd	r24, Y+3	; 0x03
    5530:	80 83       	st	Z, r24
		Local_enuErrorState = ES_OK;
    5532:	19 82       	std	Y+1, r1	; 0x01
    5534:	08 c0       	rjmp	.+16     	; 0x5546 <DIO_enuSetPortDirection+0x88>
		break;
	case DIO_PORTD :
		DDRD =Copy_u8PortDir;
    5536:	e1 e3       	ldi	r30, 0x31	; 49
    5538:	f0 e0       	ldi	r31, 0x00	; 0
    553a:	8b 81       	ldd	r24, Y+3	; 0x03
    553c:	80 83       	st	Z, r24
		Local_enuErrorState = ES_OK;
    553e:	19 82       	std	Y+1, r1	; 0x01
    5540:	02 c0       	rjmp	.+4      	; 0x5546 <DIO_enuSetPortDirection+0x88>
		break;
	default :
		Local_enuErrorState = ES_OUT_OF_RANGE;
    5542:	83 e0       	ldi	r24, 0x03	; 3
    5544:	89 83       	std	Y+1, r24	; 0x01
		break;
	}

	return Local_enuErrorState;
    5546:	89 81       	ldd	r24, Y+1	; 0x01
}
    5548:	0f 90       	pop	r0
    554a:	0f 90       	pop	r0
    554c:	0f 90       	pop	r0
    554e:	0f 90       	pop	r0
    5550:	0f 90       	pop	r0
    5552:	cf 91       	pop	r28
    5554:	df 91       	pop	r29
    5556:	08 95       	ret

00005558 <DIO_enuSetPortValue>:
/*****************************************************************/

ES_t DIO_enuSetPortValue(u8 Copy_u8PortID , u8 Copy_u8Value)
{
    5558:	df 93       	push	r29
    555a:	cf 93       	push	r28
    555c:	00 d0       	rcall	.+0      	; 0x555e <DIO_enuSetPortValue+0x6>
    555e:	00 d0       	rcall	.+0      	; 0x5560 <DIO_enuSetPortValue+0x8>
    5560:	0f 92       	push	r0
    5562:	cd b7       	in	r28, 0x3d	; 61
    5564:	de b7       	in	r29, 0x3e	; 62
    5566:	8a 83       	std	Y+2, r24	; 0x02
    5568:	6b 83       	std	Y+3, r22	; 0x03
	ES_t Local_enuErrorState = ES_NOK;
    556a:	81 e0       	ldi	r24, 0x01	; 1
    556c:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortID)
    556e:	8a 81       	ldd	r24, Y+2	; 0x02
    5570:	28 2f       	mov	r18, r24
    5572:	30 e0       	ldi	r19, 0x00	; 0
    5574:	3d 83       	std	Y+5, r19	; 0x05
    5576:	2c 83       	std	Y+4, r18	; 0x04
    5578:	8c 81       	ldd	r24, Y+4	; 0x04
    557a:	9d 81       	ldd	r25, Y+5	; 0x05
    557c:	81 30       	cpi	r24, 0x01	; 1
    557e:	91 05       	cpc	r25, r1
    5580:	d9 f0       	breq	.+54     	; 0x55b8 <DIO_enuSetPortValue+0x60>
    5582:	2c 81       	ldd	r18, Y+4	; 0x04
    5584:	3d 81       	ldd	r19, Y+5	; 0x05
    5586:	22 30       	cpi	r18, 0x02	; 2
    5588:	31 05       	cpc	r19, r1
    558a:	2c f4       	brge	.+10     	; 0x5596 <DIO_enuSetPortValue+0x3e>
    558c:	8c 81       	ldd	r24, Y+4	; 0x04
    558e:	9d 81       	ldd	r25, Y+5	; 0x05
    5590:	00 97       	sbiw	r24, 0x00	; 0
    5592:	61 f0       	breq	.+24     	; 0x55ac <DIO_enuSetPortValue+0x54>
    5594:	23 c0       	rjmp	.+70     	; 0x55dc <DIO_enuSetPortValue+0x84>
    5596:	2c 81       	ldd	r18, Y+4	; 0x04
    5598:	3d 81       	ldd	r19, Y+5	; 0x05
    559a:	22 30       	cpi	r18, 0x02	; 2
    559c:	31 05       	cpc	r19, r1
    559e:	91 f0       	breq	.+36     	; 0x55c4 <DIO_enuSetPortValue+0x6c>
    55a0:	8c 81       	ldd	r24, Y+4	; 0x04
    55a2:	9d 81       	ldd	r25, Y+5	; 0x05
    55a4:	83 30       	cpi	r24, 0x03	; 3
    55a6:	91 05       	cpc	r25, r1
    55a8:	99 f0       	breq	.+38     	; 0x55d0 <DIO_enuSetPortValue+0x78>
    55aa:	18 c0       	rjmp	.+48     	; 0x55dc <DIO_enuSetPortValue+0x84>
	{
	case DIO_PORTA :
		PORTA =Copy_u8Value;
    55ac:	eb e3       	ldi	r30, 0x3B	; 59
    55ae:	f0 e0       	ldi	r31, 0x00	; 0
    55b0:	8b 81       	ldd	r24, Y+3	; 0x03
    55b2:	80 83       	st	Z, r24
		Local_enuErrorState = ES_OK;
    55b4:	19 82       	std	Y+1, r1	; 0x01
    55b6:	14 c0       	rjmp	.+40     	; 0x55e0 <DIO_enuSetPortValue+0x88>
		break;
	case DIO_PORTB :
		PORTB =Copy_u8Value;
    55b8:	e8 e3       	ldi	r30, 0x38	; 56
    55ba:	f0 e0       	ldi	r31, 0x00	; 0
    55bc:	8b 81       	ldd	r24, Y+3	; 0x03
    55be:	80 83       	st	Z, r24
		Local_enuErrorState = ES_OK;
    55c0:	19 82       	std	Y+1, r1	; 0x01
    55c2:	0e c0       	rjmp	.+28     	; 0x55e0 <DIO_enuSetPortValue+0x88>
		break;
	case DIO_PORTC :
		PORTC =Copy_u8Value;
    55c4:	e5 e3       	ldi	r30, 0x35	; 53
    55c6:	f0 e0       	ldi	r31, 0x00	; 0
    55c8:	8b 81       	ldd	r24, Y+3	; 0x03
    55ca:	80 83       	st	Z, r24
		Local_enuErrorState = ES_OK;
    55cc:	19 82       	std	Y+1, r1	; 0x01
    55ce:	08 c0       	rjmp	.+16     	; 0x55e0 <DIO_enuSetPortValue+0x88>
		break;
	case DIO_PORTD :
		PORTD =Copy_u8Value;
    55d0:	e2 e3       	ldi	r30, 0x32	; 50
    55d2:	f0 e0       	ldi	r31, 0x00	; 0
    55d4:	8b 81       	ldd	r24, Y+3	; 0x03
    55d6:	80 83       	st	Z, r24
		Local_enuErrorState = ES_OK;
    55d8:	19 82       	std	Y+1, r1	; 0x01
    55da:	02 c0       	rjmp	.+4      	; 0x55e0 <DIO_enuSetPortValue+0x88>
		break;
	default :
		Local_enuErrorState = ES_OUT_OF_RANGE;
    55dc:	83 e0       	ldi	r24, 0x03	; 3
    55de:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Local_enuErrorState;
    55e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    55e2:	0f 90       	pop	r0
    55e4:	0f 90       	pop	r0
    55e6:	0f 90       	pop	r0
    55e8:	0f 90       	pop	r0
    55ea:	0f 90       	pop	r0
    55ec:	cf 91       	pop	r28
    55ee:	df 91       	pop	r29
    55f0:	08 95       	ret

000055f2 <DIO_enuTogPort>:
/*****************************************************************/

ES_t DIO_enuTogPort(u8 Copy_u8PortID)
{
    55f2:	df 93       	push	r29
    55f4:	cf 93       	push	r28
    55f6:	00 d0       	rcall	.+0      	; 0x55f8 <DIO_enuTogPort+0x6>
    55f8:	00 d0       	rcall	.+0      	; 0x55fa <DIO_enuTogPort+0x8>
    55fa:	cd b7       	in	r28, 0x3d	; 61
    55fc:	de b7       	in	r29, 0x3e	; 62
    55fe:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    5600:	81 e0       	ldi	r24, 0x01	; 1
    5602:	89 83       	std	Y+1, r24	; 0x01

	switch(Copy_u8PortID)
    5604:	8a 81       	ldd	r24, Y+2	; 0x02
    5606:	28 2f       	mov	r18, r24
    5608:	30 e0       	ldi	r19, 0x00	; 0
    560a:	3c 83       	std	Y+4, r19	; 0x04
    560c:	2b 83       	std	Y+3, r18	; 0x03
    560e:	8b 81       	ldd	r24, Y+3	; 0x03
    5610:	9c 81       	ldd	r25, Y+4	; 0x04
    5612:	81 30       	cpi	r24, 0x01	; 1
    5614:	91 05       	cpc	r25, r1
    5616:	f1 f0       	breq	.+60     	; 0x5654 <DIO_enuTogPort+0x62>
    5618:	2b 81       	ldd	r18, Y+3	; 0x03
    561a:	3c 81       	ldd	r19, Y+4	; 0x04
    561c:	22 30       	cpi	r18, 0x02	; 2
    561e:	31 05       	cpc	r19, r1
    5620:	2c f4       	brge	.+10     	; 0x562c <DIO_enuTogPort+0x3a>
    5622:	8b 81       	ldd	r24, Y+3	; 0x03
    5624:	9c 81       	ldd	r25, Y+4	; 0x04
    5626:	00 97       	sbiw	r24, 0x00	; 0
    5628:	61 f0       	breq	.+24     	; 0x5642 <DIO_enuTogPort+0x50>
    562a:	2f c0       	rjmp	.+94     	; 0x568a <DIO_enuTogPort+0x98>
    562c:	2b 81       	ldd	r18, Y+3	; 0x03
    562e:	3c 81       	ldd	r19, Y+4	; 0x04
    5630:	22 30       	cpi	r18, 0x02	; 2
    5632:	31 05       	cpc	r19, r1
    5634:	c1 f0       	breq	.+48     	; 0x5666 <DIO_enuTogPort+0x74>
    5636:	8b 81       	ldd	r24, Y+3	; 0x03
    5638:	9c 81       	ldd	r25, Y+4	; 0x04
    563a:	83 30       	cpi	r24, 0x03	; 3
    563c:	91 05       	cpc	r25, r1
    563e:	e1 f0       	breq	.+56     	; 0x5678 <DIO_enuTogPort+0x86>
    5640:	24 c0       	rjmp	.+72     	; 0x568a <DIO_enuTogPort+0x98>
	{
	case DIO_PORTA :
		PORTA = ~PORTA;
    5642:	ab e3       	ldi	r26, 0x3B	; 59
    5644:	b0 e0       	ldi	r27, 0x00	; 0
    5646:	eb e3       	ldi	r30, 0x3B	; 59
    5648:	f0 e0       	ldi	r31, 0x00	; 0
    564a:	80 81       	ld	r24, Z
    564c:	80 95       	com	r24
    564e:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    5650:	19 82       	std	Y+1, r1	; 0x01
    5652:	1d c0       	rjmp	.+58     	; 0x568e <DIO_enuTogPort+0x9c>
		break;
	case DIO_PORTB :
		PORTB = ~PORTB;
    5654:	a8 e3       	ldi	r26, 0x38	; 56
    5656:	b0 e0       	ldi	r27, 0x00	; 0
    5658:	e8 e3       	ldi	r30, 0x38	; 56
    565a:	f0 e0       	ldi	r31, 0x00	; 0
    565c:	80 81       	ld	r24, Z
    565e:	80 95       	com	r24
    5660:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    5662:	19 82       	std	Y+1, r1	; 0x01
    5664:	14 c0       	rjmp	.+40     	; 0x568e <DIO_enuTogPort+0x9c>
		break;
	case DIO_PORTC :
		PORTC = ~PORTC;
    5666:	a5 e3       	ldi	r26, 0x35	; 53
    5668:	b0 e0       	ldi	r27, 0x00	; 0
    566a:	e5 e3       	ldi	r30, 0x35	; 53
    566c:	f0 e0       	ldi	r31, 0x00	; 0
    566e:	80 81       	ld	r24, Z
    5670:	80 95       	com	r24
    5672:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    5674:	19 82       	std	Y+1, r1	; 0x01
    5676:	0b c0       	rjmp	.+22     	; 0x568e <DIO_enuTogPort+0x9c>
		break;
	case DIO_PORTD :
		PORTD = ~PORTD;
    5678:	a2 e3       	ldi	r26, 0x32	; 50
    567a:	b0 e0       	ldi	r27, 0x00	; 0
    567c:	e2 e3       	ldi	r30, 0x32	; 50
    567e:	f0 e0       	ldi	r31, 0x00	; 0
    5680:	80 81       	ld	r24, Z
    5682:	80 95       	com	r24
    5684:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    5686:	19 82       	std	Y+1, r1	; 0x01
    5688:	02 c0       	rjmp	.+4      	; 0x568e <DIO_enuTogPort+0x9c>
		break;
	default :
		Local_enuErrorState = ES_OUT_OF_RANGE;
    568a:	83 e0       	ldi	r24, 0x03	; 3
    568c:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Local_enuErrorState;
    568e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5690:	0f 90       	pop	r0
    5692:	0f 90       	pop	r0
    5694:	0f 90       	pop	r0
    5696:	0f 90       	pop	r0
    5698:	cf 91       	pop	r28
    569a:	df 91       	pop	r29
    569c:	08 95       	ret

0000569e <DIO_enuGetPortValue>:
/*****************************************************************/

ES_t DIO_enuGetPortValue(u8 Copy_u8PortID , u8* Copy_pu8Value)
{
    569e:	df 93       	push	r29
    56a0:	cf 93       	push	r28
    56a2:	00 d0       	rcall	.+0      	; 0x56a4 <DIO_enuGetPortValue+0x6>
    56a4:	00 d0       	rcall	.+0      	; 0x56a6 <DIO_enuGetPortValue+0x8>
    56a6:	00 d0       	rcall	.+0      	; 0x56a8 <DIO_enuGetPortValue+0xa>
    56a8:	cd b7       	in	r28, 0x3d	; 61
    56aa:	de b7       	in	r29, 0x3e	; 62
    56ac:	8a 83       	std	Y+2, r24	; 0x02
    56ae:	7c 83       	std	Y+4, r23	; 0x04
    56b0:	6b 83       	std	Y+3, r22	; 0x03
	ES_t Local_enuErrorState = ES_NOK;
    56b2:	81 e0       	ldi	r24, 0x01	; 1
    56b4:	89 83       	std	Y+1, r24	; 0x01

	if(Copy_pu8Value != NULL)
    56b6:	8b 81       	ldd	r24, Y+3	; 0x03
    56b8:	9c 81       	ldd	r25, Y+4	; 0x04
    56ba:	00 97       	sbiw	r24, 0x00	; 0
    56bc:	09 f4       	brne	.+2      	; 0x56c0 <DIO_enuGetPortValue+0x22>
    56be:	42 c0       	rjmp	.+132    	; 0x5744 <DIO_enuGetPortValue+0xa6>
	{
		switch(Copy_u8PortID)
    56c0:	8a 81       	ldd	r24, Y+2	; 0x02
    56c2:	28 2f       	mov	r18, r24
    56c4:	30 e0       	ldi	r19, 0x00	; 0
    56c6:	3e 83       	std	Y+6, r19	; 0x06
    56c8:	2d 83       	std	Y+5, r18	; 0x05
    56ca:	8d 81       	ldd	r24, Y+5	; 0x05
    56cc:	9e 81       	ldd	r25, Y+6	; 0x06
    56ce:	81 30       	cpi	r24, 0x01	; 1
    56d0:	91 05       	cpc	r25, r1
    56d2:	e9 f0       	breq	.+58     	; 0x570e <DIO_enuGetPortValue+0x70>
    56d4:	2d 81       	ldd	r18, Y+5	; 0x05
    56d6:	3e 81       	ldd	r19, Y+6	; 0x06
    56d8:	22 30       	cpi	r18, 0x02	; 2
    56da:	31 05       	cpc	r19, r1
    56dc:	2c f4       	brge	.+10     	; 0x56e8 <DIO_enuGetPortValue+0x4a>
    56de:	8d 81       	ldd	r24, Y+5	; 0x05
    56e0:	9e 81       	ldd	r25, Y+6	; 0x06
    56e2:	00 97       	sbiw	r24, 0x00	; 0
    56e4:	61 f0       	breq	.+24     	; 0x56fe <DIO_enuGetPortValue+0x60>
    56e6:	2b c0       	rjmp	.+86     	; 0x573e <DIO_enuGetPortValue+0xa0>
    56e8:	2d 81       	ldd	r18, Y+5	; 0x05
    56ea:	3e 81       	ldd	r19, Y+6	; 0x06
    56ec:	22 30       	cpi	r18, 0x02	; 2
    56ee:	31 05       	cpc	r19, r1
    56f0:	b1 f0       	breq	.+44     	; 0x571e <DIO_enuGetPortValue+0x80>
    56f2:	8d 81       	ldd	r24, Y+5	; 0x05
    56f4:	9e 81       	ldd	r25, Y+6	; 0x06
    56f6:	83 30       	cpi	r24, 0x03	; 3
    56f8:	91 05       	cpc	r25, r1
    56fa:	c9 f0       	breq	.+50     	; 0x572e <DIO_enuGetPortValue+0x90>
    56fc:	20 c0       	rjmp	.+64     	; 0x573e <DIO_enuGetPortValue+0xa0>
		{
		case DIO_PORTA:
			*Copy_pu8Value = PINA;
    56fe:	e9 e3       	ldi	r30, 0x39	; 57
    5700:	f0 e0       	ldi	r31, 0x00	; 0
    5702:	80 81       	ld	r24, Z
    5704:	eb 81       	ldd	r30, Y+3	; 0x03
    5706:	fc 81       	ldd	r31, Y+4	; 0x04
    5708:	80 83       	st	Z, r24
			Local_enuErrorState = ES_OK;
    570a:	19 82       	std	Y+1, r1	; 0x01
    570c:	1d c0       	rjmp	.+58     	; 0x5748 <DIO_enuGetPortValue+0xaa>
			break;
		case DIO_PORTB:
			*Copy_pu8Value = PIND;
    570e:	e0 e3       	ldi	r30, 0x30	; 48
    5710:	f0 e0       	ldi	r31, 0x00	; 0
    5712:	80 81       	ld	r24, Z
    5714:	eb 81       	ldd	r30, Y+3	; 0x03
    5716:	fc 81       	ldd	r31, Y+4	; 0x04
    5718:	80 83       	st	Z, r24
			Local_enuErrorState = ES_OK;
    571a:	19 82       	std	Y+1, r1	; 0x01
    571c:	15 c0       	rjmp	.+42     	; 0x5748 <DIO_enuGetPortValue+0xaa>
			break;
		case DIO_PORTC:
			*Copy_pu8Value = PINC;
    571e:	e3 e3       	ldi	r30, 0x33	; 51
    5720:	f0 e0       	ldi	r31, 0x00	; 0
    5722:	80 81       	ld	r24, Z
    5724:	eb 81       	ldd	r30, Y+3	; 0x03
    5726:	fc 81       	ldd	r31, Y+4	; 0x04
    5728:	80 83       	st	Z, r24
			Local_enuErrorState = ES_OK;
    572a:	19 82       	std	Y+1, r1	; 0x01
    572c:	0d c0       	rjmp	.+26     	; 0x5748 <DIO_enuGetPortValue+0xaa>
			break;
		case DIO_PORTD:
			*Copy_pu8Value = PIND;
    572e:	e0 e3       	ldi	r30, 0x30	; 48
    5730:	f0 e0       	ldi	r31, 0x00	; 0
    5732:	80 81       	ld	r24, Z
    5734:	eb 81       	ldd	r30, Y+3	; 0x03
    5736:	fc 81       	ldd	r31, Y+4	; 0x04
    5738:	80 83       	st	Z, r24
			Local_enuErrorState = ES_OK;
    573a:	19 82       	std	Y+1, r1	; 0x01
    573c:	05 c0       	rjmp	.+10     	; 0x5748 <DIO_enuGetPortValue+0xaa>
			break;
		default :
			Local_enuErrorState = ES_OUT_OF_RANGE;
    573e:	83 e0       	ldi	r24, 0x03	; 3
    5740:	89 83       	std	Y+1, r24	; 0x01
    5742:	02 c0       	rjmp	.+4      	; 0x5748 <DIO_enuGetPortValue+0xaa>
			break;
		}
	}
	else
	{
		Local_enuErrorState = ES_NULL_POINTER;
    5744:	82 e0       	ldi	r24, 0x02	; 2
    5746:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_enuErrorState;
    5748:	89 81       	ldd	r24, Y+1	; 0x01
}
    574a:	26 96       	adiw	r28, 0x06	; 6
    574c:	0f b6       	in	r0, 0x3f	; 63
    574e:	f8 94       	cli
    5750:	de bf       	out	0x3e, r29	; 62
    5752:	0f be       	out	0x3f, r0	; 63
    5754:	cd bf       	out	0x3d, r28	; 61
    5756:	cf 91       	pop	r28
    5758:	df 91       	pop	r29
    575a:	08 95       	ret

0000575c <DIO_enuSetPinDirection>:
/*****************************************************************/

ES_t DIO_enuSetPinDirection(u8 Copy_u8PortID ,u8 Copy_u8PinID , u8 Copy_u8PinDir)
{
    575c:	df 93       	push	r29
    575e:	cf 93       	push	r28
    5760:	00 d0       	rcall	.+0      	; 0x5762 <DIO_enuSetPinDirection+0x6>
    5762:	00 d0       	rcall	.+0      	; 0x5764 <DIO_enuSetPinDirection+0x8>
    5764:	00 d0       	rcall	.+0      	; 0x5766 <DIO_enuSetPinDirection+0xa>
    5766:	cd b7       	in	r28, 0x3d	; 61
    5768:	de b7       	in	r29, 0x3e	; 62
    576a:	8a 83       	std	Y+2, r24	; 0x02
    576c:	6b 83       	std	Y+3, r22	; 0x03
    576e:	4c 83       	std	Y+4, r20	; 0x04
	ES_t Local_enuErrorState = ES_NOK;
    5770:	81 e0       	ldi	r24, 0x01	; 1
    5772:	89 83       	std	Y+1, r24	; 0x01

	if(Copy_u8PinID <= DIO_PIN7 && Copy_u8PinDir<=OUTPUT)
    5774:	8b 81       	ldd	r24, Y+3	; 0x03
    5776:	88 30       	cpi	r24, 0x08	; 8
    5778:	08 f0       	brcs	.+2      	; 0x577c <DIO_enuSetPinDirection+0x20>
    577a:	d2 c0       	rjmp	.+420    	; 0x5920 <DIO_enuSetPinDirection+0x1c4>
    577c:	8c 81       	ldd	r24, Y+4	; 0x04
    577e:	82 30       	cpi	r24, 0x02	; 2
    5780:	08 f0       	brcs	.+2      	; 0x5784 <DIO_enuSetPinDirection+0x28>
    5782:	ce c0       	rjmp	.+412    	; 0x5920 <DIO_enuSetPinDirection+0x1c4>
	{
		switch(Copy_u8PortID)
    5784:	8a 81       	ldd	r24, Y+2	; 0x02
    5786:	28 2f       	mov	r18, r24
    5788:	30 e0       	ldi	r19, 0x00	; 0
    578a:	3e 83       	std	Y+6, r19	; 0x06
    578c:	2d 83       	std	Y+5, r18	; 0x05
    578e:	6d 81       	ldd	r22, Y+5	; 0x05
    5790:	7e 81       	ldd	r23, Y+6	; 0x06
    5792:	61 30       	cpi	r22, 0x01	; 1
    5794:	71 05       	cpc	r23, r1
    5796:	09 f4       	brne	.+2      	; 0x579a <DIO_enuSetPinDirection+0x3e>
    5798:	42 c0       	rjmp	.+132    	; 0x581e <DIO_enuSetPinDirection+0xc2>
    579a:	8d 81       	ldd	r24, Y+5	; 0x05
    579c:	9e 81       	ldd	r25, Y+6	; 0x06
    579e:	82 30       	cpi	r24, 0x02	; 2
    57a0:	91 05       	cpc	r25, r1
    57a2:	34 f4       	brge	.+12     	; 0x57b0 <DIO_enuSetPinDirection+0x54>
    57a4:	2d 81       	ldd	r18, Y+5	; 0x05
    57a6:	3e 81       	ldd	r19, Y+6	; 0x06
    57a8:	21 15       	cp	r18, r1
    57aa:	31 05       	cpc	r19, r1
    57ac:	71 f0       	breq	.+28     	; 0x57ca <DIO_enuSetPinDirection+0x6e>
    57ae:	b5 c0       	rjmp	.+362    	; 0x591a <DIO_enuSetPinDirection+0x1be>
    57b0:	6d 81       	ldd	r22, Y+5	; 0x05
    57b2:	7e 81       	ldd	r23, Y+6	; 0x06
    57b4:	62 30       	cpi	r22, 0x02	; 2
    57b6:	71 05       	cpc	r23, r1
    57b8:	09 f4       	brne	.+2      	; 0x57bc <DIO_enuSetPinDirection+0x60>
    57ba:	5b c0       	rjmp	.+182    	; 0x5872 <DIO_enuSetPinDirection+0x116>
    57bc:	8d 81       	ldd	r24, Y+5	; 0x05
    57be:	9e 81       	ldd	r25, Y+6	; 0x06
    57c0:	83 30       	cpi	r24, 0x03	; 3
    57c2:	91 05       	cpc	r25, r1
    57c4:	09 f4       	brne	.+2      	; 0x57c8 <DIO_enuSetPinDirection+0x6c>
    57c6:	7f c0       	rjmp	.+254    	; 0x58c6 <DIO_enuSetPinDirection+0x16a>
    57c8:	a8 c0       	rjmp	.+336    	; 0x591a <DIO_enuSetPinDirection+0x1be>
		{
		case DIO_PORTA:
			DDRA &=~(1<<Copy_u8PinID); //clear bit
    57ca:	aa e3       	ldi	r26, 0x3A	; 58
    57cc:	b0 e0       	ldi	r27, 0x00	; 0
    57ce:	ea e3       	ldi	r30, 0x3A	; 58
    57d0:	f0 e0       	ldi	r31, 0x00	; 0
    57d2:	80 81       	ld	r24, Z
    57d4:	48 2f       	mov	r20, r24
    57d6:	8b 81       	ldd	r24, Y+3	; 0x03
    57d8:	28 2f       	mov	r18, r24
    57da:	30 e0       	ldi	r19, 0x00	; 0
    57dc:	81 e0       	ldi	r24, 0x01	; 1
    57de:	90 e0       	ldi	r25, 0x00	; 0
    57e0:	02 c0       	rjmp	.+4      	; 0x57e6 <DIO_enuSetPinDirection+0x8a>
    57e2:	88 0f       	add	r24, r24
    57e4:	99 1f       	adc	r25, r25
    57e6:	2a 95       	dec	r18
    57e8:	e2 f7       	brpl	.-8      	; 0x57e2 <DIO_enuSetPinDirection+0x86>
    57ea:	80 95       	com	r24
    57ec:	84 23       	and	r24, r20
    57ee:	8c 93       	st	X, r24
			DDRA |=(Copy_u8PinDir<<Copy_u8PinID); //bit or with the value
    57f0:	aa e3       	ldi	r26, 0x3A	; 58
    57f2:	b0 e0       	ldi	r27, 0x00	; 0
    57f4:	ea e3       	ldi	r30, 0x3A	; 58
    57f6:	f0 e0       	ldi	r31, 0x00	; 0
    57f8:	80 81       	ld	r24, Z
    57fa:	48 2f       	mov	r20, r24
    57fc:	8c 81       	ldd	r24, Y+4	; 0x04
    57fe:	28 2f       	mov	r18, r24
    5800:	30 e0       	ldi	r19, 0x00	; 0
    5802:	8b 81       	ldd	r24, Y+3	; 0x03
    5804:	88 2f       	mov	r24, r24
    5806:	90 e0       	ldi	r25, 0x00	; 0
    5808:	b9 01       	movw	r22, r18
    580a:	02 c0       	rjmp	.+4      	; 0x5810 <DIO_enuSetPinDirection+0xb4>
    580c:	66 0f       	add	r22, r22
    580e:	77 1f       	adc	r23, r23
    5810:	8a 95       	dec	r24
    5812:	e2 f7       	brpl	.-8      	; 0x580c <DIO_enuSetPinDirection+0xb0>
    5814:	cb 01       	movw	r24, r22
    5816:	84 2b       	or	r24, r20
    5818:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    581a:	19 82       	std	Y+1, r1	; 0x01
    581c:	83 c0       	rjmp	.+262    	; 0x5924 <DIO_enuSetPinDirection+0x1c8>
			break;
		case DIO_PORTB:
			DDRB &=~(1<<Copy_u8PinID);
    581e:	a7 e3       	ldi	r26, 0x37	; 55
    5820:	b0 e0       	ldi	r27, 0x00	; 0
    5822:	e7 e3       	ldi	r30, 0x37	; 55
    5824:	f0 e0       	ldi	r31, 0x00	; 0
    5826:	80 81       	ld	r24, Z
    5828:	48 2f       	mov	r20, r24
    582a:	8b 81       	ldd	r24, Y+3	; 0x03
    582c:	28 2f       	mov	r18, r24
    582e:	30 e0       	ldi	r19, 0x00	; 0
    5830:	81 e0       	ldi	r24, 0x01	; 1
    5832:	90 e0       	ldi	r25, 0x00	; 0
    5834:	02 c0       	rjmp	.+4      	; 0x583a <DIO_enuSetPinDirection+0xde>
    5836:	88 0f       	add	r24, r24
    5838:	99 1f       	adc	r25, r25
    583a:	2a 95       	dec	r18
    583c:	e2 f7       	brpl	.-8      	; 0x5836 <DIO_enuSetPinDirection+0xda>
    583e:	80 95       	com	r24
    5840:	84 23       	and	r24, r20
    5842:	8c 93       	st	X, r24
			DDRB |=(Copy_u8PinDir<<Copy_u8PinID);
    5844:	a7 e3       	ldi	r26, 0x37	; 55
    5846:	b0 e0       	ldi	r27, 0x00	; 0
    5848:	e7 e3       	ldi	r30, 0x37	; 55
    584a:	f0 e0       	ldi	r31, 0x00	; 0
    584c:	80 81       	ld	r24, Z
    584e:	48 2f       	mov	r20, r24
    5850:	8c 81       	ldd	r24, Y+4	; 0x04
    5852:	28 2f       	mov	r18, r24
    5854:	30 e0       	ldi	r19, 0x00	; 0
    5856:	8b 81       	ldd	r24, Y+3	; 0x03
    5858:	88 2f       	mov	r24, r24
    585a:	90 e0       	ldi	r25, 0x00	; 0
    585c:	b9 01       	movw	r22, r18
    585e:	02 c0       	rjmp	.+4      	; 0x5864 <DIO_enuSetPinDirection+0x108>
    5860:	66 0f       	add	r22, r22
    5862:	77 1f       	adc	r23, r23
    5864:	8a 95       	dec	r24
    5866:	e2 f7       	brpl	.-8      	; 0x5860 <DIO_enuSetPinDirection+0x104>
    5868:	cb 01       	movw	r24, r22
    586a:	84 2b       	or	r24, r20
    586c:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    586e:	19 82       	std	Y+1, r1	; 0x01
    5870:	59 c0       	rjmp	.+178    	; 0x5924 <DIO_enuSetPinDirection+0x1c8>
			break;
		case DIO_PORTC:
			DDRC &=~(1<<Copy_u8PinID);
    5872:	a4 e3       	ldi	r26, 0x34	; 52
    5874:	b0 e0       	ldi	r27, 0x00	; 0
    5876:	e4 e3       	ldi	r30, 0x34	; 52
    5878:	f0 e0       	ldi	r31, 0x00	; 0
    587a:	80 81       	ld	r24, Z
    587c:	48 2f       	mov	r20, r24
    587e:	8b 81       	ldd	r24, Y+3	; 0x03
    5880:	28 2f       	mov	r18, r24
    5882:	30 e0       	ldi	r19, 0x00	; 0
    5884:	81 e0       	ldi	r24, 0x01	; 1
    5886:	90 e0       	ldi	r25, 0x00	; 0
    5888:	02 c0       	rjmp	.+4      	; 0x588e <DIO_enuSetPinDirection+0x132>
    588a:	88 0f       	add	r24, r24
    588c:	99 1f       	adc	r25, r25
    588e:	2a 95       	dec	r18
    5890:	e2 f7       	brpl	.-8      	; 0x588a <DIO_enuSetPinDirection+0x12e>
    5892:	80 95       	com	r24
    5894:	84 23       	and	r24, r20
    5896:	8c 93       	st	X, r24
			DDRC |=(Copy_u8PinDir<<Copy_u8PinID);
    5898:	a4 e3       	ldi	r26, 0x34	; 52
    589a:	b0 e0       	ldi	r27, 0x00	; 0
    589c:	e4 e3       	ldi	r30, 0x34	; 52
    589e:	f0 e0       	ldi	r31, 0x00	; 0
    58a0:	80 81       	ld	r24, Z
    58a2:	48 2f       	mov	r20, r24
    58a4:	8c 81       	ldd	r24, Y+4	; 0x04
    58a6:	28 2f       	mov	r18, r24
    58a8:	30 e0       	ldi	r19, 0x00	; 0
    58aa:	8b 81       	ldd	r24, Y+3	; 0x03
    58ac:	88 2f       	mov	r24, r24
    58ae:	90 e0       	ldi	r25, 0x00	; 0
    58b0:	b9 01       	movw	r22, r18
    58b2:	02 c0       	rjmp	.+4      	; 0x58b8 <DIO_enuSetPinDirection+0x15c>
    58b4:	66 0f       	add	r22, r22
    58b6:	77 1f       	adc	r23, r23
    58b8:	8a 95       	dec	r24
    58ba:	e2 f7       	brpl	.-8      	; 0x58b4 <DIO_enuSetPinDirection+0x158>
    58bc:	cb 01       	movw	r24, r22
    58be:	84 2b       	or	r24, r20
    58c0:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    58c2:	19 82       	std	Y+1, r1	; 0x01
    58c4:	2f c0       	rjmp	.+94     	; 0x5924 <DIO_enuSetPinDirection+0x1c8>
			break;
		case DIO_PORTD:
			DDRD &=~(1<<Copy_u8PinID);
    58c6:	a1 e3       	ldi	r26, 0x31	; 49
    58c8:	b0 e0       	ldi	r27, 0x00	; 0
    58ca:	e1 e3       	ldi	r30, 0x31	; 49
    58cc:	f0 e0       	ldi	r31, 0x00	; 0
    58ce:	80 81       	ld	r24, Z
    58d0:	48 2f       	mov	r20, r24
    58d2:	8b 81       	ldd	r24, Y+3	; 0x03
    58d4:	28 2f       	mov	r18, r24
    58d6:	30 e0       	ldi	r19, 0x00	; 0
    58d8:	81 e0       	ldi	r24, 0x01	; 1
    58da:	90 e0       	ldi	r25, 0x00	; 0
    58dc:	02 c0       	rjmp	.+4      	; 0x58e2 <DIO_enuSetPinDirection+0x186>
    58de:	88 0f       	add	r24, r24
    58e0:	99 1f       	adc	r25, r25
    58e2:	2a 95       	dec	r18
    58e4:	e2 f7       	brpl	.-8      	; 0x58de <DIO_enuSetPinDirection+0x182>
    58e6:	80 95       	com	r24
    58e8:	84 23       	and	r24, r20
    58ea:	8c 93       	st	X, r24
			DDRD |=(Copy_u8PinDir<<Copy_u8PinID);
    58ec:	a1 e3       	ldi	r26, 0x31	; 49
    58ee:	b0 e0       	ldi	r27, 0x00	; 0
    58f0:	e1 e3       	ldi	r30, 0x31	; 49
    58f2:	f0 e0       	ldi	r31, 0x00	; 0
    58f4:	80 81       	ld	r24, Z
    58f6:	48 2f       	mov	r20, r24
    58f8:	8c 81       	ldd	r24, Y+4	; 0x04
    58fa:	28 2f       	mov	r18, r24
    58fc:	30 e0       	ldi	r19, 0x00	; 0
    58fe:	8b 81       	ldd	r24, Y+3	; 0x03
    5900:	88 2f       	mov	r24, r24
    5902:	90 e0       	ldi	r25, 0x00	; 0
    5904:	b9 01       	movw	r22, r18
    5906:	02 c0       	rjmp	.+4      	; 0x590c <DIO_enuSetPinDirection+0x1b0>
    5908:	66 0f       	add	r22, r22
    590a:	77 1f       	adc	r23, r23
    590c:	8a 95       	dec	r24
    590e:	e2 f7       	brpl	.-8      	; 0x5908 <DIO_enuSetPinDirection+0x1ac>
    5910:	cb 01       	movw	r24, r22
    5912:	84 2b       	or	r24, r20
    5914:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    5916:	19 82       	std	Y+1, r1	; 0x01
    5918:	05 c0       	rjmp	.+10     	; 0x5924 <DIO_enuSetPinDirection+0x1c8>
			break;
		default :
			Local_enuErrorState = ES_OUT_OF_RANGE;
    591a:	83 e0       	ldi	r24, 0x03	; 3
    591c:	89 83       	std	Y+1, r24	; 0x01
    591e:	02 c0       	rjmp	.+4      	; 0x5924 <DIO_enuSetPinDirection+0x1c8>
			break;
		}
	}
	else
	{
		Local_enuErrorState = ES_OUT_OF_RANGE;
    5920:	83 e0       	ldi	r24, 0x03	; 3
    5922:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_enuErrorState;
    5924:	89 81       	ldd	r24, Y+1	; 0x01
}
    5926:	26 96       	adiw	r28, 0x06	; 6
    5928:	0f b6       	in	r0, 0x3f	; 63
    592a:	f8 94       	cli
    592c:	de bf       	out	0x3e, r29	; 62
    592e:	0f be       	out	0x3f, r0	; 63
    5930:	cd bf       	out	0x3d, r28	; 61
    5932:	cf 91       	pop	r28
    5934:	df 91       	pop	r29
    5936:	08 95       	ret

00005938 <DIO_enuSetPinValue>:

/*****************************************************************/
ES_t DIO_enuSetPinValue(u8 Copy_u8PortID ,u8 Copy_u8PinID , u8 Copy_u8Value)
{
    5938:	df 93       	push	r29
    593a:	cf 93       	push	r28
    593c:	00 d0       	rcall	.+0      	; 0x593e <DIO_enuSetPinValue+0x6>
    593e:	00 d0       	rcall	.+0      	; 0x5940 <DIO_enuSetPinValue+0x8>
    5940:	00 d0       	rcall	.+0      	; 0x5942 <DIO_enuSetPinValue+0xa>
    5942:	cd b7       	in	r28, 0x3d	; 61
    5944:	de b7       	in	r29, 0x3e	; 62
    5946:	8a 83       	std	Y+2, r24	; 0x02
    5948:	6b 83       	std	Y+3, r22	; 0x03
    594a:	4c 83       	std	Y+4, r20	; 0x04
	ES_t Local_enuErrorState = ES_NOK;
    594c:	81 e0       	ldi	r24, 0x01	; 1
    594e:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinID <= DIO_PIN7 && Copy_u8Value<=OUTPUT)
    5950:	8b 81       	ldd	r24, Y+3	; 0x03
    5952:	88 30       	cpi	r24, 0x08	; 8
    5954:	08 f0       	brcs	.+2      	; 0x5958 <DIO_enuSetPinValue+0x20>
    5956:	d2 c0       	rjmp	.+420    	; 0x5afc <DIO_enuSetPinValue+0x1c4>
    5958:	8c 81       	ldd	r24, Y+4	; 0x04
    595a:	82 30       	cpi	r24, 0x02	; 2
    595c:	08 f0       	brcs	.+2      	; 0x5960 <DIO_enuSetPinValue+0x28>
    595e:	ce c0       	rjmp	.+412    	; 0x5afc <DIO_enuSetPinValue+0x1c4>
	{
		switch(Copy_u8PortID)
    5960:	8a 81       	ldd	r24, Y+2	; 0x02
    5962:	28 2f       	mov	r18, r24
    5964:	30 e0       	ldi	r19, 0x00	; 0
    5966:	3e 83       	std	Y+6, r19	; 0x06
    5968:	2d 83       	std	Y+5, r18	; 0x05
    596a:	6d 81       	ldd	r22, Y+5	; 0x05
    596c:	7e 81       	ldd	r23, Y+6	; 0x06
    596e:	61 30       	cpi	r22, 0x01	; 1
    5970:	71 05       	cpc	r23, r1
    5972:	09 f4       	brne	.+2      	; 0x5976 <DIO_enuSetPinValue+0x3e>
    5974:	42 c0       	rjmp	.+132    	; 0x59fa <DIO_enuSetPinValue+0xc2>
    5976:	8d 81       	ldd	r24, Y+5	; 0x05
    5978:	9e 81       	ldd	r25, Y+6	; 0x06
    597a:	82 30       	cpi	r24, 0x02	; 2
    597c:	91 05       	cpc	r25, r1
    597e:	34 f4       	brge	.+12     	; 0x598c <DIO_enuSetPinValue+0x54>
    5980:	2d 81       	ldd	r18, Y+5	; 0x05
    5982:	3e 81       	ldd	r19, Y+6	; 0x06
    5984:	21 15       	cp	r18, r1
    5986:	31 05       	cpc	r19, r1
    5988:	71 f0       	breq	.+28     	; 0x59a6 <DIO_enuSetPinValue+0x6e>
    598a:	b5 c0       	rjmp	.+362    	; 0x5af6 <DIO_enuSetPinValue+0x1be>
    598c:	6d 81       	ldd	r22, Y+5	; 0x05
    598e:	7e 81       	ldd	r23, Y+6	; 0x06
    5990:	62 30       	cpi	r22, 0x02	; 2
    5992:	71 05       	cpc	r23, r1
    5994:	09 f4       	brne	.+2      	; 0x5998 <DIO_enuSetPinValue+0x60>
    5996:	5b c0       	rjmp	.+182    	; 0x5a4e <DIO_enuSetPinValue+0x116>
    5998:	8d 81       	ldd	r24, Y+5	; 0x05
    599a:	9e 81       	ldd	r25, Y+6	; 0x06
    599c:	83 30       	cpi	r24, 0x03	; 3
    599e:	91 05       	cpc	r25, r1
    59a0:	09 f4       	brne	.+2      	; 0x59a4 <DIO_enuSetPinValue+0x6c>
    59a2:	7f c0       	rjmp	.+254    	; 0x5aa2 <DIO_enuSetPinValue+0x16a>
    59a4:	a8 c0       	rjmp	.+336    	; 0x5af6 <DIO_enuSetPinValue+0x1be>
		{
		case DIO_PORTA:
			PORTA &=~(1<<Copy_u8PinID);
    59a6:	ab e3       	ldi	r26, 0x3B	; 59
    59a8:	b0 e0       	ldi	r27, 0x00	; 0
    59aa:	eb e3       	ldi	r30, 0x3B	; 59
    59ac:	f0 e0       	ldi	r31, 0x00	; 0
    59ae:	80 81       	ld	r24, Z
    59b0:	48 2f       	mov	r20, r24
    59b2:	8b 81       	ldd	r24, Y+3	; 0x03
    59b4:	28 2f       	mov	r18, r24
    59b6:	30 e0       	ldi	r19, 0x00	; 0
    59b8:	81 e0       	ldi	r24, 0x01	; 1
    59ba:	90 e0       	ldi	r25, 0x00	; 0
    59bc:	02 c0       	rjmp	.+4      	; 0x59c2 <DIO_enuSetPinValue+0x8a>
    59be:	88 0f       	add	r24, r24
    59c0:	99 1f       	adc	r25, r25
    59c2:	2a 95       	dec	r18
    59c4:	e2 f7       	brpl	.-8      	; 0x59be <DIO_enuSetPinValue+0x86>
    59c6:	80 95       	com	r24
    59c8:	84 23       	and	r24, r20
    59ca:	8c 93       	st	X, r24
			PORTA |=(Copy_u8Value<<Copy_u8PinID);
    59cc:	ab e3       	ldi	r26, 0x3B	; 59
    59ce:	b0 e0       	ldi	r27, 0x00	; 0
    59d0:	eb e3       	ldi	r30, 0x3B	; 59
    59d2:	f0 e0       	ldi	r31, 0x00	; 0
    59d4:	80 81       	ld	r24, Z
    59d6:	48 2f       	mov	r20, r24
    59d8:	8c 81       	ldd	r24, Y+4	; 0x04
    59da:	28 2f       	mov	r18, r24
    59dc:	30 e0       	ldi	r19, 0x00	; 0
    59de:	8b 81       	ldd	r24, Y+3	; 0x03
    59e0:	88 2f       	mov	r24, r24
    59e2:	90 e0       	ldi	r25, 0x00	; 0
    59e4:	b9 01       	movw	r22, r18
    59e6:	02 c0       	rjmp	.+4      	; 0x59ec <DIO_enuSetPinValue+0xb4>
    59e8:	66 0f       	add	r22, r22
    59ea:	77 1f       	adc	r23, r23
    59ec:	8a 95       	dec	r24
    59ee:	e2 f7       	brpl	.-8      	; 0x59e8 <DIO_enuSetPinValue+0xb0>
    59f0:	cb 01       	movw	r24, r22
    59f2:	84 2b       	or	r24, r20
    59f4:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    59f6:	19 82       	std	Y+1, r1	; 0x01
    59f8:	83 c0       	rjmp	.+262    	; 0x5b00 <DIO_enuSetPinValue+0x1c8>
			break;
		case DIO_PORTB:
			PORTB &=~(1<<Copy_u8PinID);
    59fa:	a8 e3       	ldi	r26, 0x38	; 56
    59fc:	b0 e0       	ldi	r27, 0x00	; 0
    59fe:	e8 e3       	ldi	r30, 0x38	; 56
    5a00:	f0 e0       	ldi	r31, 0x00	; 0
    5a02:	80 81       	ld	r24, Z
    5a04:	48 2f       	mov	r20, r24
    5a06:	8b 81       	ldd	r24, Y+3	; 0x03
    5a08:	28 2f       	mov	r18, r24
    5a0a:	30 e0       	ldi	r19, 0x00	; 0
    5a0c:	81 e0       	ldi	r24, 0x01	; 1
    5a0e:	90 e0       	ldi	r25, 0x00	; 0
    5a10:	02 c0       	rjmp	.+4      	; 0x5a16 <DIO_enuSetPinValue+0xde>
    5a12:	88 0f       	add	r24, r24
    5a14:	99 1f       	adc	r25, r25
    5a16:	2a 95       	dec	r18
    5a18:	e2 f7       	brpl	.-8      	; 0x5a12 <DIO_enuSetPinValue+0xda>
    5a1a:	80 95       	com	r24
    5a1c:	84 23       	and	r24, r20
    5a1e:	8c 93       	st	X, r24
			PORTB |=(Copy_u8Value<<Copy_u8PinID);
    5a20:	a8 e3       	ldi	r26, 0x38	; 56
    5a22:	b0 e0       	ldi	r27, 0x00	; 0
    5a24:	e8 e3       	ldi	r30, 0x38	; 56
    5a26:	f0 e0       	ldi	r31, 0x00	; 0
    5a28:	80 81       	ld	r24, Z
    5a2a:	48 2f       	mov	r20, r24
    5a2c:	8c 81       	ldd	r24, Y+4	; 0x04
    5a2e:	28 2f       	mov	r18, r24
    5a30:	30 e0       	ldi	r19, 0x00	; 0
    5a32:	8b 81       	ldd	r24, Y+3	; 0x03
    5a34:	88 2f       	mov	r24, r24
    5a36:	90 e0       	ldi	r25, 0x00	; 0
    5a38:	b9 01       	movw	r22, r18
    5a3a:	02 c0       	rjmp	.+4      	; 0x5a40 <DIO_enuSetPinValue+0x108>
    5a3c:	66 0f       	add	r22, r22
    5a3e:	77 1f       	adc	r23, r23
    5a40:	8a 95       	dec	r24
    5a42:	e2 f7       	brpl	.-8      	; 0x5a3c <DIO_enuSetPinValue+0x104>
    5a44:	cb 01       	movw	r24, r22
    5a46:	84 2b       	or	r24, r20
    5a48:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    5a4a:	19 82       	std	Y+1, r1	; 0x01
    5a4c:	59 c0       	rjmp	.+178    	; 0x5b00 <DIO_enuSetPinValue+0x1c8>
			break;
		case DIO_PORTC:
			PORTC &=~(1<<Copy_u8PinID);
    5a4e:	a5 e3       	ldi	r26, 0x35	; 53
    5a50:	b0 e0       	ldi	r27, 0x00	; 0
    5a52:	e5 e3       	ldi	r30, 0x35	; 53
    5a54:	f0 e0       	ldi	r31, 0x00	; 0
    5a56:	80 81       	ld	r24, Z
    5a58:	48 2f       	mov	r20, r24
    5a5a:	8b 81       	ldd	r24, Y+3	; 0x03
    5a5c:	28 2f       	mov	r18, r24
    5a5e:	30 e0       	ldi	r19, 0x00	; 0
    5a60:	81 e0       	ldi	r24, 0x01	; 1
    5a62:	90 e0       	ldi	r25, 0x00	; 0
    5a64:	02 c0       	rjmp	.+4      	; 0x5a6a <DIO_enuSetPinValue+0x132>
    5a66:	88 0f       	add	r24, r24
    5a68:	99 1f       	adc	r25, r25
    5a6a:	2a 95       	dec	r18
    5a6c:	e2 f7       	brpl	.-8      	; 0x5a66 <DIO_enuSetPinValue+0x12e>
    5a6e:	80 95       	com	r24
    5a70:	84 23       	and	r24, r20
    5a72:	8c 93       	st	X, r24
			PORTC |=(Copy_u8Value<<Copy_u8PinID);
    5a74:	a5 e3       	ldi	r26, 0x35	; 53
    5a76:	b0 e0       	ldi	r27, 0x00	; 0
    5a78:	e5 e3       	ldi	r30, 0x35	; 53
    5a7a:	f0 e0       	ldi	r31, 0x00	; 0
    5a7c:	80 81       	ld	r24, Z
    5a7e:	48 2f       	mov	r20, r24
    5a80:	8c 81       	ldd	r24, Y+4	; 0x04
    5a82:	28 2f       	mov	r18, r24
    5a84:	30 e0       	ldi	r19, 0x00	; 0
    5a86:	8b 81       	ldd	r24, Y+3	; 0x03
    5a88:	88 2f       	mov	r24, r24
    5a8a:	90 e0       	ldi	r25, 0x00	; 0
    5a8c:	b9 01       	movw	r22, r18
    5a8e:	02 c0       	rjmp	.+4      	; 0x5a94 <DIO_enuSetPinValue+0x15c>
    5a90:	66 0f       	add	r22, r22
    5a92:	77 1f       	adc	r23, r23
    5a94:	8a 95       	dec	r24
    5a96:	e2 f7       	brpl	.-8      	; 0x5a90 <DIO_enuSetPinValue+0x158>
    5a98:	cb 01       	movw	r24, r22
    5a9a:	84 2b       	or	r24, r20
    5a9c:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    5a9e:	19 82       	std	Y+1, r1	; 0x01
    5aa0:	2f c0       	rjmp	.+94     	; 0x5b00 <DIO_enuSetPinValue+0x1c8>
			break;
		case DIO_PORTD:
			PORTD &=~(1<<Copy_u8PinID);
    5aa2:	a2 e3       	ldi	r26, 0x32	; 50
    5aa4:	b0 e0       	ldi	r27, 0x00	; 0
    5aa6:	e2 e3       	ldi	r30, 0x32	; 50
    5aa8:	f0 e0       	ldi	r31, 0x00	; 0
    5aaa:	80 81       	ld	r24, Z
    5aac:	48 2f       	mov	r20, r24
    5aae:	8b 81       	ldd	r24, Y+3	; 0x03
    5ab0:	28 2f       	mov	r18, r24
    5ab2:	30 e0       	ldi	r19, 0x00	; 0
    5ab4:	81 e0       	ldi	r24, 0x01	; 1
    5ab6:	90 e0       	ldi	r25, 0x00	; 0
    5ab8:	02 c0       	rjmp	.+4      	; 0x5abe <DIO_enuSetPinValue+0x186>
    5aba:	88 0f       	add	r24, r24
    5abc:	99 1f       	adc	r25, r25
    5abe:	2a 95       	dec	r18
    5ac0:	e2 f7       	brpl	.-8      	; 0x5aba <DIO_enuSetPinValue+0x182>
    5ac2:	80 95       	com	r24
    5ac4:	84 23       	and	r24, r20
    5ac6:	8c 93       	st	X, r24
			PORTD |=(Copy_u8Value<<Copy_u8PinID);
    5ac8:	a2 e3       	ldi	r26, 0x32	; 50
    5aca:	b0 e0       	ldi	r27, 0x00	; 0
    5acc:	e2 e3       	ldi	r30, 0x32	; 50
    5ace:	f0 e0       	ldi	r31, 0x00	; 0
    5ad0:	80 81       	ld	r24, Z
    5ad2:	48 2f       	mov	r20, r24
    5ad4:	8c 81       	ldd	r24, Y+4	; 0x04
    5ad6:	28 2f       	mov	r18, r24
    5ad8:	30 e0       	ldi	r19, 0x00	; 0
    5ada:	8b 81       	ldd	r24, Y+3	; 0x03
    5adc:	88 2f       	mov	r24, r24
    5ade:	90 e0       	ldi	r25, 0x00	; 0
    5ae0:	b9 01       	movw	r22, r18
    5ae2:	02 c0       	rjmp	.+4      	; 0x5ae8 <DIO_enuSetPinValue+0x1b0>
    5ae4:	66 0f       	add	r22, r22
    5ae6:	77 1f       	adc	r23, r23
    5ae8:	8a 95       	dec	r24
    5aea:	e2 f7       	brpl	.-8      	; 0x5ae4 <DIO_enuSetPinValue+0x1ac>
    5aec:	cb 01       	movw	r24, r22
    5aee:	84 2b       	or	r24, r20
    5af0:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    5af2:	19 82       	std	Y+1, r1	; 0x01
    5af4:	05 c0       	rjmp	.+10     	; 0x5b00 <DIO_enuSetPinValue+0x1c8>
			break;
		default :
			Local_enuErrorState = ES_OUT_OF_RANGE;
    5af6:	83 e0       	ldi	r24, 0x03	; 3
    5af8:	89 83       	std	Y+1, r24	; 0x01
    5afa:	02 c0       	rjmp	.+4      	; 0x5b00 <DIO_enuSetPinValue+0x1c8>
			break;
		}
	}
	else
	{
		Local_enuErrorState = ES_OUT_OF_RANGE;
    5afc:	83 e0       	ldi	r24, 0x03	; 3
    5afe:	89 83       	std	Y+1, r24	; 0x01
	}



	return Local_enuErrorState;
    5b00:	89 81       	ldd	r24, Y+1	; 0x01
}
    5b02:	26 96       	adiw	r28, 0x06	; 6
    5b04:	0f b6       	in	r0, 0x3f	; 63
    5b06:	f8 94       	cli
    5b08:	de bf       	out	0x3e, r29	; 62
    5b0a:	0f be       	out	0x3f, r0	; 63
    5b0c:	cd bf       	out	0x3d, r28	; 61
    5b0e:	cf 91       	pop	r28
    5b10:	df 91       	pop	r29
    5b12:	08 95       	ret

00005b14 <DIO_enuTogPin>:
/*****************************************************************/
ES_t DIO_enuTogPin(u8 Copy_u8PortID ,u8 Copy_u8PinID )
{
    5b14:	df 93       	push	r29
    5b16:	cf 93       	push	r28
    5b18:	00 d0       	rcall	.+0      	; 0x5b1a <DIO_enuTogPin+0x6>
    5b1a:	00 d0       	rcall	.+0      	; 0x5b1c <DIO_enuTogPin+0x8>
    5b1c:	0f 92       	push	r0
    5b1e:	cd b7       	in	r28, 0x3d	; 61
    5b20:	de b7       	in	r29, 0x3e	; 62
    5b22:	8a 83       	std	Y+2, r24	; 0x02
    5b24:	6b 83       	std	Y+3, r22	; 0x03
	ES_t Local_enuErrorState = ES_NOK;
    5b26:	81 e0       	ldi	r24, 0x01	; 1
    5b28:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinID <= DIO_PIN7)
    5b2a:	8b 81       	ldd	r24, Y+3	; 0x03
    5b2c:	88 30       	cpi	r24, 0x08	; 8
    5b2e:	08 f0       	brcs	.+2      	; 0x5b32 <DIO_enuTogPin+0x1e>
    5b30:	77 c0       	rjmp	.+238    	; 0x5c20 <DIO_enuTogPin+0x10c>
	{
		switch(Copy_u8PortID)
    5b32:	8a 81       	ldd	r24, Y+2	; 0x02
    5b34:	28 2f       	mov	r18, r24
    5b36:	30 e0       	ldi	r19, 0x00	; 0
    5b38:	3d 83       	std	Y+5, r19	; 0x05
    5b3a:	2c 83       	std	Y+4, r18	; 0x04
    5b3c:	8c 81       	ldd	r24, Y+4	; 0x04
    5b3e:	9d 81       	ldd	r25, Y+5	; 0x05
    5b40:	81 30       	cpi	r24, 0x01	; 1
    5b42:	91 05       	cpc	r25, r1
    5b44:	59 f1       	breq	.+86     	; 0x5b9c <DIO_enuTogPin+0x88>
    5b46:	2c 81       	ldd	r18, Y+4	; 0x04
    5b48:	3d 81       	ldd	r19, Y+5	; 0x05
    5b4a:	22 30       	cpi	r18, 0x02	; 2
    5b4c:	31 05       	cpc	r19, r1
    5b4e:	2c f4       	brge	.+10     	; 0x5b5a <DIO_enuTogPin+0x46>
    5b50:	8c 81       	ldd	r24, Y+4	; 0x04
    5b52:	9d 81       	ldd	r25, Y+5	; 0x05
    5b54:	00 97       	sbiw	r24, 0x00	; 0
    5b56:	69 f0       	breq	.+26     	; 0x5b72 <DIO_enuTogPin+0x5e>
    5b58:	60 c0       	rjmp	.+192    	; 0x5c1a <DIO_enuTogPin+0x106>
    5b5a:	2c 81       	ldd	r18, Y+4	; 0x04
    5b5c:	3d 81       	ldd	r19, Y+5	; 0x05
    5b5e:	22 30       	cpi	r18, 0x02	; 2
    5b60:	31 05       	cpc	r19, r1
    5b62:	89 f1       	breq	.+98     	; 0x5bc6 <DIO_enuTogPin+0xb2>
    5b64:	8c 81       	ldd	r24, Y+4	; 0x04
    5b66:	9d 81       	ldd	r25, Y+5	; 0x05
    5b68:	83 30       	cpi	r24, 0x03	; 3
    5b6a:	91 05       	cpc	r25, r1
    5b6c:	09 f4       	brne	.+2      	; 0x5b70 <DIO_enuTogPin+0x5c>
    5b6e:	40 c0       	rjmp	.+128    	; 0x5bf0 <DIO_enuTogPin+0xdc>
    5b70:	54 c0       	rjmp	.+168    	; 0x5c1a <DIO_enuTogPin+0x106>
		{
		case DIO_PORTA:
			PORTA ^=(1<<Copy_u8PinID); //toggle bit
    5b72:	ab e3       	ldi	r26, 0x3B	; 59
    5b74:	b0 e0       	ldi	r27, 0x00	; 0
    5b76:	eb e3       	ldi	r30, 0x3B	; 59
    5b78:	f0 e0       	ldi	r31, 0x00	; 0
    5b7a:	80 81       	ld	r24, Z
    5b7c:	48 2f       	mov	r20, r24
    5b7e:	8b 81       	ldd	r24, Y+3	; 0x03
    5b80:	28 2f       	mov	r18, r24
    5b82:	30 e0       	ldi	r19, 0x00	; 0
    5b84:	81 e0       	ldi	r24, 0x01	; 1
    5b86:	90 e0       	ldi	r25, 0x00	; 0
    5b88:	02 2e       	mov	r0, r18
    5b8a:	02 c0       	rjmp	.+4      	; 0x5b90 <DIO_enuTogPin+0x7c>
    5b8c:	88 0f       	add	r24, r24
    5b8e:	99 1f       	adc	r25, r25
    5b90:	0a 94       	dec	r0
    5b92:	e2 f7       	brpl	.-8      	; 0x5b8c <DIO_enuTogPin+0x78>
    5b94:	84 27       	eor	r24, r20
    5b96:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    5b98:	19 82       	std	Y+1, r1	; 0x01
    5b9a:	44 c0       	rjmp	.+136    	; 0x5c24 <DIO_enuTogPin+0x110>
			break;
		case DIO_PORTB:
			PORTB ^=(1<<Copy_u8PinID);
    5b9c:	a8 e3       	ldi	r26, 0x38	; 56
    5b9e:	b0 e0       	ldi	r27, 0x00	; 0
    5ba0:	e8 e3       	ldi	r30, 0x38	; 56
    5ba2:	f0 e0       	ldi	r31, 0x00	; 0
    5ba4:	80 81       	ld	r24, Z
    5ba6:	48 2f       	mov	r20, r24
    5ba8:	8b 81       	ldd	r24, Y+3	; 0x03
    5baa:	28 2f       	mov	r18, r24
    5bac:	30 e0       	ldi	r19, 0x00	; 0
    5bae:	81 e0       	ldi	r24, 0x01	; 1
    5bb0:	90 e0       	ldi	r25, 0x00	; 0
    5bb2:	02 2e       	mov	r0, r18
    5bb4:	02 c0       	rjmp	.+4      	; 0x5bba <DIO_enuTogPin+0xa6>
    5bb6:	88 0f       	add	r24, r24
    5bb8:	99 1f       	adc	r25, r25
    5bba:	0a 94       	dec	r0
    5bbc:	e2 f7       	brpl	.-8      	; 0x5bb6 <DIO_enuTogPin+0xa2>
    5bbe:	84 27       	eor	r24, r20
    5bc0:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    5bc2:	19 82       	std	Y+1, r1	; 0x01
    5bc4:	2f c0       	rjmp	.+94     	; 0x5c24 <DIO_enuTogPin+0x110>
			break;
		case DIO_PORTC:
			PORTC ^=(1<<Copy_u8PinID);
    5bc6:	a5 e3       	ldi	r26, 0x35	; 53
    5bc8:	b0 e0       	ldi	r27, 0x00	; 0
    5bca:	e5 e3       	ldi	r30, 0x35	; 53
    5bcc:	f0 e0       	ldi	r31, 0x00	; 0
    5bce:	80 81       	ld	r24, Z
    5bd0:	48 2f       	mov	r20, r24
    5bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    5bd4:	28 2f       	mov	r18, r24
    5bd6:	30 e0       	ldi	r19, 0x00	; 0
    5bd8:	81 e0       	ldi	r24, 0x01	; 1
    5bda:	90 e0       	ldi	r25, 0x00	; 0
    5bdc:	02 2e       	mov	r0, r18
    5bde:	02 c0       	rjmp	.+4      	; 0x5be4 <DIO_enuTogPin+0xd0>
    5be0:	88 0f       	add	r24, r24
    5be2:	99 1f       	adc	r25, r25
    5be4:	0a 94       	dec	r0
    5be6:	e2 f7       	brpl	.-8      	; 0x5be0 <DIO_enuTogPin+0xcc>
    5be8:	84 27       	eor	r24, r20
    5bea:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    5bec:	19 82       	std	Y+1, r1	; 0x01
    5bee:	1a c0       	rjmp	.+52     	; 0x5c24 <DIO_enuTogPin+0x110>
			break;
		case DIO_PORTD:
			PORTD ^=(1<<Copy_u8PinID);
    5bf0:	a2 e3       	ldi	r26, 0x32	; 50
    5bf2:	b0 e0       	ldi	r27, 0x00	; 0
    5bf4:	e2 e3       	ldi	r30, 0x32	; 50
    5bf6:	f0 e0       	ldi	r31, 0x00	; 0
    5bf8:	80 81       	ld	r24, Z
    5bfa:	48 2f       	mov	r20, r24
    5bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    5bfe:	28 2f       	mov	r18, r24
    5c00:	30 e0       	ldi	r19, 0x00	; 0
    5c02:	81 e0       	ldi	r24, 0x01	; 1
    5c04:	90 e0       	ldi	r25, 0x00	; 0
    5c06:	02 2e       	mov	r0, r18
    5c08:	02 c0       	rjmp	.+4      	; 0x5c0e <DIO_enuTogPin+0xfa>
    5c0a:	88 0f       	add	r24, r24
    5c0c:	99 1f       	adc	r25, r25
    5c0e:	0a 94       	dec	r0
    5c10:	e2 f7       	brpl	.-8      	; 0x5c0a <DIO_enuTogPin+0xf6>
    5c12:	84 27       	eor	r24, r20
    5c14:	8c 93       	st	X, r24
			Local_enuErrorState = ES_OK;
    5c16:	19 82       	std	Y+1, r1	; 0x01
    5c18:	05 c0       	rjmp	.+10     	; 0x5c24 <DIO_enuTogPin+0x110>
			break;
		default :
			Local_enuErrorState = ES_OUT_OF_RANGE;
    5c1a:	83 e0       	ldi	r24, 0x03	; 3
    5c1c:	89 83       	std	Y+1, r24	; 0x01
    5c1e:	02 c0       	rjmp	.+4      	; 0x5c24 <DIO_enuTogPin+0x110>
			break;
		}
	}
	else
	{
		Local_enuErrorState = ES_OUT_OF_RANGE;
    5c20:	83 e0       	ldi	r24, 0x03	; 3
    5c22:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_enuErrorState;
    5c24:	89 81       	ldd	r24, Y+1	; 0x01
}
    5c26:	0f 90       	pop	r0
    5c28:	0f 90       	pop	r0
    5c2a:	0f 90       	pop	r0
    5c2c:	0f 90       	pop	r0
    5c2e:	0f 90       	pop	r0
    5c30:	cf 91       	pop	r28
    5c32:	df 91       	pop	r29
    5c34:	08 95       	ret

00005c36 <DIO_enuGetPinValue>:
/*****************************************************************/
ES_t DIO_enuGetPinValue(u8 Copy_u8PortID ,u8 Copy_u8PinID , u8* Copy_pu8Value)
{
    5c36:	df 93       	push	r29
    5c38:	cf 93       	push	r28
    5c3a:	cd b7       	in	r28, 0x3d	; 61
    5c3c:	de b7       	in	r29, 0x3e	; 62
    5c3e:	27 97       	sbiw	r28, 0x07	; 7
    5c40:	0f b6       	in	r0, 0x3f	; 63
    5c42:	f8 94       	cli
    5c44:	de bf       	out	0x3e, r29	; 62
    5c46:	0f be       	out	0x3f, r0	; 63
    5c48:	cd bf       	out	0x3d, r28	; 61
    5c4a:	8a 83       	std	Y+2, r24	; 0x02
    5c4c:	6b 83       	std	Y+3, r22	; 0x03
    5c4e:	5d 83       	std	Y+5, r21	; 0x05
    5c50:	4c 83       	std	Y+4, r20	; 0x04
	ES_t Local_enuErrorState = ES_NOK;
    5c52:	81 e0       	ldi	r24, 0x01	; 1
    5c54:	89 83       	std	Y+1, r24	; 0x01

	if(Copy_pu8Value != NULL)
    5c56:	8c 81       	ldd	r24, Y+4	; 0x04
    5c58:	9d 81       	ldd	r25, Y+5	; 0x05
    5c5a:	00 97       	sbiw	r24, 0x00	; 0
    5c5c:	09 f4       	brne	.+2      	; 0x5c60 <DIO_enuGetPinValue+0x2a>
    5c5e:	7b c0       	rjmp	.+246    	; 0x5d56 <DIO_enuGetPinValue+0x120>
	{
		if(Copy_u8PinID<=DIO_PIN7)
    5c60:	8b 81       	ldd	r24, Y+3	; 0x03
    5c62:	88 30       	cpi	r24, 0x08	; 8
    5c64:	08 f0       	brcs	.+2      	; 0x5c68 <DIO_enuGetPinValue+0x32>
    5c66:	74 c0       	rjmp	.+232    	; 0x5d50 <DIO_enuGetPinValue+0x11a>
		{
			switch(Copy_u8PortID)
    5c68:	8a 81       	ldd	r24, Y+2	; 0x02
    5c6a:	28 2f       	mov	r18, r24
    5c6c:	30 e0       	ldi	r19, 0x00	; 0
    5c6e:	3f 83       	std	Y+7, r19	; 0x07
    5c70:	2e 83       	std	Y+6, r18	; 0x06
    5c72:	4e 81       	ldd	r20, Y+6	; 0x06
    5c74:	5f 81       	ldd	r21, Y+7	; 0x07
    5c76:	41 30       	cpi	r20, 0x01	; 1
    5c78:	51 05       	cpc	r21, r1
    5c7a:	59 f1       	breq	.+86     	; 0x5cd2 <DIO_enuGetPinValue+0x9c>
    5c7c:	8e 81       	ldd	r24, Y+6	; 0x06
    5c7e:	9f 81       	ldd	r25, Y+7	; 0x07
    5c80:	82 30       	cpi	r24, 0x02	; 2
    5c82:	91 05       	cpc	r25, r1
    5c84:	34 f4       	brge	.+12     	; 0x5c92 <DIO_enuGetPinValue+0x5c>
    5c86:	2e 81       	ldd	r18, Y+6	; 0x06
    5c88:	3f 81       	ldd	r19, Y+7	; 0x07
    5c8a:	21 15       	cp	r18, r1
    5c8c:	31 05       	cpc	r19, r1
    5c8e:	69 f0       	breq	.+26     	; 0x5caa <DIO_enuGetPinValue+0x74>
    5c90:	5c c0       	rjmp	.+184    	; 0x5d4a <DIO_enuGetPinValue+0x114>
    5c92:	4e 81       	ldd	r20, Y+6	; 0x06
    5c94:	5f 81       	ldd	r21, Y+7	; 0x07
    5c96:	42 30       	cpi	r20, 0x02	; 2
    5c98:	51 05       	cpc	r21, r1
    5c9a:	79 f1       	breq	.+94     	; 0x5cfa <DIO_enuGetPinValue+0xc4>
    5c9c:	8e 81       	ldd	r24, Y+6	; 0x06
    5c9e:	9f 81       	ldd	r25, Y+7	; 0x07
    5ca0:	83 30       	cpi	r24, 0x03	; 3
    5ca2:	91 05       	cpc	r25, r1
    5ca4:	09 f4       	brne	.+2      	; 0x5ca8 <DIO_enuGetPinValue+0x72>
    5ca6:	3d c0       	rjmp	.+122    	; 0x5d22 <DIO_enuGetPinValue+0xec>
    5ca8:	50 c0       	rjmp	.+160    	; 0x5d4a <DIO_enuGetPinValue+0x114>
			{
			case DIO_PORTA:
				*Copy_pu8Value=((PINA>>Copy_u8PinID)&DIO_MASK_BIT);
    5caa:	e9 e3       	ldi	r30, 0x39	; 57
    5cac:	f0 e0       	ldi	r31, 0x00	; 0
    5cae:	80 81       	ld	r24, Z
    5cb0:	28 2f       	mov	r18, r24
    5cb2:	30 e0       	ldi	r19, 0x00	; 0
    5cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    5cb6:	88 2f       	mov	r24, r24
    5cb8:	90 e0       	ldi	r25, 0x00	; 0
    5cba:	a9 01       	movw	r20, r18
    5cbc:	02 c0       	rjmp	.+4      	; 0x5cc2 <DIO_enuGetPinValue+0x8c>
    5cbe:	55 95       	asr	r21
    5cc0:	47 95       	ror	r20
    5cc2:	8a 95       	dec	r24
    5cc4:	e2 f7       	brpl	.-8      	; 0x5cbe <DIO_enuGetPinValue+0x88>
    5cc6:	ca 01       	movw	r24, r20
    5cc8:	81 70       	andi	r24, 0x01	; 1
    5cca:	ec 81       	ldd	r30, Y+4	; 0x04
    5ccc:	fd 81       	ldd	r31, Y+5	; 0x05
    5cce:	80 83       	st	Z, r24
    5cd0:	44 c0       	rjmp	.+136    	; 0x5d5a <DIO_enuGetPinValue+0x124>
				break;
			case DIO_PORTB:
				*Copy_pu8Value=((PINB>>Copy_u8PinID)&DIO_MASK_BIT);
    5cd2:	e6 e3       	ldi	r30, 0x36	; 54
    5cd4:	f0 e0       	ldi	r31, 0x00	; 0
    5cd6:	80 81       	ld	r24, Z
    5cd8:	28 2f       	mov	r18, r24
    5cda:	30 e0       	ldi	r19, 0x00	; 0
    5cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    5cde:	88 2f       	mov	r24, r24
    5ce0:	90 e0       	ldi	r25, 0x00	; 0
    5ce2:	a9 01       	movw	r20, r18
    5ce4:	02 c0       	rjmp	.+4      	; 0x5cea <DIO_enuGetPinValue+0xb4>
    5ce6:	55 95       	asr	r21
    5ce8:	47 95       	ror	r20
    5cea:	8a 95       	dec	r24
    5cec:	e2 f7       	brpl	.-8      	; 0x5ce6 <DIO_enuGetPinValue+0xb0>
    5cee:	ca 01       	movw	r24, r20
    5cf0:	81 70       	andi	r24, 0x01	; 1
    5cf2:	ec 81       	ldd	r30, Y+4	; 0x04
    5cf4:	fd 81       	ldd	r31, Y+5	; 0x05
    5cf6:	80 83       	st	Z, r24
    5cf8:	30 c0       	rjmp	.+96     	; 0x5d5a <DIO_enuGetPinValue+0x124>
				break;
			case DIO_PORTC:
				*Copy_pu8Value=((PINC>>Copy_u8PinID)&DIO_MASK_BIT);
    5cfa:	e3 e3       	ldi	r30, 0x33	; 51
    5cfc:	f0 e0       	ldi	r31, 0x00	; 0
    5cfe:	80 81       	ld	r24, Z
    5d00:	28 2f       	mov	r18, r24
    5d02:	30 e0       	ldi	r19, 0x00	; 0
    5d04:	8b 81       	ldd	r24, Y+3	; 0x03
    5d06:	88 2f       	mov	r24, r24
    5d08:	90 e0       	ldi	r25, 0x00	; 0
    5d0a:	a9 01       	movw	r20, r18
    5d0c:	02 c0       	rjmp	.+4      	; 0x5d12 <DIO_enuGetPinValue+0xdc>
    5d0e:	55 95       	asr	r21
    5d10:	47 95       	ror	r20
    5d12:	8a 95       	dec	r24
    5d14:	e2 f7       	brpl	.-8      	; 0x5d0e <DIO_enuGetPinValue+0xd8>
    5d16:	ca 01       	movw	r24, r20
    5d18:	81 70       	andi	r24, 0x01	; 1
    5d1a:	ec 81       	ldd	r30, Y+4	; 0x04
    5d1c:	fd 81       	ldd	r31, Y+5	; 0x05
    5d1e:	80 83       	st	Z, r24
    5d20:	1c c0       	rjmp	.+56     	; 0x5d5a <DIO_enuGetPinValue+0x124>
				break;
			case DIO_PORTD:
				*Copy_pu8Value=((PIND>>Copy_u8PinID)&DIO_MASK_BIT);
    5d22:	e0 e3       	ldi	r30, 0x30	; 48
    5d24:	f0 e0       	ldi	r31, 0x00	; 0
    5d26:	80 81       	ld	r24, Z
    5d28:	28 2f       	mov	r18, r24
    5d2a:	30 e0       	ldi	r19, 0x00	; 0
    5d2c:	8b 81       	ldd	r24, Y+3	; 0x03
    5d2e:	88 2f       	mov	r24, r24
    5d30:	90 e0       	ldi	r25, 0x00	; 0
    5d32:	a9 01       	movw	r20, r18
    5d34:	02 c0       	rjmp	.+4      	; 0x5d3a <DIO_enuGetPinValue+0x104>
    5d36:	55 95       	asr	r21
    5d38:	47 95       	ror	r20
    5d3a:	8a 95       	dec	r24
    5d3c:	e2 f7       	brpl	.-8      	; 0x5d36 <DIO_enuGetPinValue+0x100>
    5d3e:	ca 01       	movw	r24, r20
    5d40:	81 70       	andi	r24, 0x01	; 1
    5d42:	ec 81       	ldd	r30, Y+4	; 0x04
    5d44:	fd 81       	ldd	r31, Y+5	; 0x05
    5d46:	80 83       	st	Z, r24
    5d48:	08 c0       	rjmp	.+16     	; 0x5d5a <DIO_enuGetPinValue+0x124>
				break;
			default :
				Local_enuErrorState = ES_OUT_OF_RANGE;
    5d4a:	83 e0       	ldi	r24, 0x03	; 3
    5d4c:	89 83       	std	Y+1, r24	; 0x01
    5d4e:	05 c0       	rjmp	.+10     	; 0x5d5a <DIO_enuGetPinValue+0x124>
				break;
			}
		}
		else
		{
			Local_enuErrorState=ES_OUT_OF_RANGE;
    5d50:	83 e0       	ldi	r24, 0x03	; 3
    5d52:	89 83       	std	Y+1, r24	; 0x01
    5d54:	02 c0       	rjmp	.+4      	; 0x5d5a <DIO_enuGetPinValue+0x124>
		}
	}
	else
	{
		Local_enuErrorState = ES_NULL_POINTER;
    5d56:	82 e0       	ldi	r24, 0x02	; 2
    5d58:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_enuErrorState;
    5d5a:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d5c:	27 96       	adiw	r28, 0x07	; 7
    5d5e:	0f b6       	in	r0, 0x3f	; 63
    5d60:	f8 94       	cli
    5d62:	de bf       	out	0x3e, r29	; 62
    5d64:	0f be       	out	0x3f, r0	; 63
    5d66:	cd bf       	out	0x3d, r28	; 61
    5d68:	cf 91       	pop	r28
    5d6a:	df 91       	pop	r29
    5d6c:	08 95       	ret

00005d6e <GIE_enuEnable>:
#include "GIE_int.h"
#include "GIE_priv.h"


ES_t GIE_enuEnable()
{
    5d6e:	df 93       	push	r29
    5d70:	cf 93       	push	r28
    5d72:	0f 92       	push	r0
    5d74:	cd b7       	in	r28, 0x3d	; 61
    5d76:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorstate = ES_NOK;
    5d78:	81 e0       	ldi	r24, 0x01	; 1
    5d7a:	89 83       	std	Y+1, r24	; 0x01

	SET_BIT(SREG,I);
    5d7c:	af e5       	ldi	r26, 0x5F	; 95
    5d7e:	b0 e0       	ldi	r27, 0x00	; 0
    5d80:	ef e5       	ldi	r30, 0x5F	; 95
    5d82:	f0 e0       	ldi	r31, 0x00	; 0
    5d84:	80 81       	ld	r24, Z
    5d86:	80 68       	ori	r24, 0x80	; 128
    5d88:	8c 93       	st	X, r24
	Local_enuErrorstate = ES_OK;
    5d8a:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorstate;
    5d8c:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d8e:	0f 90       	pop	r0
    5d90:	cf 91       	pop	r28
    5d92:	df 91       	pop	r29
    5d94:	08 95       	ret

00005d96 <GIE_enuDisable>:

ES_t GIE_enuDisable()
{
    5d96:	df 93       	push	r29
    5d98:	cf 93       	push	r28
    5d9a:	0f 92       	push	r0
    5d9c:	cd b7       	in	r28, 0x3d	; 61
    5d9e:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorstate = ES_NOK;
    5da0:	81 e0       	ldi	r24, 0x01	; 1
    5da2:	89 83       	std	Y+1, r24	; 0x01

	CLEAR_BIT(SREG,I);
    5da4:	af e5       	ldi	r26, 0x5F	; 95
    5da6:	b0 e0       	ldi	r27, 0x00	; 0
    5da8:	ef e5       	ldi	r30, 0x5F	; 95
    5daa:	f0 e0       	ldi	r31, 0x00	; 0
    5dac:	80 81       	ld	r24, Z
    5dae:	8f 77       	andi	r24, 0x7F	; 127
    5db0:	8c 93       	st	X, r24
	Local_enuErrorstate = ES_OK;
    5db2:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorstate;
    5db4:	89 81       	ldd	r24, Y+1	; 0x01
}
    5db6:	0f 90       	pop	r0
    5db8:	cf 91       	pop	r28
    5dba:	df 91       	pop	r29
    5dbc:	08 95       	ret

00005dbe <Timer0_enuInit>:
static void (*Timer1_pfuncTimer1_CTCB_Func) (void) = NULL;
/***************************************************/
/*                     TIMER0                      */
/***************************************************/
ES_t Timer0_enuInit(Timer0_t *Copy_strTimer0)
{
    5dbe:	df 93       	push	r29
    5dc0:	cf 93       	push	r28
    5dc2:	00 d0       	rcall	.+0      	; 0x5dc4 <Timer0_enuInit+0x6>
    5dc4:	00 d0       	rcall	.+0      	; 0x5dc6 <Timer0_enuInit+0x8>
    5dc6:	0f 92       	push	r0
    5dc8:	cd b7       	in	r28, 0x3d	; 61
    5dca:	de b7       	in	r29, 0x3e	; 62
    5dcc:	9b 83       	std	Y+3, r25	; 0x03
    5dce:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    5dd0:	81 e0       	ldi	r24, 0x01	; 1
    5dd2:	89 83       	std	Y+1, r24	; 0x01

	/*********************************************/
	/**              Set the mode               **/
	/*********************************************/

	switch(Copy_strTimer0->Timer0_enuMode)
    5dd4:	ea 81       	ldd	r30, Y+2	; 0x02
    5dd6:	fb 81       	ldd	r31, Y+3	; 0x03
    5dd8:	80 81       	ld	r24, Z
    5dda:	28 2f       	mov	r18, r24
    5ddc:	30 e0       	ldi	r19, 0x00	; 0
    5dde:	3d 83       	std	Y+5, r19	; 0x05
    5de0:	2c 83       	std	Y+4, r18	; 0x04
    5de2:	8c 81       	ldd	r24, Y+4	; 0x04
    5de4:	9d 81       	ldd	r25, Y+5	; 0x05
    5de6:	81 30       	cpi	r24, 0x01	; 1
    5de8:	91 05       	cpc	r25, r1
    5dea:	21 f1       	breq	.+72     	; 0x5e34 <Timer0_enuInit+0x76>
    5dec:	2c 81       	ldd	r18, Y+4	; 0x04
    5dee:	3d 81       	ldd	r19, Y+5	; 0x05
    5df0:	22 30       	cpi	r18, 0x02	; 2
    5df2:	31 05       	cpc	r19, r1
    5df4:	2c f4       	brge	.+10     	; 0x5e00 <Timer0_enuInit+0x42>
    5df6:	8c 81       	ldd	r24, Y+4	; 0x04
    5df8:	9d 81       	ldd	r25, Y+5	; 0x05
    5dfa:	00 97       	sbiw	r24, 0x00	; 0
    5dfc:	61 f0       	breq	.+24     	; 0x5e16 <Timer0_enuInit+0x58>
    5dfe:	46 c0       	rjmp	.+140    	; 0x5e8c <Timer0_enuInit+0xce>
    5e00:	2c 81       	ldd	r18, Y+4	; 0x04
    5e02:	3d 81       	ldd	r19, Y+5	; 0x05
    5e04:	22 30       	cpi	r18, 0x02	; 2
    5e06:	31 05       	cpc	r19, r1
    5e08:	99 f1       	breq	.+102    	; 0x5e70 <Timer0_enuInit+0xb2>
    5e0a:	8c 81       	ldd	r24, Y+4	; 0x04
    5e0c:	9d 81       	ldd	r25, Y+5	; 0x05
    5e0e:	83 30       	cpi	r24, 0x03	; 3
    5e10:	91 05       	cpc	r25, r1
    5e12:	f9 f0       	breq	.+62     	; 0x5e52 <Timer0_enuInit+0x94>
    5e14:	3b c0       	rjmp	.+118    	; 0x5e8c <Timer0_enuInit+0xce>
	{
	case Timer0_enuOverflow :
		TCCR0 &=~(1<<WGM01);
    5e16:	a3 e5       	ldi	r26, 0x53	; 83
    5e18:	b0 e0       	ldi	r27, 0x00	; 0
    5e1a:	e3 e5       	ldi	r30, 0x53	; 83
    5e1c:	f0 e0       	ldi	r31, 0x00	; 0
    5e1e:	80 81       	ld	r24, Z
    5e20:	87 7f       	andi	r24, 0xF7	; 247
    5e22:	8c 93       	st	X, r24
		TCCR0 &=~(1<<WGM00);
    5e24:	a3 e5       	ldi	r26, 0x53	; 83
    5e26:	b0 e0       	ldi	r27, 0x00	; 0
    5e28:	e3 e5       	ldi	r30, 0x53	; 83
    5e2a:	f0 e0       	ldi	r31, 0x00	; 0
    5e2c:	80 81       	ld	r24, Z
    5e2e:	8f 7b       	andi	r24, 0xBF	; 191
    5e30:	8c 93       	st	X, r24
    5e32:	2c c0       	rjmp	.+88     	; 0x5e8c <Timer0_enuInit+0xce>
		break;
	case Timer0_enuCTC :
		TCCR0 |=(1<<WGM01);
    5e34:	a3 e5       	ldi	r26, 0x53	; 83
    5e36:	b0 e0       	ldi	r27, 0x00	; 0
    5e38:	e3 e5       	ldi	r30, 0x53	; 83
    5e3a:	f0 e0       	ldi	r31, 0x00	; 0
    5e3c:	80 81       	ld	r24, Z
    5e3e:	88 60       	ori	r24, 0x08	; 8
    5e40:	8c 93       	st	X, r24
		TCCR0 &=~(1<<WGM00);
    5e42:	a3 e5       	ldi	r26, 0x53	; 83
    5e44:	b0 e0       	ldi	r27, 0x00	; 0
    5e46:	e3 e5       	ldi	r30, 0x53	; 83
    5e48:	f0 e0       	ldi	r31, 0x00	; 0
    5e4a:	80 81       	ld	r24, Z
    5e4c:	8f 7b       	andi	r24, 0xBF	; 191
    5e4e:	8c 93       	st	X, r24
    5e50:	1d c0       	rjmp	.+58     	; 0x5e8c <Timer0_enuInit+0xce>
		break;
	case Timer0_enuPhaseCorrectPWM  :
		TCCR0 &=~(1<<WGM01);
    5e52:	a3 e5       	ldi	r26, 0x53	; 83
    5e54:	b0 e0       	ldi	r27, 0x00	; 0
    5e56:	e3 e5       	ldi	r30, 0x53	; 83
    5e58:	f0 e0       	ldi	r31, 0x00	; 0
    5e5a:	80 81       	ld	r24, Z
    5e5c:	87 7f       	andi	r24, 0xF7	; 247
    5e5e:	8c 93       	st	X, r24
		TCCR0 |=(1<<WGM00);
    5e60:	a3 e5       	ldi	r26, 0x53	; 83
    5e62:	b0 e0       	ldi	r27, 0x00	; 0
    5e64:	e3 e5       	ldi	r30, 0x53	; 83
    5e66:	f0 e0       	ldi	r31, 0x00	; 0
    5e68:	80 81       	ld	r24, Z
    5e6a:	80 64       	ori	r24, 0x40	; 64
    5e6c:	8c 93       	st	X, r24
    5e6e:	0e c0       	rjmp	.+28     	; 0x5e8c <Timer0_enuInit+0xce>
		break;
	case Timer0_enuFastPWM  :
		TCCR0 |=(1<<WGM01);
    5e70:	a3 e5       	ldi	r26, 0x53	; 83
    5e72:	b0 e0       	ldi	r27, 0x00	; 0
    5e74:	e3 e5       	ldi	r30, 0x53	; 83
    5e76:	f0 e0       	ldi	r31, 0x00	; 0
    5e78:	80 81       	ld	r24, Z
    5e7a:	88 60       	ori	r24, 0x08	; 8
    5e7c:	8c 93       	st	X, r24
		TCCR0 |=(1<<WGM00);
    5e7e:	a3 e5       	ldi	r26, 0x53	; 83
    5e80:	b0 e0       	ldi	r27, 0x00	; 0
    5e82:	e3 e5       	ldi	r30, 0x53	; 83
    5e84:	f0 e0       	ldi	r31, 0x00	; 0
    5e86:	80 81       	ld	r24, Z
    5e88:	80 64       	ori	r24, 0x40	; 64
    5e8a:	8c 93       	st	X, r24


	/*********************************************/
	/**                  OC0                    **/
	/*********************************************/
	if(Copy_strTimer0->Timer0_enuMode == Timer0_enuOverflow)
    5e8c:	ea 81       	ldd	r30, Y+2	; 0x02
    5e8e:	fb 81       	ldd	r31, Y+3	; 0x03
    5e90:	80 81       	ld	r24, Z
    5e92:	88 23       	and	r24, r24
    5e94:	79 f4       	brne	.+30     	; 0x5eb4 <Timer0_enuInit+0xf6>
	{
		TCCR0&=~(1<<COM00);
    5e96:	a3 e5       	ldi	r26, 0x53	; 83
    5e98:	b0 e0       	ldi	r27, 0x00	; 0
    5e9a:	e3 e5       	ldi	r30, 0x53	; 83
    5e9c:	f0 e0       	ldi	r31, 0x00	; 0
    5e9e:	80 81       	ld	r24, Z
    5ea0:	8f 7e       	andi	r24, 0xEF	; 239
    5ea2:	8c 93       	st	X, r24
		TCCR0&=~(1<<COM01);
    5ea4:	a3 e5       	ldi	r26, 0x53	; 83
    5ea6:	b0 e0       	ldi	r27, 0x00	; 0
    5ea8:	e3 e5       	ldi	r30, 0x53	; 83
    5eaa:	f0 e0       	ldi	r31, 0x00	; 0
    5eac:	80 81       	ld	r24, Z
    5eae:	8f 7d       	andi	r24, 0xDF	; 223
    5eb0:	8c 93       	st	X, r24
    5eb2:	5f c0       	rjmp	.+190    	; 0x5f72 <Timer0_enuInit+0x1b4>
	}
	else
	{

		if(Copy_strTimer0->Timer0_enuOC0Action == Disconnect)
    5eb4:	ea 81       	ldd	r30, Y+2	; 0x02
    5eb6:	fb 81       	ldd	r31, Y+3	; 0x03
    5eb8:	81 81       	ldd	r24, Z+1	; 0x01
    5eba:	88 23       	and	r24, r24
    5ebc:	79 f4       	brne	.+30     	; 0x5edc <Timer0_enuInit+0x11e>
		{
			TCCR0&=~(1<<COM00);
    5ebe:	a3 e5       	ldi	r26, 0x53	; 83
    5ec0:	b0 e0       	ldi	r27, 0x00	; 0
    5ec2:	e3 e5       	ldi	r30, 0x53	; 83
    5ec4:	f0 e0       	ldi	r31, 0x00	; 0
    5ec6:	80 81       	ld	r24, Z
    5ec8:	8f 7e       	andi	r24, 0xEF	; 239
    5eca:	8c 93       	st	X, r24
			TCCR0&=~(1<<COM01);
    5ecc:	a3 e5       	ldi	r26, 0x53	; 83
    5ece:	b0 e0       	ldi	r27, 0x00	; 0
    5ed0:	e3 e5       	ldi	r30, 0x53	; 83
    5ed2:	f0 e0       	ldi	r31, 0x00	; 0
    5ed4:	80 81       	ld	r24, Z
    5ed6:	8f 7d       	andi	r24, 0xDF	; 223
    5ed8:	8c 93       	st	X, r24
    5eda:	4b c0       	rjmp	.+150    	; 0x5f72 <Timer0_enuInit+0x1b4>
		}
		else if(Copy_strTimer0->Timer0_enuOC0Action == ToggleOnCompare)
    5edc:	ea 81       	ldd	r30, Y+2	; 0x02
    5ede:	fb 81       	ldd	r31, Y+3	; 0x03
    5ee0:	81 81       	ldd	r24, Z+1	; 0x01
    5ee2:	81 30       	cpi	r24, 0x01	; 1
    5ee4:	a9 f4       	brne	.+42     	; 0x5f10 <Timer0_enuInit+0x152>
		{
			if(Copy_strTimer0->Timer0_enuMode == Timer0_enuCTC)
    5ee6:	ea 81       	ldd	r30, Y+2	; 0x02
    5ee8:	fb 81       	ldd	r31, Y+3	; 0x03
    5eea:	80 81       	ld	r24, Z
    5eec:	81 30       	cpi	r24, 0x01	; 1
    5eee:	09 f0       	breq	.+2      	; 0x5ef2 <Timer0_enuInit+0x134>
    5ef0:	40 c0       	rjmp	.+128    	; 0x5f72 <Timer0_enuInit+0x1b4>
			{
				TCCR0|=(1<<COM00);
    5ef2:	a3 e5       	ldi	r26, 0x53	; 83
    5ef4:	b0 e0       	ldi	r27, 0x00	; 0
    5ef6:	e3 e5       	ldi	r30, 0x53	; 83
    5ef8:	f0 e0       	ldi	r31, 0x00	; 0
    5efa:	80 81       	ld	r24, Z
    5efc:	80 61       	ori	r24, 0x10	; 16
    5efe:	8c 93       	st	X, r24
				TCCR0&=~(1<<COM01);
    5f00:	a3 e5       	ldi	r26, 0x53	; 83
    5f02:	b0 e0       	ldi	r27, 0x00	; 0
    5f04:	e3 e5       	ldi	r30, 0x53	; 83
    5f06:	f0 e0       	ldi	r31, 0x00	; 0
    5f08:	80 81       	ld	r24, Z
    5f0a:	8f 7d       	andi	r24, 0xDF	; 223
    5f0c:	8c 93       	st	X, r24
    5f0e:	31 c0       	rjmp	.+98     	; 0x5f72 <Timer0_enuInit+0x1b4>
			}
		}
		else if((Copy_strTimer0->Timer0_enuOC0Action == ClearOnCompare) || (Copy_strTimer0->Timer0_enuOC0Action == PWM_NonInverted) )
    5f10:	ea 81       	ldd	r30, Y+2	; 0x02
    5f12:	fb 81       	ldd	r31, Y+3	; 0x03
    5f14:	81 81       	ldd	r24, Z+1	; 0x01
    5f16:	82 30       	cpi	r24, 0x02	; 2
    5f18:	29 f0       	breq	.+10     	; 0x5f24 <Timer0_enuInit+0x166>
    5f1a:	ea 81       	ldd	r30, Y+2	; 0x02
    5f1c:	fb 81       	ldd	r31, Y+3	; 0x03
    5f1e:	81 81       	ldd	r24, Z+1	; 0x01
    5f20:	84 30       	cpi	r24, 0x04	; 4
    5f22:	79 f4       	brne	.+30     	; 0x5f42 <Timer0_enuInit+0x184>
		{
			TCCR0&=~(1<<COM00);
    5f24:	a3 e5       	ldi	r26, 0x53	; 83
    5f26:	b0 e0       	ldi	r27, 0x00	; 0
    5f28:	e3 e5       	ldi	r30, 0x53	; 83
    5f2a:	f0 e0       	ldi	r31, 0x00	; 0
    5f2c:	80 81       	ld	r24, Z
    5f2e:	8f 7e       	andi	r24, 0xEF	; 239
    5f30:	8c 93       	st	X, r24
			TCCR0|=(1<<COM01);
    5f32:	a3 e5       	ldi	r26, 0x53	; 83
    5f34:	b0 e0       	ldi	r27, 0x00	; 0
    5f36:	e3 e5       	ldi	r30, 0x53	; 83
    5f38:	f0 e0       	ldi	r31, 0x00	; 0
    5f3a:	80 81       	ld	r24, Z
    5f3c:	80 62       	ori	r24, 0x20	; 32
    5f3e:	8c 93       	st	X, r24
    5f40:	18 c0       	rjmp	.+48     	; 0x5f72 <Timer0_enuInit+0x1b4>
		}
		else if((Copy_strTimer0->Timer0_enuOC0Action == SetOnCompare) || (Copy_strTimer0->Timer0_enuOC0Action == PWM_Inverted))
    5f42:	ea 81       	ldd	r30, Y+2	; 0x02
    5f44:	fb 81       	ldd	r31, Y+3	; 0x03
    5f46:	81 81       	ldd	r24, Z+1	; 0x01
    5f48:	83 30       	cpi	r24, 0x03	; 3
    5f4a:	29 f0       	breq	.+10     	; 0x5f56 <Timer0_enuInit+0x198>
    5f4c:	ea 81       	ldd	r30, Y+2	; 0x02
    5f4e:	fb 81       	ldd	r31, Y+3	; 0x03
    5f50:	81 81       	ldd	r24, Z+1	; 0x01
    5f52:	85 30       	cpi	r24, 0x05	; 5
    5f54:	71 f4       	brne	.+28     	; 0x5f72 <Timer0_enuInit+0x1b4>
		{
			TCCR0|=(1<<COM00);
    5f56:	a3 e5       	ldi	r26, 0x53	; 83
    5f58:	b0 e0       	ldi	r27, 0x00	; 0
    5f5a:	e3 e5       	ldi	r30, 0x53	; 83
    5f5c:	f0 e0       	ldi	r31, 0x00	; 0
    5f5e:	80 81       	ld	r24, Z
    5f60:	80 61       	ori	r24, 0x10	; 16
    5f62:	8c 93       	st	X, r24
			TCCR0|=(1<<COM01);
    5f64:	a3 e5       	ldi	r26, 0x53	; 83
    5f66:	b0 e0       	ldi	r27, 0x00	; 0
    5f68:	e3 e5       	ldi	r30, 0x53	; 83
    5f6a:	f0 e0       	ldi	r31, 0x00	; 0
    5f6c:	80 81       	ld	r24, Z
    5f6e:	80 62       	ori	r24, 0x20	; 32
    5f70:	8c 93       	st	X, r24
	}

	/*********************************************/
	/**              Pr-escaler                 **/
	/*********************************************/
	if((Copy_strTimer0->Timer0_enuPrescaler)>= TIMERS_enuNoClockSource && (Copy_strTimer0->Timer0_enuPrescaler) <= TIMERS_enuPrescalingBy1024 )
    5f72:	ea 81       	ldd	r30, Y+2	; 0x02
    5f74:	fb 81       	ldd	r31, Y+3	; 0x03
    5f76:	82 81       	ldd	r24, Z+2	; 0x02
    5f78:	86 30       	cpi	r24, 0x06	; 6
    5f7a:	88 f4       	brcc	.+34     	; 0x5f9e <Timer0_enuInit+0x1e0>
	{
		TCCR0 &=0xF8;
    5f7c:	a3 e5       	ldi	r26, 0x53	; 83
    5f7e:	b0 e0       	ldi	r27, 0x00	; 0
    5f80:	e3 e5       	ldi	r30, 0x53	; 83
    5f82:	f0 e0       	ldi	r31, 0x00	; 0
    5f84:	80 81       	ld	r24, Z
    5f86:	88 7f       	andi	r24, 0xF8	; 248
    5f88:	8c 93       	st	X, r24
		TCCR0 |=(Copy_strTimer0->Timer0_enuPrescaler);
    5f8a:	a3 e5       	ldi	r26, 0x53	; 83
    5f8c:	b0 e0       	ldi	r27, 0x00	; 0
    5f8e:	e3 e5       	ldi	r30, 0x53	; 83
    5f90:	f0 e0       	ldi	r31, 0x00	; 0
    5f92:	90 81       	ld	r25, Z
    5f94:	ea 81       	ldd	r30, Y+2	; 0x02
    5f96:	fb 81       	ldd	r31, Y+3	; 0x03
    5f98:	82 81       	ldd	r24, Z+2	; 0x02
    5f9a:	89 2b       	or	r24, r25
    5f9c:	8c 93       	st	X, r24
	}


	/*set compare match value*/
	OCR0  = Copy_strTimer0->Timer0_u8CompareMatchValue;
    5f9e:	ac e5       	ldi	r26, 0x5C	; 92
    5fa0:	b0 e0       	ldi	r27, 0x00	; 0
    5fa2:	ea 81       	ldd	r30, Y+2	; 0x02
    5fa4:	fb 81       	ldd	r31, Y+3	; 0x03
    5fa6:	84 81       	ldd	r24, Z+4	; 0x04
    5fa8:	8c 93       	st	X, r24

	/*set the initial counter value*/
    TCNT0 = Copy_strTimer0->Timer0_u8Counter;
    5faa:	a2 e5       	ldi	r26, 0x52	; 82
    5fac:	b0 e0       	ldi	r27, 0x00	; 0
    5fae:	ea 81       	ldd	r30, Y+2	; 0x02
    5fb0:	fb 81       	ldd	r31, Y+3	; 0x03
    5fb2:	83 81       	ldd	r24, Z+3	; 0x03
    5fb4:	8c 93       	st	X, r24


	return Local_enuErrorState;
    5fb6:	89 81       	ldd	r24, Y+1	; 0x01
}
    5fb8:	0f 90       	pop	r0
    5fba:	0f 90       	pop	r0
    5fbc:	0f 90       	pop	r0
    5fbe:	0f 90       	pop	r0
    5fc0:	0f 90       	pop	r0
    5fc2:	cf 91       	pop	r28
    5fc4:	df 91       	pop	r29
    5fc6:	08 95       	ret

00005fc8 <Timer0_enuSetMode>:

ES_t Timer0_enuSetMode(TIMERS_Mode_t Copy_enuTimer0Mode)
{
    5fc8:	df 93       	push	r29
    5fca:	cf 93       	push	r28
    5fcc:	00 d0       	rcall	.+0      	; 0x5fce <Timer0_enuSetMode+0x6>
    5fce:	00 d0       	rcall	.+0      	; 0x5fd0 <Timer0_enuSetMode+0x8>
    5fd0:	cd b7       	in	r28, 0x3d	; 61
    5fd2:	de b7       	in	r29, 0x3e	; 62
    5fd4:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState=ES_NOK;
    5fd6:	81 e0       	ldi	r24, 0x01	; 1
    5fd8:	89 83       	std	Y+1, r24	; 0x01
	/*Set the mode*/
	switch(Copy_enuTimer0Mode)
    5fda:	8a 81       	ldd	r24, Y+2	; 0x02
    5fdc:	28 2f       	mov	r18, r24
    5fde:	30 e0       	ldi	r19, 0x00	; 0
    5fe0:	3c 83       	std	Y+4, r19	; 0x04
    5fe2:	2b 83       	std	Y+3, r18	; 0x03
    5fe4:	8b 81       	ldd	r24, Y+3	; 0x03
    5fe6:	9c 81       	ldd	r25, Y+4	; 0x04
    5fe8:	81 30       	cpi	r24, 0x01	; 1
    5fea:	91 05       	cpc	r25, r1
    5fec:	21 f1       	breq	.+72     	; 0x6036 <Timer0_enuSetMode+0x6e>
    5fee:	2b 81       	ldd	r18, Y+3	; 0x03
    5ff0:	3c 81       	ldd	r19, Y+4	; 0x04
    5ff2:	22 30       	cpi	r18, 0x02	; 2
    5ff4:	31 05       	cpc	r19, r1
    5ff6:	2c f4       	brge	.+10     	; 0x6002 <Timer0_enuSetMode+0x3a>
    5ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    5ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    5ffc:	00 97       	sbiw	r24, 0x00	; 0
    5ffe:	61 f0       	breq	.+24     	; 0x6018 <Timer0_enuSetMode+0x50>
    6000:	46 c0       	rjmp	.+140    	; 0x608e <Timer0_enuSetMode+0xc6>
    6002:	2b 81       	ldd	r18, Y+3	; 0x03
    6004:	3c 81       	ldd	r19, Y+4	; 0x04
    6006:	22 30       	cpi	r18, 0x02	; 2
    6008:	31 05       	cpc	r19, r1
    600a:	99 f1       	breq	.+102    	; 0x6072 <Timer0_enuSetMode+0xaa>
    600c:	8b 81       	ldd	r24, Y+3	; 0x03
    600e:	9c 81       	ldd	r25, Y+4	; 0x04
    6010:	83 30       	cpi	r24, 0x03	; 3
    6012:	91 05       	cpc	r25, r1
    6014:	f9 f0       	breq	.+62     	; 0x6054 <Timer0_enuSetMode+0x8c>
    6016:	3b c0       	rjmp	.+118    	; 0x608e <Timer0_enuSetMode+0xc6>
	{
	case Timer0_enuOverflow :
		TCCR0 &=~(1<<WGM01);
    6018:	a3 e5       	ldi	r26, 0x53	; 83
    601a:	b0 e0       	ldi	r27, 0x00	; 0
    601c:	e3 e5       	ldi	r30, 0x53	; 83
    601e:	f0 e0       	ldi	r31, 0x00	; 0
    6020:	80 81       	ld	r24, Z
    6022:	87 7f       	andi	r24, 0xF7	; 247
    6024:	8c 93       	st	X, r24
		TCCR0 &=~(1<<WGM00);
    6026:	a3 e5       	ldi	r26, 0x53	; 83
    6028:	b0 e0       	ldi	r27, 0x00	; 0
    602a:	e3 e5       	ldi	r30, 0x53	; 83
    602c:	f0 e0       	ldi	r31, 0x00	; 0
    602e:	80 81       	ld	r24, Z
    6030:	8f 7b       	andi	r24, 0xBF	; 191
    6032:	8c 93       	st	X, r24
    6034:	2c c0       	rjmp	.+88     	; 0x608e <Timer0_enuSetMode+0xc6>
		break;
	case Timer0_enuCTC :
		TCCR0 |=(1<<WGM01);
    6036:	a3 e5       	ldi	r26, 0x53	; 83
    6038:	b0 e0       	ldi	r27, 0x00	; 0
    603a:	e3 e5       	ldi	r30, 0x53	; 83
    603c:	f0 e0       	ldi	r31, 0x00	; 0
    603e:	80 81       	ld	r24, Z
    6040:	88 60       	ori	r24, 0x08	; 8
    6042:	8c 93       	st	X, r24
		TCCR0 &=~(1<<WGM00);
    6044:	a3 e5       	ldi	r26, 0x53	; 83
    6046:	b0 e0       	ldi	r27, 0x00	; 0
    6048:	e3 e5       	ldi	r30, 0x53	; 83
    604a:	f0 e0       	ldi	r31, 0x00	; 0
    604c:	80 81       	ld	r24, Z
    604e:	8f 7b       	andi	r24, 0xBF	; 191
    6050:	8c 93       	st	X, r24
    6052:	1d c0       	rjmp	.+58     	; 0x608e <Timer0_enuSetMode+0xc6>
		break;
	case Timer0_enuPhaseCorrectPWM  :
		TCCR0 &=~(1<<WGM01);
    6054:	a3 e5       	ldi	r26, 0x53	; 83
    6056:	b0 e0       	ldi	r27, 0x00	; 0
    6058:	e3 e5       	ldi	r30, 0x53	; 83
    605a:	f0 e0       	ldi	r31, 0x00	; 0
    605c:	80 81       	ld	r24, Z
    605e:	87 7f       	andi	r24, 0xF7	; 247
    6060:	8c 93       	st	X, r24
		TCCR0 |=(1<<WGM00);
    6062:	a3 e5       	ldi	r26, 0x53	; 83
    6064:	b0 e0       	ldi	r27, 0x00	; 0
    6066:	e3 e5       	ldi	r30, 0x53	; 83
    6068:	f0 e0       	ldi	r31, 0x00	; 0
    606a:	80 81       	ld	r24, Z
    606c:	80 64       	ori	r24, 0x40	; 64
    606e:	8c 93       	st	X, r24
    6070:	0e c0       	rjmp	.+28     	; 0x608e <Timer0_enuSetMode+0xc6>
		break;
	case Timer0_enuFastPWM  :
		TCCR0 |=(1<<WGM01);
    6072:	a3 e5       	ldi	r26, 0x53	; 83
    6074:	b0 e0       	ldi	r27, 0x00	; 0
    6076:	e3 e5       	ldi	r30, 0x53	; 83
    6078:	f0 e0       	ldi	r31, 0x00	; 0
    607a:	80 81       	ld	r24, Z
    607c:	88 60       	ori	r24, 0x08	; 8
    607e:	8c 93       	st	X, r24
		TCCR0 |=(1<<WGM00);
    6080:	a3 e5       	ldi	r26, 0x53	; 83
    6082:	b0 e0       	ldi	r27, 0x00	; 0
    6084:	e3 e5       	ldi	r30, 0x53	; 83
    6086:	f0 e0       	ldi	r31, 0x00	; 0
    6088:	80 81       	ld	r24, Z
    608a:	80 64       	ori	r24, 0x40	; 64
    608c:	8c 93       	st	X, r24
		break;
	default :
		break;
	}

	return Local_enuErrorState;
    608e:	89 81       	ldd	r24, Y+1	; 0x01
}
    6090:	0f 90       	pop	r0
    6092:	0f 90       	pop	r0
    6094:	0f 90       	pop	r0
    6096:	0f 90       	pop	r0
    6098:	cf 91       	pop	r28
    609a:	df 91       	pop	r29
    609c:	08 95       	ret

0000609e <Timer0_enuSetPrescaler>:

ES_t Timer0_enuSetPrescaler(TIMERS_prescaler_t Copy_enuTimer0Prescaler)
{
    609e:	df 93       	push	r29
    60a0:	cf 93       	push	r28
    60a2:	00 d0       	rcall	.+0      	; 0x60a4 <Timer0_enuSetPrescaler+0x6>
    60a4:	cd b7       	in	r28, 0x3d	; 61
    60a6:	de b7       	in	r29, 0x3e	; 62
    60a8:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState=ES_NOK;
    60aa:	81 e0       	ldi	r24, 0x01	; 1
    60ac:	89 83       	std	Y+1, r24	; 0x01

	if((Copy_enuTimer0Prescaler)>= TIMERS_enuNoClockSource && (Copy_enuTimer0Prescaler) <= TIMERS_enuPrescalingBy1024 )
    60ae:	8a 81       	ldd	r24, Y+2	; 0x02
    60b0:	86 30       	cpi	r24, 0x06	; 6
    60b2:	80 f4       	brcc	.+32     	; 0x60d4 <Timer0_enuSetPrescaler+0x36>
	{
		TCCR0 &=0xF8;
    60b4:	a3 e5       	ldi	r26, 0x53	; 83
    60b6:	b0 e0       	ldi	r27, 0x00	; 0
    60b8:	e3 e5       	ldi	r30, 0x53	; 83
    60ba:	f0 e0       	ldi	r31, 0x00	; 0
    60bc:	80 81       	ld	r24, Z
    60be:	88 7f       	andi	r24, 0xF8	; 248
    60c0:	8c 93       	st	X, r24
		TCCR0 |= Copy_enuTimer0Prescaler;
    60c2:	a3 e5       	ldi	r26, 0x53	; 83
    60c4:	b0 e0       	ldi	r27, 0x00	; 0
    60c6:	e3 e5       	ldi	r30, 0x53	; 83
    60c8:	f0 e0       	ldi	r31, 0x00	; 0
    60ca:	90 81       	ld	r25, Z
    60cc:	8a 81       	ldd	r24, Y+2	; 0x02
    60ce:	89 2b       	or	r24, r25
    60d0:	8c 93       	st	X, r24
		Local_enuErrorState=ES_OK;
    60d2:	19 82       	std	Y+1, r1	; 0x01
	}


	return Local_enuErrorState;
    60d4:	89 81       	ldd	r24, Y+1	; 0x01
}
    60d6:	0f 90       	pop	r0
    60d8:	0f 90       	pop	r0
    60da:	cf 91       	pop	r28
    60dc:	df 91       	pop	r29
    60de:	08 95       	ret

000060e0 <Timer0_enuSetCounter>:


ES_t Timer0_enuSetCounter(u8 Copy_u8Counter)
{
    60e0:	df 93       	push	r29
    60e2:	cf 93       	push	r28
    60e4:	00 d0       	rcall	.+0      	; 0x60e6 <Timer0_enuSetCounter+0x6>
    60e6:	cd b7       	in	r28, 0x3d	; 61
    60e8:	de b7       	in	r29, 0x3e	; 62
    60ea:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState=ES_NOK;
    60ec:	81 e0       	ldi	r24, 0x01	; 1
    60ee:	89 83       	std	Y+1, r24	; 0x01

	/*set counter value*/
	TCNT0 = Copy_u8Counter;
    60f0:	e2 e5       	ldi	r30, 0x52	; 82
    60f2:	f0 e0       	ldi	r31, 0x00	; 0
    60f4:	8a 81       	ldd	r24, Y+2	; 0x02
    60f6:	80 83       	st	Z, r24
	Local_enuErrorState=ES_OK;
    60f8:	19 82       	std	Y+1, r1	; 0x01


	return Local_enuErrorState;
    60fa:	89 81       	ldd	r24, Y+1	; 0x01

}
    60fc:	0f 90       	pop	r0
    60fe:	0f 90       	pop	r0
    6100:	cf 91       	pop	r28
    6102:	df 91       	pop	r29
    6104:	08 95       	ret

00006106 <Timer0_enuGetCounter>:

ES_t Timer0_enuGetCounter(u8 *Copy_u8Counter)
{
    6106:	df 93       	push	r29
    6108:	cf 93       	push	r28
    610a:	00 d0       	rcall	.+0      	; 0x610c <Timer0_enuGetCounter+0x6>
    610c:	0f 92       	push	r0
    610e:	cd b7       	in	r28, 0x3d	; 61
    6110:	de b7       	in	r29, 0x3e	; 62
    6112:	9b 83       	std	Y+3, r25	; 0x03
    6114:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState=ES_NOK;
    6116:	81 e0       	ldi	r24, 0x01	; 1
    6118:	89 83       	std	Y+1, r24	; 0x01

	/*Get counter value*/
	*Copy_u8Counter = TCNT0;
    611a:	e2 e5       	ldi	r30, 0x52	; 82
    611c:	f0 e0       	ldi	r31, 0x00	; 0
    611e:	80 81       	ld	r24, Z
    6120:	ea 81       	ldd	r30, Y+2	; 0x02
    6122:	fb 81       	ldd	r31, Y+3	; 0x03
    6124:	80 83       	st	Z, r24

	Local_enuErrorState=ES_OK;
    6126:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    6128:	89 81       	ldd	r24, Y+1	; 0x01
}
    612a:	0f 90       	pop	r0
    612c:	0f 90       	pop	r0
    612e:	0f 90       	pop	r0
    6130:	cf 91       	pop	r28
    6132:	df 91       	pop	r29
    6134:	08 95       	ret

00006136 <Timer0_enuSetCmpareMatch>:

ES_t Timer0_enuSetCmpareMatch(u8 Copy_u8CompareMatchValue)
{
    6136:	df 93       	push	r29
    6138:	cf 93       	push	r28
    613a:	00 d0       	rcall	.+0      	; 0x613c <Timer0_enuSetCmpareMatch+0x6>
    613c:	cd b7       	in	r28, 0x3d	; 61
    613e:	de b7       	in	r29, 0x3e	; 62
    6140:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState=ES_NOK;
    6142:	81 e0       	ldi	r24, 0x01	; 1
    6144:	89 83       	std	Y+1, r24	; 0x01

	/*set compare match value*/
	OCR0 = Copy_u8CompareMatchValue;
    6146:	ec e5       	ldi	r30, 0x5C	; 92
    6148:	f0 e0       	ldi	r31, 0x00	; 0
    614a:	8a 81       	ldd	r24, Y+2	; 0x02
    614c:	80 83       	st	Z, r24
	Local_enuErrorState=ES_OK;
    614e:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    6150:	89 81       	ldd	r24, Y+1	; 0x01

}
    6152:	0f 90       	pop	r0
    6154:	0f 90       	pop	r0
    6156:	cf 91       	pop	r28
    6158:	df 91       	pop	r29
    615a:	08 95       	ret

0000615c <Timer0_enuSetOC0Action>:

ES_t Timer0_enuSetOC0Action(TIMERS_OutputPinAction_t Copy_enuTime0OC0Act)
{
    615c:	df 93       	push	r29
    615e:	cf 93       	push	r28
    6160:	00 d0       	rcall	.+0      	; 0x6162 <Timer0_enuSetOC0Action+0x6>
    6162:	cd b7       	in	r28, 0x3d	; 61
    6164:	de b7       	in	r29, 0x3e	; 62
    6166:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState=ES_NOK;
    6168:	81 e0       	ldi	r24, 0x01	; 1
    616a:	89 83       	std	Y+1, r24	; 0x01

	/*********************************************/
	/**                  OC0                    **/
	/*********************************************/

	if(Copy_enuTime0OC0Act == Disconnect)
    616c:	8a 81       	ldd	r24, Y+2	; 0x02
    616e:	88 23       	and	r24, r24
    6170:	79 f4       	brne	.+30     	; 0x6190 <Timer0_enuSetOC0Action+0x34>
	{
		TCCR0&=~(1<<COM00);
    6172:	a3 e5       	ldi	r26, 0x53	; 83
    6174:	b0 e0       	ldi	r27, 0x00	; 0
    6176:	e3 e5       	ldi	r30, 0x53	; 83
    6178:	f0 e0       	ldi	r31, 0x00	; 0
    617a:	80 81       	ld	r24, Z
    617c:	8f 7e       	andi	r24, 0xEF	; 239
    617e:	8c 93       	st	X, r24
		TCCR0&=~(1<<COM01);
    6180:	a3 e5       	ldi	r26, 0x53	; 83
    6182:	b0 e0       	ldi	r27, 0x00	; 0
    6184:	e3 e5       	ldi	r30, 0x53	; 83
    6186:	f0 e0       	ldi	r31, 0x00	; 0
    6188:	80 81       	ld	r24, Z
    618a:	8f 7d       	andi	r24, 0xDF	; 223
    618c:	8c 93       	st	X, r24
    618e:	3e c0       	rjmp	.+124    	; 0x620c <Timer0_enuSetOC0Action+0xb0>
	}
	else if(Copy_enuTime0OC0Act== ToggleOnCompare)
    6190:	8a 81       	ldd	r24, Y+2	; 0x02
    6192:	81 30       	cpi	r24, 0x01	; 1
    6194:	91 f4       	brne	.+36     	; 0x61ba <Timer0_enuSetOC0Action+0x5e>
	{
		if(Copy_enuTime0OC0Act == Timer0_enuCTC)
    6196:	8a 81       	ldd	r24, Y+2	; 0x02
    6198:	81 30       	cpi	r24, 0x01	; 1
    619a:	c1 f5       	brne	.+112    	; 0x620c <Timer0_enuSetOC0Action+0xb0>
		{
			TCCR0|=(1<<COM00);
    619c:	a3 e5       	ldi	r26, 0x53	; 83
    619e:	b0 e0       	ldi	r27, 0x00	; 0
    61a0:	e3 e5       	ldi	r30, 0x53	; 83
    61a2:	f0 e0       	ldi	r31, 0x00	; 0
    61a4:	80 81       	ld	r24, Z
    61a6:	80 61       	ori	r24, 0x10	; 16
    61a8:	8c 93       	st	X, r24
			TCCR0&=~(1<<COM01);
    61aa:	a3 e5       	ldi	r26, 0x53	; 83
    61ac:	b0 e0       	ldi	r27, 0x00	; 0
    61ae:	e3 e5       	ldi	r30, 0x53	; 83
    61b0:	f0 e0       	ldi	r31, 0x00	; 0
    61b2:	80 81       	ld	r24, Z
    61b4:	8f 7d       	andi	r24, 0xDF	; 223
    61b6:	8c 93       	st	X, r24
    61b8:	29 c0       	rjmp	.+82     	; 0x620c <Timer0_enuSetOC0Action+0xb0>
		}
	}
	else if((Copy_enuTime0OC0Act == ClearOnCompare) || (Copy_enuTime0OC0Act == PWM_NonInverted) )
    61ba:	8a 81       	ldd	r24, Y+2	; 0x02
    61bc:	82 30       	cpi	r24, 0x02	; 2
    61be:	19 f0       	breq	.+6      	; 0x61c6 <Timer0_enuSetOC0Action+0x6a>
    61c0:	8a 81       	ldd	r24, Y+2	; 0x02
    61c2:	84 30       	cpi	r24, 0x04	; 4
    61c4:	79 f4       	brne	.+30     	; 0x61e4 <Timer0_enuSetOC0Action+0x88>
	{
		TCCR0&=~(1<<COM00);
    61c6:	a3 e5       	ldi	r26, 0x53	; 83
    61c8:	b0 e0       	ldi	r27, 0x00	; 0
    61ca:	e3 e5       	ldi	r30, 0x53	; 83
    61cc:	f0 e0       	ldi	r31, 0x00	; 0
    61ce:	80 81       	ld	r24, Z
    61d0:	8f 7e       	andi	r24, 0xEF	; 239
    61d2:	8c 93       	st	X, r24
		TCCR0|=(1<<COM01);
    61d4:	a3 e5       	ldi	r26, 0x53	; 83
    61d6:	b0 e0       	ldi	r27, 0x00	; 0
    61d8:	e3 e5       	ldi	r30, 0x53	; 83
    61da:	f0 e0       	ldi	r31, 0x00	; 0
    61dc:	80 81       	ld	r24, Z
    61de:	80 62       	ori	r24, 0x20	; 32
    61e0:	8c 93       	st	X, r24
    61e2:	14 c0       	rjmp	.+40     	; 0x620c <Timer0_enuSetOC0Action+0xb0>
	}
	else if((Copy_enuTime0OC0Act == SetOnCompare) || (Copy_enuTime0OC0Act == PWM_Inverted))
    61e4:	8a 81       	ldd	r24, Y+2	; 0x02
    61e6:	83 30       	cpi	r24, 0x03	; 3
    61e8:	19 f0       	breq	.+6      	; 0x61f0 <Timer0_enuSetOC0Action+0x94>
    61ea:	8a 81       	ldd	r24, Y+2	; 0x02
    61ec:	85 30       	cpi	r24, 0x05	; 5
    61ee:	71 f4       	brne	.+28     	; 0x620c <Timer0_enuSetOC0Action+0xb0>
	{
		TCCR0|=(1<<COM00);
    61f0:	a3 e5       	ldi	r26, 0x53	; 83
    61f2:	b0 e0       	ldi	r27, 0x00	; 0
    61f4:	e3 e5       	ldi	r30, 0x53	; 83
    61f6:	f0 e0       	ldi	r31, 0x00	; 0
    61f8:	80 81       	ld	r24, Z
    61fa:	80 61       	ori	r24, 0x10	; 16
    61fc:	8c 93       	st	X, r24
		TCCR0|=(1<<COM01);
    61fe:	a3 e5       	ldi	r26, 0x53	; 83
    6200:	b0 e0       	ldi	r27, 0x00	; 0
    6202:	e3 e5       	ldi	r30, 0x53	; 83
    6204:	f0 e0       	ldi	r31, 0x00	; 0
    6206:	80 81       	ld	r24, Z
    6208:	80 62       	ori	r24, 0x20	; 32
    620a:	8c 93       	st	X, r24
	}

	return Local_enuErrorState;
    620c:	89 81       	ldd	r24, Y+1	; 0x01
}
    620e:	0f 90       	pop	r0
    6210:	0f 90       	pop	r0
    6212:	cf 91       	pop	r28
    6214:	df 91       	pop	r29
    6216:	08 95       	ret

00006218 <Timer0_enuOverFlowINT_Enable>:


ES_t Timer0_enuOverFlowINT_Enable()
{
    6218:	df 93       	push	r29
    621a:	cf 93       	push	r28
    621c:	0f 92       	push	r0
    621e:	cd b7       	in	r28, 0x3d	; 61
    6220:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState=ES_NOK;
    6222:	81 e0       	ldi	r24, 0x01	; 1
    6224:	89 83       	std	Y+1, r24	; 0x01

	TIMSK|=(1<<TOIE0);
    6226:	a9 e5       	ldi	r26, 0x59	; 89
    6228:	b0 e0       	ldi	r27, 0x00	; 0
    622a:	e9 e5       	ldi	r30, 0x59	; 89
    622c:	f0 e0       	ldi	r31, 0x00	; 0
    622e:	80 81       	ld	r24, Z
    6230:	81 60       	ori	r24, 0x01	; 1
    6232:	8c 93       	st	X, r24

	return Local_enuErrorState;
    6234:	89 81       	ldd	r24, Y+1	; 0x01

}
    6236:	0f 90       	pop	r0
    6238:	cf 91       	pop	r28
    623a:	df 91       	pop	r29
    623c:	08 95       	ret

0000623e <Timer0_enuOverFlowINT_Disable>:

ES_t Timer0_enuOverFlowINT_Disable()
{
    623e:	df 93       	push	r29
    6240:	cf 93       	push	r28
    6242:	0f 92       	push	r0
    6244:	cd b7       	in	r28, 0x3d	; 61
    6246:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState=ES_NOK;
    6248:	81 e0       	ldi	r24, 0x01	; 1
    624a:	89 83       	std	Y+1, r24	; 0x01

	TIMSK&=~(1<<TOIE0);
    624c:	a9 e5       	ldi	r26, 0x59	; 89
    624e:	b0 e0       	ldi	r27, 0x00	; 0
    6250:	e9 e5       	ldi	r30, 0x59	; 89
    6252:	f0 e0       	ldi	r31, 0x00	; 0
    6254:	80 81       	ld	r24, Z
    6256:	8e 7f       	andi	r24, 0xFE	; 254
    6258:	8c 93       	st	X, r24

	return Local_enuErrorState;
    625a:	89 81       	ldd	r24, Y+1	; 0x01
}
    625c:	0f 90       	pop	r0
    625e:	cf 91       	pop	r28
    6260:	df 91       	pop	r29
    6262:	08 95       	ret

00006264 <Timer0_enuCTC_INT_Enable>:

ES_t Timer0_enuCTC_INT_Enable()
{
    6264:	df 93       	push	r29
    6266:	cf 93       	push	r28
    6268:	0f 92       	push	r0
    626a:	cd b7       	in	r28, 0x3d	; 61
    626c:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState=ES_NOK;
    626e:	81 e0       	ldi	r24, 0x01	; 1
    6270:	89 83       	std	Y+1, r24	; 0x01

	TIMSK|=(1<<OCIE0);
    6272:	a9 e5       	ldi	r26, 0x59	; 89
    6274:	b0 e0       	ldi	r27, 0x00	; 0
    6276:	e9 e5       	ldi	r30, 0x59	; 89
    6278:	f0 e0       	ldi	r31, 0x00	; 0
    627a:	80 81       	ld	r24, Z
    627c:	82 60       	ori	r24, 0x02	; 2
    627e:	8c 93       	st	X, r24

	return Local_enuErrorState;
    6280:	89 81       	ldd	r24, Y+1	; 0x01
}
    6282:	0f 90       	pop	r0
    6284:	cf 91       	pop	r28
    6286:	df 91       	pop	r29
    6288:	08 95       	ret

0000628a <Timer0_enuCTC_INT_Disable>:

ES_t Timer0_enuCTC_INT_Disable()
{
    628a:	df 93       	push	r29
    628c:	cf 93       	push	r28
    628e:	0f 92       	push	r0
    6290:	cd b7       	in	r28, 0x3d	; 61
    6292:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState=ES_NOK;
    6294:	81 e0       	ldi	r24, 0x01	; 1
    6296:	89 83       	std	Y+1, r24	; 0x01

	TIMSK&=~(1<<OCIE0);
    6298:	a9 e5       	ldi	r26, 0x59	; 89
    629a:	b0 e0       	ldi	r27, 0x00	; 0
    629c:	e9 e5       	ldi	r30, 0x59	; 89
    629e:	f0 e0       	ldi	r31, 0x00	; 0
    62a0:	80 81       	ld	r24, Z
    62a2:	8d 7f       	andi	r24, 0xFD	; 253
    62a4:	8c 93       	st	X, r24

	return Local_enuErrorState;
    62a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    62a8:	0f 90       	pop	r0
    62aa:	cf 91       	pop	r28
    62ac:	df 91       	pop	r29
    62ae:	08 95       	ret

000062b0 <Timer0_enuCallBack>:


ES_t Timer0_enuCallBack(TIMERS_Mode_t Copy_enuTimer0Mode , void(*Copy_pfunTimer0func)(void))
{
    62b0:	df 93       	push	r29
    62b2:	cf 93       	push	r28
    62b4:	00 d0       	rcall	.+0      	; 0x62b6 <Timer0_enuCallBack+0x6>
    62b6:	00 d0       	rcall	.+0      	; 0x62b8 <Timer0_enuCallBack+0x8>
    62b8:	00 d0       	rcall	.+0      	; 0x62ba <Timer0_enuCallBack+0xa>
    62ba:	cd b7       	in	r28, 0x3d	; 61
    62bc:	de b7       	in	r29, 0x3e	; 62
    62be:	8a 83       	std	Y+2, r24	; 0x02
    62c0:	7c 83       	std	Y+4, r23	; 0x04
    62c2:	6b 83       	std	Y+3, r22	; 0x03
	ES_t Local_enuErrorState=ES_NOK;
    62c4:	81 e0       	ldi	r24, 0x01	; 1
    62c6:	89 83       	std	Y+1, r24	; 0x01

	if(Copy_pfunTimer0func == NULL)
    62c8:	8b 81       	ldd	r24, Y+3	; 0x03
    62ca:	9c 81       	ldd	r25, Y+4	; 0x04
    62cc:	00 97       	sbiw	r24, 0x00	; 0
    62ce:	19 f4       	brne	.+6      	; 0x62d6 <Timer0_enuCallBack+0x26>
	{
		Local_enuErrorState=ES_NULL_POINTER;
    62d0:	82 e0       	ldi	r24, 0x02	; 2
    62d2:	89 83       	std	Y+1, r24	; 0x01
    62d4:	1e c0       	rjmp	.+60     	; 0x6312 <Timer0_enuCallBack+0x62>
	}
	else
	{
		switch(Copy_enuTimer0Mode)
    62d6:	8a 81       	ldd	r24, Y+2	; 0x02
    62d8:	28 2f       	mov	r18, r24
    62da:	30 e0       	ldi	r19, 0x00	; 0
    62dc:	3e 83       	std	Y+6, r19	; 0x06
    62de:	2d 83       	std	Y+5, r18	; 0x05
    62e0:	8d 81       	ldd	r24, Y+5	; 0x05
    62e2:	9e 81       	ldd	r25, Y+6	; 0x06
    62e4:	00 97       	sbiw	r24, 0x00	; 0
    62e6:	31 f0       	breq	.+12     	; 0x62f4 <Timer0_enuCallBack+0x44>
    62e8:	2d 81       	ldd	r18, Y+5	; 0x05
    62ea:	3e 81       	ldd	r19, Y+6	; 0x06
    62ec:	21 30       	cpi	r18, 0x01	; 1
    62ee:	31 05       	cpc	r19, r1
    62f0:	49 f0       	breq	.+18     	; 0x6304 <Timer0_enuCallBack+0x54>
    62f2:	0f c0       	rjmp	.+30     	; 0x6312 <Timer0_enuCallBack+0x62>
		{
		case Timer0_enuOverflow:
			Timer0_pfuncTimer0OVFunc = Copy_pfunTimer0func;
    62f4:	8b 81       	ldd	r24, Y+3	; 0x03
    62f6:	9c 81       	ldd	r25, Y+4	; 0x04
    62f8:	90 93 bf 06 	sts	0x06BF, r25
    62fc:	80 93 be 06 	sts	0x06BE, r24
			Local_enuErrorState=ES_OK;
    6300:	19 82       	std	Y+1, r1	; 0x01
    6302:	07 c0       	rjmp	.+14     	; 0x6312 <Timer0_enuCallBack+0x62>
			break;
		case Timer0_enuCTC:
			Timer0_pfuncTimer0CTCFunc = Copy_pfunTimer0func;
    6304:	8b 81       	ldd	r24, Y+3	; 0x03
    6306:	9c 81       	ldd	r25, Y+4	; 0x04
    6308:	90 93 c1 06 	sts	0x06C1, r25
    630c:	80 93 c0 06 	sts	0x06C0, r24
			Local_enuErrorState=ES_OK;
    6310:	19 82       	std	Y+1, r1	; 0x01
		default :
			break;
		}
	}

	return Local_enuErrorState;
    6312:	89 81       	ldd	r24, Y+1	; 0x01
}
    6314:	26 96       	adiw	r28, 0x06	; 6
    6316:	0f b6       	in	r0, 0x3f	; 63
    6318:	f8 94       	cli
    631a:	de bf       	out	0x3e, r29	; 62
    631c:	0f be       	out	0x3f, r0	; 63
    631e:	cd bf       	out	0x3d, r28	; 61
    6320:	cf 91       	pop	r28
    6322:	df 91       	pop	r29
    6324:	08 95       	ret

00006326 <__vector_10>:

// compare match ISR
void __vector_10(void) __attribute__((signal));
void __vector_10(void)
{
    6326:	1f 92       	push	r1
    6328:	0f 92       	push	r0
    632a:	0f b6       	in	r0, 0x3f	; 63
    632c:	0f 92       	push	r0
    632e:	11 24       	eor	r1, r1
    6330:	2f 93       	push	r18
    6332:	3f 93       	push	r19
    6334:	4f 93       	push	r20
    6336:	5f 93       	push	r21
    6338:	6f 93       	push	r22
    633a:	7f 93       	push	r23
    633c:	8f 93       	push	r24
    633e:	9f 93       	push	r25
    6340:	af 93       	push	r26
    6342:	bf 93       	push	r27
    6344:	ef 93       	push	r30
    6346:	ff 93       	push	r31
    6348:	df 93       	push	r29
    634a:	cf 93       	push	r28
    634c:	cd b7       	in	r28, 0x3d	; 61
    634e:	de b7       	in	r29, 0x3e	; 62
	if(Timer0_pfuncTimer0CTCFunc!=NULL)
    6350:	80 91 c0 06 	lds	r24, 0x06C0
    6354:	90 91 c1 06 	lds	r25, 0x06C1
    6358:	00 97       	sbiw	r24, 0x00	; 0
    635a:	29 f0       	breq	.+10     	; 0x6366 <__vector_10+0x40>
	{
		Timer0_pfuncTimer0CTCFunc();
    635c:	e0 91 c0 06 	lds	r30, 0x06C0
    6360:	f0 91 c1 06 	lds	r31, 0x06C1
    6364:	09 95       	icall
	}

}
    6366:	cf 91       	pop	r28
    6368:	df 91       	pop	r29
    636a:	ff 91       	pop	r31
    636c:	ef 91       	pop	r30
    636e:	bf 91       	pop	r27
    6370:	af 91       	pop	r26
    6372:	9f 91       	pop	r25
    6374:	8f 91       	pop	r24
    6376:	7f 91       	pop	r23
    6378:	6f 91       	pop	r22
    637a:	5f 91       	pop	r21
    637c:	4f 91       	pop	r20
    637e:	3f 91       	pop	r19
    6380:	2f 91       	pop	r18
    6382:	0f 90       	pop	r0
    6384:	0f be       	out	0x3f, r0	; 63
    6386:	0f 90       	pop	r0
    6388:	1f 90       	pop	r1
    638a:	18 95       	reti

0000638c <__vector_11>:

// overflow ISR
void __vector_11(void) __attribute__((signal));
void __vector_11(void)
{
    638c:	1f 92       	push	r1
    638e:	0f 92       	push	r0
    6390:	0f b6       	in	r0, 0x3f	; 63
    6392:	0f 92       	push	r0
    6394:	11 24       	eor	r1, r1
    6396:	2f 93       	push	r18
    6398:	3f 93       	push	r19
    639a:	4f 93       	push	r20
    639c:	5f 93       	push	r21
    639e:	6f 93       	push	r22
    63a0:	7f 93       	push	r23
    63a2:	8f 93       	push	r24
    63a4:	9f 93       	push	r25
    63a6:	af 93       	push	r26
    63a8:	bf 93       	push	r27
    63aa:	ef 93       	push	r30
    63ac:	ff 93       	push	r31
    63ae:	df 93       	push	r29
    63b0:	cf 93       	push	r28
    63b2:	cd b7       	in	r28, 0x3d	; 61
    63b4:	de b7       	in	r29, 0x3e	; 62
	if(Timer0_pfuncTimer0OVFunc!=NULL)
    63b6:	80 91 be 06 	lds	r24, 0x06BE
    63ba:	90 91 bf 06 	lds	r25, 0x06BF
    63be:	00 97       	sbiw	r24, 0x00	; 0
    63c0:	29 f0       	breq	.+10     	; 0x63cc <__vector_11+0x40>
	{
		Timer0_pfuncTimer0OVFunc();
    63c2:	e0 91 be 06 	lds	r30, 0x06BE
    63c6:	f0 91 bf 06 	lds	r31, 0x06BF
    63ca:	09 95       	icall
	}

}
    63cc:	cf 91       	pop	r28
    63ce:	df 91       	pop	r29
    63d0:	ff 91       	pop	r31
    63d2:	ef 91       	pop	r30
    63d4:	bf 91       	pop	r27
    63d6:	af 91       	pop	r26
    63d8:	9f 91       	pop	r25
    63da:	8f 91       	pop	r24
    63dc:	7f 91       	pop	r23
    63de:	6f 91       	pop	r22
    63e0:	5f 91       	pop	r21
    63e2:	4f 91       	pop	r20
    63e4:	3f 91       	pop	r19
    63e6:	2f 91       	pop	r18
    63e8:	0f 90       	pop	r0
    63ea:	0f be       	out	0x3f, r0	; 63
    63ec:	0f 90       	pop	r0
    63ee:	1f 90       	pop	r1
    63f0:	18 95       	reti

000063f2 <Timer1_enuInit>:
/***************************************************/
/*                     TIMER1                      */
/***************************************************/

ES_t Timer1_enuInit(Timer1_t *Copy_strTimer1Config)
{
    63f2:	df 93       	push	r29
    63f4:	cf 93       	push	r28
    63f6:	cd b7       	in	r28, 0x3d	; 61
    63f8:	de b7       	in	r29, 0x3e	; 62
    63fa:	29 97       	sbiw	r28, 0x09	; 9
    63fc:	0f b6       	in	r0, 0x3f	; 63
    63fe:	f8 94       	cli
    6400:	de bf       	out	0x3e, r29	; 62
    6402:	0f be       	out	0x3f, r0	; 63
    6404:	cd bf       	out	0x3d, r28	; 61
    6406:	9b 83       	std	Y+3, r25	; 0x03
    6408:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    640a:	81 e0       	ldi	r24, 0x01	; 1
    640c:	89 83       	std	Y+1, r24	; 0x01


	/*set the mode of timer1*/

	switch(Copy_strTimer1Config->Timer1_enuMode)
    640e:	ea 81       	ldd	r30, Y+2	; 0x02
    6410:	fb 81       	ldd	r31, Y+3	; 0x03
    6412:	80 81       	ld	r24, Z
    6414:	28 2f       	mov	r18, r24
    6416:	30 e0       	ldi	r19, 0x00	; 0
    6418:	39 87       	std	Y+9, r19	; 0x09
    641a:	28 87       	std	Y+8, r18	; 0x08
    641c:	88 85       	ldd	r24, Y+8	; 0x08
    641e:	99 85       	ldd	r25, Y+9	; 0x09
    6420:	85 30       	cpi	r24, 0x05	; 5
    6422:	91 05       	cpc	r25, r1
    6424:	51 f1       	breq	.+84     	; 0x647a <Timer1_enuInit+0x88>
    6426:	28 85       	ldd	r18, Y+8	; 0x08
    6428:	39 85       	ldd	r19, Y+9	; 0x09
    642a:	26 30       	cpi	r18, 0x06	; 6
    642c:	31 05       	cpc	r19, r1
    642e:	09 f4       	brne	.+2      	; 0x6432 <Timer1_enuInit+0x40>
    6430:	42 c0       	rjmp	.+132    	; 0x64b6 <Timer1_enuInit+0xc4>
    6432:	88 85       	ldd	r24, Y+8	; 0x08
    6434:	99 85       	ldd	r25, Y+9	; 0x09
    6436:	84 30       	cpi	r24, 0x04	; 4
    6438:	91 05       	cpc	r25, r1
    643a:	09 f0       	breq	.+2      	; 0x643e <Timer1_enuInit+0x4c>
    643c:	5a c0       	rjmp	.+180    	; 0x64f2 <Timer1_enuInit+0x100>
	{
	case Timer1_enuOverflow:
		TCCR1A&=~(1<<WGM10);
    643e:	af e4       	ldi	r26, 0x4F	; 79
    6440:	b0 e0       	ldi	r27, 0x00	; 0
    6442:	ef e4       	ldi	r30, 0x4F	; 79
    6444:	f0 e0       	ldi	r31, 0x00	; 0
    6446:	80 81       	ld	r24, Z
    6448:	8e 7f       	andi	r24, 0xFE	; 254
    644a:	8c 93       	st	X, r24
		TCCR1A&=~(1<<WGM11);
    644c:	af e4       	ldi	r26, 0x4F	; 79
    644e:	b0 e0       	ldi	r27, 0x00	; 0
    6450:	ef e4       	ldi	r30, 0x4F	; 79
    6452:	f0 e0       	ldi	r31, 0x00	; 0
    6454:	80 81       	ld	r24, Z
    6456:	8d 7f       	andi	r24, 0xFD	; 253
    6458:	8c 93       	st	X, r24
		TCCR1B&=~(1<<WGM12);
    645a:	ae e4       	ldi	r26, 0x4E	; 78
    645c:	b0 e0       	ldi	r27, 0x00	; 0
    645e:	ee e4       	ldi	r30, 0x4E	; 78
    6460:	f0 e0       	ldi	r31, 0x00	; 0
    6462:	80 81       	ld	r24, Z
    6464:	87 7f       	andi	r24, 0xF7	; 247
    6466:	8c 93       	st	X, r24
		TCCR1B&=~(1<<WGM13);
    6468:	ae e4       	ldi	r26, 0x4E	; 78
    646a:	b0 e0       	ldi	r27, 0x00	; 0
    646c:	ee e4       	ldi	r30, 0x4E	; 78
    646e:	f0 e0       	ldi	r31, 0x00	; 0
    6470:	80 81       	ld	r24, Z
    6472:	8f 7e       	andi	r24, 0xEF	; 239
    6474:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6476:	19 82       	std	Y+1, r1	; 0x01
    6478:	3e c0       	rjmp	.+124    	; 0x64f6 <Timer1_enuInit+0x104>
		break;
	case Timer1_enuCTC:
		TCCR1A&=~(1<<WGM10);
    647a:	af e4       	ldi	r26, 0x4F	; 79
    647c:	b0 e0       	ldi	r27, 0x00	; 0
    647e:	ef e4       	ldi	r30, 0x4F	; 79
    6480:	f0 e0       	ldi	r31, 0x00	; 0
    6482:	80 81       	ld	r24, Z
    6484:	8e 7f       	andi	r24, 0xFE	; 254
    6486:	8c 93       	st	X, r24
		TCCR1A&=~(1<<WGM11);
    6488:	af e4       	ldi	r26, 0x4F	; 79
    648a:	b0 e0       	ldi	r27, 0x00	; 0
    648c:	ef e4       	ldi	r30, 0x4F	; 79
    648e:	f0 e0       	ldi	r31, 0x00	; 0
    6490:	80 81       	ld	r24, Z
    6492:	8d 7f       	andi	r24, 0xFD	; 253
    6494:	8c 93       	st	X, r24
		TCCR1B|=(1<<WGM12);
    6496:	ae e4       	ldi	r26, 0x4E	; 78
    6498:	b0 e0       	ldi	r27, 0x00	; 0
    649a:	ee e4       	ldi	r30, 0x4E	; 78
    649c:	f0 e0       	ldi	r31, 0x00	; 0
    649e:	80 81       	ld	r24, Z
    64a0:	88 60       	ori	r24, 0x08	; 8
    64a2:	8c 93       	st	X, r24
		TCCR1B&=~(1<<WGM13);
    64a4:	ae e4       	ldi	r26, 0x4E	; 78
    64a6:	b0 e0       	ldi	r27, 0x00	; 0
    64a8:	ee e4       	ldi	r30, 0x4E	; 78
    64aa:	f0 e0       	ldi	r31, 0x00	; 0
    64ac:	80 81       	ld	r24, Z
    64ae:	8f 7e       	andi	r24, 0xEF	; 239
    64b0:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    64b2:	19 82       	std	Y+1, r1	; 0x01
    64b4:	20 c0       	rjmp	.+64     	; 0x64f6 <Timer1_enuInit+0x104>
		break;
	case Timer1_enuFastPWM_TopICR1:
		TCCR1A&=~(1<<WGM10);
    64b6:	af e4       	ldi	r26, 0x4F	; 79
    64b8:	b0 e0       	ldi	r27, 0x00	; 0
    64ba:	ef e4       	ldi	r30, 0x4F	; 79
    64bc:	f0 e0       	ldi	r31, 0x00	; 0
    64be:	80 81       	ld	r24, Z
    64c0:	8e 7f       	andi	r24, 0xFE	; 254
    64c2:	8c 93       	st	X, r24
		TCCR1A|=(1<<WGM11);
    64c4:	af e4       	ldi	r26, 0x4F	; 79
    64c6:	b0 e0       	ldi	r27, 0x00	; 0
    64c8:	ef e4       	ldi	r30, 0x4F	; 79
    64ca:	f0 e0       	ldi	r31, 0x00	; 0
    64cc:	80 81       	ld	r24, Z
    64ce:	82 60       	ori	r24, 0x02	; 2
    64d0:	8c 93       	st	X, r24
		TCCR1B|=(1<<WGM12);
    64d2:	ae e4       	ldi	r26, 0x4E	; 78
    64d4:	b0 e0       	ldi	r27, 0x00	; 0
    64d6:	ee e4       	ldi	r30, 0x4E	; 78
    64d8:	f0 e0       	ldi	r31, 0x00	; 0
    64da:	80 81       	ld	r24, Z
    64dc:	88 60       	ori	r24, 0x08	; 8
    64de:	8c 93       	st	X, r24
		TCCR1B|=(1<<WGM13);
    64e0:	ae e4       	ldi	r26, 0x4E	; 78
    64e2:	b0 e0       	ldi	r27, 0x00	; 0
    64e4:	ee e4       	ldi	r30, 0x4E	; 78
    64e6:	f0 e0       	ldi	r31, 0x00	; 0
    64e8:	80 81       	ld	r24, Z
    64ea:	80 61       	ori	r24, 0x10	; 16
    64ec:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    64ee:	19 82       	std	Y+1, r1	; 0x01
    64f0:	02 c0       	rjmp	.+4      	; 0x64f6 <Timer1_enuInit+0x104>
		break;
	default:
		Local_enuErrorState = ES_OUT_OF_RANGE;
    64f2:	83 e0       	ldi	r24, 0x03	; 3
    64f4:	89 83       	std	Y+1, r24	; 0x01
		break;
	}

	/*set the compare match values*/
	OCR1A = Copy_strTimer1Config->Timer1_u16Comparematch_A_Value ;
    64f6:	aa e4       	ldi	r26, 0x4A	; 74
    64f8:	b0 e0       	ldi	r27, 0x00	; 0
    64fa:	ea 81       	ldd	r30, Y+2	; 0x02
    64fc:	fb 81       	ldd	r31, Y+3	; 0x03
    64fe:	86 81       	ldd	r24, Z+6	; 0x06
    6500:	97 81       	ldd	r25, Z+7	; 0x07
    6502:	11 96       	adiw	r26, 0x01	; 1
    6504:	9c 93       	st	X, r25
    6506:	8e 93       	st	-X, r24
	OCR1B = Copy_strTimer1Config->Timer1_u16Comparematch_B_Value ;
    6508:	a8 e4       	ldi	r26, 0x48	; 72
    650a:	b0 e0       	ldi	r27, 0x00	; 0
    650c:	ea 81       	ldd	r30, Y+2	; 0x02
    650e:	fb 81       	ldd	r31, Y+3	; 0x03
    6510:	80 85       	ldd	r24, Z+8	; 0x08
    6512:	91 85       	ldd	r25, Z+9	; 0x09
    6514:	11 96       	adiw	r26, 0x01	; 1
    6516:	9c 93       	st	X, r25
    6518:	8e 93       	st	-X, r24
	/*set input capture register value*/
	ICR1  = Copy_strTimer1Config->Timer1_u16InputCapRegValue ;
    651a:	a6 e4       	ldi	r26, 0x46	; 70
    651c:	b0 e0       	ldi	r27, 0x00	; 0
    651e:	ea 81       	ldd	r30, Y+2	; 0x02
    6520:	fb 81       	ldd	r31, Y+3	; 0x03
    6522:	82 85       	ldd	r24, Z+10	; 0x0a
    6524:	93 85       	ldd	r25, Z+11	; 0x0b
    6526:	11 96       	adiw	r26, 0x01	; 1
    6528:	9c 93       	st	X, r25
    652a:	8e 93       	st	-X, r24

	TCNT1 = Copy_strTimer1Config->Timer1_u16Counter;
    652c:	ac e4       	ldi	r26, 0x4C	; 76
    652e:	b0 e0       	ldi	r27, 0x00	; 0
    6530:	ea 81       	ldd	r30, Y+2	; 0x02
    6532:	fb 81       	ldd	r31, Y+3	; 0x03
    6534:	84 81       	ldd	r24, Z+4	; 0x04
    6536:	95 81       	ldd	r25, Z+5	; 0x05
    6538:	11 96       	adiw	r26, 0x01	; 1
    653a:	9c 93       	st	X, r25
    653c:	8e 93       	st	-X, r24

	/*OC1A Action*/

	switch(Copy_strTimer1Config->Timer1_enuOC1A_Action)
    653e:	ea 81       	ldd	r30, Y+2	; 0x02
    6540:	fb 81       	ldd	r31, Y+3	; 0x03
    6542:	81 81       	ldd	r24, Z+1	; 0x01
    6544:	28 2f       	mov	r18, r24
    6546:	30 e0       	ldi	r19, 0x00	; 0
    6548:	3f 83       	std	Y+7, r19	; 0x07
    654a:	2e 83       	std	Y+6, r18	; 0x06
    654c:	8e 81       	ldd	r24, Y+6	; 0x06
    654e:	9f 81       	ldd	r25, Y+7	; 0x07
    6550:	82 30       	cpi	r24, 0x02	; 2
    6552:	91 05       	cpc	r25, r1
    6554:	09 f4       	brne	.+2      	; 0x6558 <Timer1_enuInit+0x166>
    6556:	41 c0       	rjmp	.+130    	; 0x65da <Timer1_enuInit+0x1e8>
    6558:	2e 81       	ldd	r18, Y+6	; 0x06
    655a:	3f 81       	ldd	r19, Y+7	; 0x07
    655c:	23 30       	cpi	r18, 0x03	; 3
    655e:	31 05       	cpc	r19, r1
    6560:	54 f4       	brge	.+20     	; 0x6576 <Timer1_enuInit+0x184>
    6562:	8e 81       	ldd	r24, Y+6	; 0x06
    6564:	9f 81       	ldd	r25, Y+7	; 0x07
    6566:	00 97       	sbiw	r24, 0x00	; 0
    6568:	c1 f0       	breq	.+48     	; 0x659a <Timer1_enuInit+0x1a8>
    656a:	2e 81       	ldd	r18, Y+6	; 0x06
    656c:	3f 81       	ldd	r19, Y+7	; 0x07
    656e:	21 30       	cpi	r18, 0x01	; 1
    6570:	31 05       	cpc	r19, r1
    6572:	19 f1       	breq	.+70     	; 0x65ba <Timer1_enuInit+0x1c8>
    6574:	72 c0       	rjmp	.+228    	; 0x665a <Timer1_enuInit+0x268>
    6576:	8e 81       	ldd	r24, Y+6	; 0x06
    6578:	9f 81       	ldd	r25, Y+7	; 0x07
    657a:	84 30       	cpi	r24, 0x04	; 4
    657c:	91 05       	cpc	r25, r1
    657e:	e9 f1       	breq	.+122    	; 0x65fa <Timer1_enuInit+0x208>
    6580:	2e 81       	ldd	r18, Y+6	; 0x06
    6582:	3f 81       	ldd	r19, Y+7	; 0x07
    6584:	24 30       	cpi	r18, 0x04	; 4
    6586:	31 05       	cpc	r19, r1
    6588:	0c f4       	brge	.+2      	; 0x658c <Timer1_enuInit+0x19a>
    658a:	47 c0       	rjmp	.+142    	; 0x661a <Timer1_enuInit+0x228>
    658c:	8e 81       	ldd	r24, Y+6	; 0x06
    658e:	9f 81       	ldd	r25, Y+7	; 0x07
    6590:	85 30       	cpi	r24, 0x05	; 5
    6592:	91 05       	cpc	r25, r1
    6594:	09 f4       	brne	.+2      	; 0x6598 <Timer1_enuInit+0x1a6>
    6596:	51 c0       	rjmp	.+162    	; 0x663a <Timer1_enuInit+0x248>
    6598:	60 c0       	rjmp	.+192    	; 0x665a <Timer1_enuInit+0x268>
	{
	case Disconnect:
		TCCR1A&=~(1<<COM1A0);
    659a:	af e4       	ldi	r26, 0x4F	; 79
    659c:	b0 e0       	ldi	r27, 0x00	; 0
    659e:	ef e4       	ldi	r30, 0x4F	; 79
    65a0:	f0 e0       	ldi	r31, 0x00	; 0
    65a2:	80 81       	ld	r24, Z
    65a4:	8f 7b       	andi	r24, 0xBF	; 191
    65a6:	8c 93       	st	X, r24
		TCCR1A&=~(1<<COM1A1);
    65a8:	af e4       	ldi	r26, 0x4F	; 79
    65aa:	b0 e0       	ldi	r27, 0x00	; 0
    65ac:	ef e4       	ldi	r30, 0x4F	; 79
    65ae:	f0 e0       	ldi	r31, 0x00	; 0
    65b0:	80 81       	ld	r24, Z
    65b2:	8f 77       	andi	r24, 0x7F	; 127
    65b4:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    65b6:	19 82       	std	Y+1, r1	; 0x01
    65b8:	52 c0       	rjmp	.+164    	; 0x665e <Timer1_enuInit+0x26c>
		break;
	case ToggleOnCompare:
		TCCR1A|=(1<<COM1A0);
    65ba:	af e4       	ldi	r26, 0x4F	; 79
    65bc:	b0 e0       	ldi	r27, 0x00	; 0
    65be:	ef e4       	ldi	r30, 0x4F	; 79
    65c0:	f0 e0       	ldi	r31, 0x00	; 0
    65c2:	80 81       	ld	r24, Z
    65c4:	80 64       	ori	r24, 0x40	; 64
    65c6:	8c 93       	st	X, r24
		TCCR1A&=~(1<<COM1A1);
    65c8:	af e4       	ldi	r26, 0x4F	; 79
    65ca:	b0 e0       	ldi	r27, 0x00	; 0
    65cc:	ef e4       	ldi	r30, 0x4F	; 79
    65ce:	f0 e0       	ldi	r31, 0x00	; 0
    65d0:	80 81       	ld	r24, Z
    65d2:	8f 77       	andi	r24, 0x7F	; 127
    65d4:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    65d6:	19 82       	std	Y+1, r1	; 0x01
    65d8:	42 c0       	rjmp	.+132    	; 0x665e <Timer1_enuInit+0x26c>
		break;
	case ClearOnCompare:
		TCCR1A&=~(1<<COM1A0);
    65da:	af e4       	ldi	r26, 0x4F	; 79
    65dc:	b0 e0       	ldi	r27, 0x00	; 0
    65de:	ef e4       	ldi	r30, 0x4F	; 79
    65e0:	f0 e0       	ldi	r31, 0x00	; 0
    65e2:	80 81       	ld	r24, Z
    65e4:	8f 7b       	andi	r24, 0xBF	; 191
    65e6:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1A1);
    65e8:	af e4       	ldi	r26, 0x4F	; 79
    65ea:	b0 e0       	ldi	r27, 0x00	; 0
    65ec:	ef e4       	ldi	r30, 0x4F	; 79
    65ee:	f0 e0       	ldi	r31, 0x00	; 0
    65f0:	80 81       	ld	r24, Z
    65f2:	80 68       	ori	r24, 0x80	; 128
    65f4:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    65f6:	19 82       	std	Y+1, r1	; 0x01
    65f8:	32 c0       	rjmp	.+100    	; 0x665e <Timer1_enuInit+0x26c>
		break;
	case PWM_NonInverted:
		TCCR1A&=~(1<<COM1A0);
    65fa:	af e4       	ldi	r26, 0x4F	; 79
    65fc:	b0 e0       	ldi	r27, 0x00	; 0
    65fe:	ef e4       	ldi	r30, 0x4F	; 79
    6600:	f0 e0       	ldi	r31, 0x00	; 0
    6602:	80 81       	ld	r24, Z
    6604:	8f 7b       	andi	r24, 0xBF	; 191
    6606:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1A1);
    6608:	af e4       	ldi	r26, 0x4F	; 79
    660a:	b0 e0       	ldi	r27, 0x00	; 0
    660c:	ef e4       	ldi	r30, 0x4F	; 79
    660e:	f0 e0       	ldi	r31, 0x00	; 0
    6610:	80 81       	ld	r24, Z
    6612:	80 68       	ori	r24, 0x80	; 128
    6614:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6616:	19 82       	std	Y+1, r1	; 0x01
    6618:	22 c0       	rjmp	.+68     	; 0x665e <Timer1_enuInit+0x26c>
		break;
	case SetOnCompare:
		TCCR1A|=(1<<COM1A0);
    661a:	af e4       	ldi	r26, 0x4F	; 79
    661c:	b0 e0       	ldi	r27, 0x00	; 0
    661e:	ef e4       	ldi	r30, 0x4F	; 79
    6620:	f0 e0       	ldi	r31, 0x00	; 0
    6622:	80 81       	ld	r24, Z
    6624:	80 64       	ori	r24, 0x40	; 64
    6626:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1A1);
    6628:	af e4       	ldi	r26, 0x4F	; 79
    662a:	b0 e0       	ldi	r27, 0x00	; 0
    662c:	ef e4       	ldi	r30, 0x4F	; 79
    662e:	f0 e0       	ldi	r31, 0x00	; 0
    6630:	80 81       	ld	r24, Z
    6632:	80 68       	ori	r24, 0x80	; 128
    6634:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6636:	19 82       	std	Y+1, r1	; 0x01
    6638:	12 c0       	rjmp	.+36     	; 0x665e <Timer1_enuInit+0x26c>
		break;
	case PWM_Inverted:
		TCCR1A|=(1<<COM1A0);
    663a:	af e4       	ldi	r26, 0x4F	; 79
    663c:	b0 e0       	ldi	r27, 0x00	; 0
    663e:	ef e4       	ldi	r30, 0x4F	; 79
    6640:	f0 e0       	ldi	r31, 0x00	; 0
    6642:	80 81       	ld	r24, Z
    6644:	80 64       	ori	r24, 0x40	; 64
    6646:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1A1);
    6648:	af e4       	ldi	r26, 0x4F	; 79
    664a:	b0 e0       	ldi	r27, 0x00	; 0
    664c:	ef e4       	ldi	r30, 0x4F	; 79
    664e:	f0 e0       	ldi	r31, 0x00	; 0
    6650:	80 81       	ld	r24, Z
    6652:	80 68       	ori	r24, 0x80	; 128
    6654:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6656:	19 82       	std	Y+1, r1	; 0x01
    6658:	02 c0       	rjmp	.+4      	; 0x665e <Timer1_enuInit+0x26c>
		break;
	default:
		Local_enuErrorState = ES_OUT_OF_RANGE;
    665a:	83 e0       	ldi	r24, 0x03	; 3
    665c:	89 83       	std	Y+1, r24	; 0x01
		break;
	}

	/*OC1B Action*/

	switch(Copy_strTimer1Config->Timer1_enuOC1B_Action)
    665e:	ea 81       	ldd	r30, Y+2	; 0x02
    6660:	fb 81       	ldd	r31, Y+3	; 0x03
    6662:	82 81       	ldd	r24, Z+2	; 0x02
    6664:	28 2f       	mov	r18, r24
    6666:	30 e0       	ldi	r19, 0x00	; 0
    6668:	3d 83       	std	Y+5, r19	; 0x05
    666a:	2c 83       	std	Y+4, r18	; 0x04
    666c:	8c 81       	ldd	r24, Y+4	; 0x04
    666e:	9d 81       	ldd	r25, Y+5	; 0x05
    6670:	82 30       	cpi	r24, 0x02	; 2
    6672:	91 05       	cpc	r25, r1
    6674:	09 f4       	brne	.+2      	; 0x6678 <Timer1_enuInit+0x286>
    6676:	41 c0       	rjmp	.+130    	; 0x66fa <Timer1_enuInit+0x308>
    6678:	2c 81       	ldd	r18, Y+4	; 0x04
    667a:	3d 81       	ldd	r19, Y+5	; 0x05
    667c:	23 30       	cpi	r18, 0x03	; 3
    667e:	31 05       	cpc	r19, r1
    6680:	54 f4       	brge	.+20     	; 0x6696 <Timer1_enuInit+0x2a4>
    6682:	8c 81       	ldd	r24, Y+4	; 0x04
    6684:	9d 81       	ldd	r25, Y+5	; 0x05
    6686:	00 97       	sbiw	r24, 0x00	; 0
    6688:	c1 f0       	breq	.+48     	; 0x66ba <Timer1_enuInit+0x2c8>
    668a:	2c 81       	ldd	r18, Y+4	; 0x04
    668c:	3d 81       	ldd	r19, Y+5	; 0x05
    668e:	21 30       	cpi	r18, 0x01	; 1
    6690:	31 05       	cpc	r19, r1
    6692:	19 f1       	breq	.+70     	; 0x66da <Timer1_enuInit+0x2e8>
    6694:	72 c0       	rjmp	.+228    	; 0x677a <Timer1_enuInit+0x388>
    6696:	8c 81       	ldd	r24, Y+4	; 0x04
    6698:	9d 81       	ldd	r25, Y+5	; 0x05
    669a:	84 30       	cpi	r24, 0x04	; 4
    669c:	91 05       	cpc	r25, r1
    669e:	e9 f1       	breq	.+122    	; 0x671a <Timer1_enuInit+0x328>
    66a0:	2c 81       	ldd	r18, Y+4	; 0x04
    66a2:	3d 81       	ldd	r19, Y+5	; 0x05
    66a4:	24 30       	cpi	r18, 0x04	; 4
    66a6:	31 05       	cpc	r19, r1
    66a8:	0c f4       	brge	.+2      	; 0x66ac <Timer1_enuInit+0x2ba>
    66aa:	47 c0       	rjmp	.+142    	; 0x673a <Timer1_enuInit+0x348>
    66ac:	8c 81       	ldd	r24, Y+4	; 0x04
    66ae:	9d 81       	ldd	r25, Y+5	; 0x05
    66b0:	85 30       	cpi	r24, 0x05	; 5
    66b2:	91 05       	cpc	r25, r1
    66b4:	09 f4       	brne	.+2      	; 0x66b8 <Timer1_enuInit+0x2c6>
    66b6:	51 c0       	rjmp	.+162    	; 0x675a <Timer1_enuInit+0x368>
    66b8:	60 c0       	rjmp	.+192    	; 0x677a <Timer1_enuInit+0x388>
	{
	case Disconnect:
		TCCR1A&=~(1<<COM1B0);
    66ba:	af e4       	ldi	r26, 0x4F	; 79
    66bc:	b0 e0       	ldi	r27, 0x00	; 0
    66be:	ef e4       	ldi	r30, 0x4F	; 79
    66c0:	f0 e0       	ldi	r31, 0x00	; 0
    66c2:	80 81       	ld	r24, Z
    66c4:	8f 7e       	andi	r24, 0xEF	; 239
    66c6:	8c 93       	st	X, r24
		TCCR1A&=~(1<<COM1B1);
    66c8:	af e4       	ldi	r26, 0x4F	; 79
    66ca:	b0 e0       	ldi	r27, 0x00	; 0
    66cc:	ef e4       	ldi	r30, 0x4F	; 79
    66ce:	f0 e0       	ldi	r31, 0x00	; 0
    66d0:	80 81       	ld	r24, Z
    66d2:	8f 7d       	andi	r24, 0xDF	; 223
    66d4:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    66d6:	19 82       	std	Y+1, r1	; 0x01
    66d8:	52 c0       	rjmp	.+164    	; 0x677e <Timer1_enuInit+0x38c>
		break;
	case ToggleOnCompare:
		TCCR1A|=(1<<COM1B0);
    66da:	af e4       	ldi	r26, 0x4F	; 79
    66dc:	b0 e0       	ldi	r27, 0x00	; 0
    66de:	ef e4       	ldi	r30, 0x4F	; 79
    66e0:	f0 e0       	ldi	r31, 0x00	; 0
    66e2:	80 81       	ld	r24, Z
    66e4:	80 61       	ori	r24, 0x10	; 16
    66e6:	8c 93       	st	X, r24
		TCCR1A&=~(1<<COM1B1);
    66e8:	af e4       	ldi	r26, 0x4F	; 79
    66ea:	b0 e0       	ldi	r27, 0x00	; 0
    66ec:	ef e4       	ldi	r30, 0x4F	; 79
    66ee:	f0 e0       	ldi	r31, 0x00	; 0
    66f0:	80 81       	ld	r24, Z
    66f2:	8f 7d       	andi	r24, 0xDF	; 223
    66f4:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    66f6:	19 82       	std	Y+1, r1	; 0x01
    66f8:	42 c0       	rjmp	.+132    	; 0x677e <Timer1_enuInit+0x38c>
		break;
	case ClearOnCompare:
		TCCR1A&=~(1<<COM1B0);
    66fa:	af e4       	ldi	r26, 0x4F	; 79
    66fc:	b0 e0       	ldi	r27, 0x00	; 0
    66fe:	ef e4       	ldi	r30, 0x4F	; 79
    6700:	f0 e0       	ldi	r31, 0x00	; 0
    6702:	80 81       	ld	r24, Z
    6704:	8f 7e       	andi	r24, 0xEF	; 239
    6706:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1B1);
    6708:	af e4       	ldi	r26, 0x4F	; 79
    670a:	b0 e0       	ldi	r27, 0x00	; 0
    670c:	ef e4       	ldi	r30, 0x4F	; 79
    670e:	f0 e0       	ldi	r31, 0x00	; 0
    6710:	80 81       	ld	r24, Z
    6712:	80 62       	ori	r24, 0x20	; 32
    6714:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6716:	19 82       	std	Y+1, r1	; 0x01
    6718:	32 c0       	rjmp	.+100    	; 0x677e <Timer1_enuInit+0x38c>
		break;
	case PWM_NonInverted:
		TCCR1A&=~(1<<COM1B0);
    671a:	af e4       	ldi	r26, 0x4F	; 79
    671c:	b0 e0       	ldi	r27, 0x00	; 0
    671e:	ef e4       	ldi	r30, 0x4F	; 79
    6720:	f0 e0       	ldi	r31, 0x00	; 0
    6722:	80 81       	ld	r24, Z
    6724:	8f 7e       	andi	r24, 0xEF	; 239
    6726:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1B1);
    6728:	af e4       	ldi	r26, 0x4F	; 79
    672a:	b0 e0       	ldi	r27, 0x00	; 0
    672c:	ef e4       	ldi	r30, 0x4F	; 79
    672e:	f0 e0       	ldi	r31, 0x00	; 0
    6730:	80 81       	ld	r24, Z
    6732:	80 62       	ori	r24, 0x20	; 32
    6734:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6736:	19 82       	std	Y+1, r1	; 0x01
    6738:	22 c0       	rjmp	.+68     	; 0x677e <Timer1_enuInit+0x38c>
		break;
	case SetOnCompare:
		TCCR1A|=(1<<COM1B0);
    673a:	af e4       	ldi	r26, 0x4F	; 79
    673c:	b0 e0       	ldi	r27, 0x00	; 0
    673e:	ef e4       	ldi	r30, 0x4F	; 79
    6740:	f0 e0       	ldi	r31, 0x00	; 0
    6742:	80 81       	ld	r24, Z
    6744:	80 61       	ori	r24, 0x10	; 16
    6746:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1B1);
    6748:	af e4       	ldi	r26, 0x4F	; 79
    674a:	b0 e0       	ldi	r27, 0x00	; 0
    674c:	ef e4       	ldi	r30, 0x4F	; 79
    674e:	f0 e0       	ldi	r31, 0x00	; 0
    6750:	80 81       	ld	r24, Z
    6752:	80 62       	ori	r24, 0x20	; 32
    6754:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6756:	19 82       	std	Y+1, r1	; 0x01
    6758:	12 c0       	rjmp	.+36     	; 0x677e <Timer1_enuInit+0x38c>
		break;
	case PWM_Inverted:
		TCCR1A|=(1<<COM1B0);
    675a:	af e4       	ldi	r26, 0x4F	; 79
    675c:	b0 e0       	ldi	r27, 0x00	; 0
    675e:	ef e4       	ldi	r30, 0x4F	; 79
    6760:	f0 e0       	ldi	r31, 0x00	; 0
    6762:	80 81       	ld	r24, Z
    6764:	80 61       	ori	r24, 0x10	; 16
    6766:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1B1);
    6768:	af e4       	ldi	r26, 0x4F	; 79
    676a:	b0 e0       	ldi	r27, 0x00	; 0
    676c:	ef e4       	ldi	r30, 0x4F	; 79
    676e:	f0 e0       	ldi	r31, 0x00	; 0
    6770:	80 81       	ld	r24, Z
    6772:	80 62       	ori	r24, 0x20	; 32
    6774:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6776:	19 82       	std	Y+1, r1	; 0x01
    6778:	02 c0       	rjmp	.+4      	; 0x677e <Timer1_enuInit+0x38c>
		break;
	default:
		Local_enuErrorState = ES_OUT_OF_RANGE;
    677a:	83 e0       	ldi	r24, 0x03	; 3
    677c:	89 83       	std	Y+1, r24	; 0x01
		break;
	}

	/*Set the Prescaler */

	if((Copy_strTimer1Config->Timer1_enuPrescaler)>=TIMERS_enuNoClockSource && (Copy_strTimer1Config->Timer1_enuPrescaler) <= TIMERS_enuPrescalingBy1024)
    677e:	ea 81       	ldd	r30, Y+2	; 0x02
    6780:	fb 81       	ldd	r31, Y+3	; 0x03
    6782:	83 81       	ldd	r24, Z+3	; 0x03
    6784:	86 30       	cpi	r24, 0x06	; 6
    6786:	88 f4       	brcc	.+34     	; 0x67aa <Timer1_enuInit+0x3b8>
	{
		TCCR1B&=0xf8;
    6788:	ae e4       	ldi	r26, 0x4E	; 78
    678a:	b0 e0       	ldi	r27, 0x00	; 0
    678c:	ee e4       	ldi	r30, 0x4E	; 78
    678e:	f0 e0       	ldi	r31, 0x00	; 0
    6790:	80 81       	ld	r24, Z
    6792:	88 7f       	andi	r24, 0xF8	; 248
    6794:	8c 93       	st	X, r24
		TCCR1B|=(Copy_strTimer1Config->Timer1_enuPrescaler);
    6796:	ae e4       	ldi	r26, 0x4E	; 78
    6798:	b0 e0       	ldi	r27, 0x00	; 0
    679a:	ee e4       	ldi	r30, 0x4E	; 78
    679c:	f0 e0       	ldi	r31, 0x00	; 0
    679e:	90 81       	ld	r25, Z
    67a0:	ea 81       	ldd	r30, Y+2	; 0x02
    67a2:	fb 81       	ldd	r31, Y+3	; 0x03
    67a4:	83 81       	ldd	r24, Z+3	; 0x03
    67a6:	89 2b       	or	r24, r25
    67a8:	8c 93       	st	X, r24
	}

	return Local_enuErrorState;
    67aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    67ac:	29 96       	adiw	r28, 0x09	; 9
    67ae:	0f b6       	in	r0, 0x3f	; 63
    67b0:	f8 94       	cli
    67b2:	de bf       	out	0x3e, r29	; 62
    67b4:	0f be       	out	0x3f, r0	; 63
    67b6:	cd bf       	out	0x3d, r28	; 61
    67b8:	cf 91       	pop	r28
    67ba:	df 91       	pop	r29
    67bc:	08 95       	ret

000067be <Timer1_enuSetMode>:



ES_t Timer1_enuSetMode(TIMERS_Mode_t Copy_enuTimer1Mode)
{
    67be:	df 93       	push	r29
    67c0:	cf 93       	push	r28
    67c2:	00 d0       	rcall	.+0      	; 0x67c4 <Timer1_enuSetMode+0x6>
    67c4:	00 d0       	rcall	.+0      	; 0x67c6 <Timer1_enuSetMode+0x8>
    67c6:	cd b7       	in	r28, 0x3d	; 61
    67c8:	de b7       	in	r29, 0x3e	; 62
    67ca:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    67cc:	81 e0       	ldi	r24, 0x01	; 1
    67ce:	89 83       	std	Y+1, r24	; 0x01

	/*set the mode of timer1*/

	switch(Copy_enuTimer1Mode)
    67d0:	8a 81       	ldd	r24, Y+2	; 0x02
    67d2:	28 2f       	mov	r18, r24
    67d4:	30 e0       	ldi	r19, 0x00	; 0
    67d6:	3c 83       	std	Y+4, r19	; 0x04
    67d8:	2b 83       	std	Y+3, r18	; 0x03
    67da:	8b 81       	ldd	r24, Y+3	; 0x03
    67dc:	9c 81       	ldd	r25, Y+4	; 0x04
    67de:	85 30       	cpi	r24, 0x05	; 5
    67e0:	91 05       	cpc	r25, r1
    67e2:	51 f1       	breq	.+84     	; 0x6838 <Timer1_enuSetMode+0x7a>
    67e4:	2b 81       	ldd	r18, Y+3	; 0x03
    67e6:	3c 81       	ldd	r19, Y+4	; 0x04
    67e8:	26 30       	cpi	r18, 0x06	; 6
    67ea:	31 05       	cpc	r19, r1
    67ec:	09 f4       	brne	.+2      	; 0x67f0 <Timer1_enuSetMode+0x32>
    67ee:	42 c0       	rjmp	.+132    	; 0x6874 <Timer1_enuSetMode+0xb6>
    67f0:	8b 81       	ldd	r24, Y+3	; 0x03
    67f2:	9c 81       	ldd	r25, Y+4	; 0x04
    67f4:	84 30       	cpi	r24, 0x04	; 4
    67f6:	91 05       	cpc	r25, r1
    67f8:	09 f0       	breq	.+2      	; 0x67fc <Timer1_enuSetMode+0x3e>
    67fa:	5a c0       	rjmp	.+180    	; 0x68b0 <Timer1_enuSetMode+0xf2>
	{
	case Timer1_enuOverflow:
		TCCR1A&=~(1<<WGM10);
    67fc:	af e4       	ldi	r26, 0x4F	; 79
    67fe:	b0 e0       	ldi	r27, 0x00	; 0
    6800:	ef e4       	ldi	r30, 0x4F	; 79
    6802:	f0 e0       	ldi	r31, 0x00	; 0
    6804:	80 81       	ld	r24, Z
    6806:	8e 7f       	andi	r24, 0xFE	; 254
    6808:	8c 93       	st	X, r24
		TCCR1A&=~(1<<WGM11);
    680a:	af e4       	ldi	r26, 0x4F	; 79
    680c:	b0 e0       	ldi	r27, 0x00	; 0
    680e:	ef e4       	ldi	r30, 0x4F	; 79
    6810:	f0 e0       	ldi	r31, 0x00	; 0
    6812:	80 81       	ld	r24, Z
    6814:	8d 7f       	andi	r24, 0xFD	; 253
    6816:	8c 93       	st	X, r24
		TCCR1B&=~(1<<WGM12);
    6818:	ae e4       	ldi	r26, 0x4E	; 78
    681a:	b0 e0       	ldi	r27, 0x00	; 0
    681c:	ee e4       	ldi	r30, 0x4E	; 78
    681e:	f0 e0       	ldi	r31, 0x00	; 0
    6820:	80 81       	ld	r24, Z
    6822:	87 7f       	andi	r24, 0xF7	; 247
    6824:	8c 93       	st	X, r24
		TCCR1B&=~(1<<WGM13);
    6826:	ae e4       	ldi	r26, 0x4E	; 78
    6828:	b0 e0       	ldi	r27, 0x00	; 0
    682a:	ee e4       	ldi	r30, 0x4E	; 78
    682c:	f0 e0       	ldi	r31, 0x00	; 0
    682e:	80 81       	ld	r24, Z
    6830:	8f 7e       	andi	r24, 0xEF	; 239
    6832:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6834:	19 82       	std	Y+1, r1	; 0x01
    6836:	3e c0       	rjmp	.+124    	; 0x68b4 <Timer1_enuSetMode+0xf6>
		break;
	case Timer1_enuCTC:
		TCCR1A&=~(1<<WGM10);
    6838:	af e4       	ldi	r26, 0x4F	; 79
    683a:	b0 e0       	ldi	r27, 0x00	; 0
    683c:	ef e4       	ldi	r30, 0x4F	; 79
    683e:	f0 e0       	ldi	r31, 0x00	; 0
    6840:	80 81       	ld	r24, Z
    6842:	8e 7f       	andi	r24, 0xFE	; 254
    6844:	8c 93       	st	X, r24
		TCCR1A&=~(1<<WGM11);
    6846:	af e4       	ldi	r26, 0x4F	; 79
    6848:	b0 e0       	ldi	r27, 0x00	; 0
    684a:	ef e4       	ldi	r30, 0x4F	; 79
    684c:	f0 e0       	ldi	r31, 0x00	; 0
    684e:	80 81       	ld	r24, Z
    6850:	8d 7f       	andi	r24, 0xFD	; 253
    6852:	8c 93       	st	X, r24
		TCCR1B|=(1<<WGM12);
    6854:	ae e4       	ldi	r26, 0x4E	; 78
    6856:	b0 e0       	ldi	r27, 0x00	; 0
    6858:	ee e4       	ldi	r30, 0x4E	; 78
    685a:	f0 e0       	ldi	r31, 0x00	; 0
    685c:	80 81       	ld	r24, Z
    685e:	88 60       	ori	r24, 0x08	; 8
    6860:	8c 93       	st	X, r24
		TCCR1B&=~(1<<WGM13);
    6862:	ae e4       	ldi	r26, 0x4E	; 78
    6864:	b0 e0       	ldi	r27, 0x00	; 0
    6866:	ee e4       	ldi	r30, 0x4E	; 78
    6868:	f0 e0       	ldi	r31, 0x00	; 0
    686a:	80 81       	ld	r24, Z
    686c:	8f 7e       	andi	r24, 0xEF	; 239
    686e:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6870:	19 82       	std	Y+1, r1	; 0x01
    6872:	20 c0       	rjmp	.+64     	; 0x68b4 <Timer1_enuSetMode+0xf6>
		break;
	case Timer1_enuFastPWM_TopICR1:
		TCCR1A&=~(1<<WGM10);
    6874:	af e4       	ldi	r26, 0x4F	; 79
    6876:	b0 e0       	ldi	r27, 0x00	; 0
    6878:	ef e4       	ldi	r30, 0x4F	; 79
    687a:	f0 e0       	ldi	r31, 0x00	; 0
    687c:	80 81       	ld	r24, Z
    687e:	8e 7f       	andi	r24, 0xFE	; 254
    6880:	8c 93       	st	X, r24
		TCCR1A|=(1<<WGM11);
    6882:	af e4       	ldi	r26, 0x4F	; 79
    6884:	b0 e0       	ldi	r27, 0x00	; 0
    6886:	ef e4       	ldi	r30, 0x4F	; 79
    6888:	f0 e0       	ldi	r31, 0x00	; 0
    688a:	80 81       	ld	r24, Z
    688c:	82 60       	ori	r24, 0x02	; 2
    688e:	8c 93       	st	X, r24
		TCCR1B|=(1<<WGM12);
    6890:	ae e4       	ldi	r26, 0x4E	; 78
    6892:	b0 e0       	ldi	r27, 0x00	; 0
    6894:	ee e4       	ldi	r30, 0x4E	; 78
    6896:	f0 e0       	ldi	r31, 0x00	; 0
    6898:	80 81       	ld	r24, Z
    689a:	88 60       	ori	r24, 0x08	; 8
    689c:	8c 93       	st	X, r24
		TCCR1B|=(1<<WGM13);
    689e:	ae e4       	ldi	r26, 0x4E	; 78
    68a0:	b0 e0       	ldi	r27, 0x00	; 0
    68a2:	ee e4       	ldi	r30, 0x4E	; 78
    68a4:	f0 e0       	ldi	r31, 0x00	; 0
    68a6:	80 81       	ld	r24, Z
    68a8:	80 61       	ori	r24, 0x10	; 16
    68aa:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    68ac:	19 82       	std	Y+1, r1	; 0x01
    68ae:	02 c0       	rjmp	.+4      	; 0x68b4 <Timer1_enuSetMode+0xf6>
		break;
	default:
		Local_enuErrorState = ES_OUT_OF_RANGE;
    68b0:	83 e0       	ldi	r24, 0x03	; 3
    68b2:	89 83       	std	Y+1, r24	; 0x01
		break;
	}

	return Local_enuErrorState;
    68b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    68b6:	0f 90       	pop	r0
    68b8:	0f 90       	pop	r0
    68ba:	0f 90       	pop	r0
    68bc:	0f 90       	pop	r0
    68be:	cf 91       	pop	r28
    68c0:	df 91       	pop	r29
    68c2:	08 95       	ret

000068c4 <Timer1_enuSetPrescaler>:

ES_t Timer1_enuSetPrescaler(TIMERS_prescaler_t Copy_enuTimer1Prescaler)
{
    68c4:	df 93       	push	r29
    68c6:	cf 93       	push	r28
    68c8:	00 d0       	rcall	.+0      	; 0x68ca <Timer1_enuSetPrescaler+0x6>
    68ca:	cd b7       	in	r28, 0x3d	; 61
    68cc:	de b7       	in	r29, 0x3e	; 62
    68ce:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    68d0:	81 e0       	ldi	r24, 0x01	; 1
    68d2:	89 83       	std	Y+1, r24	; 0x01

	/*Set the Prescaler */

	if(Copy_enuTimer1Prescaler>=TIMERS_enuNoClockSource && Copy_enuTimer1Prescaler <= TIMERS_enuPrescalingBy1024)
    68d4:	8a 81       	ldd	r24, Y+2	; 0x02
    68d6:	86 30       	cpi	r24, 0x06	; 6
    68d8:	78 f4       	brcc	.+30     	; 0x68f8 <Timer1_enuSetPrescaler+0x34>
	{
		TCCR1B&=0xf8;
    68da:	ae e4       	ldi	r26, 0x4E	; 78
    68dc:	b0 e0       	ldi	r27, 0x00	; 0
    68de:	ee e4       	ldi	r30, 0x4E	; 78
    68e0:	f0 e0       	ldi	r31, 0x00	; 0
    68e2:	80 81       	ld	r24, Z
    68e4:	88 7f       	andi	r24, 0xF8	; 248
    68e6:	8c 93       	st	X, r24
		TCCR1B|=Copy_enuTimer1Prescaler;
    68e8:	ae e4       	ldi	r26, 0x4E	; 78
    68ea:	b0 e0       	ldi	r27, 0x00	; 0
    68ec:	ee e4       	ldi	r30, 0x4E	; 78
    68ee:	f0 e0       	ldi	r31, 0x00	; 0
    68f0:	90 81       	ld	r25, Z
    68f2:	8a 81       	ldd	r24, Y+2	; 0x02
    68f4:	89 2b       	or	r24, r25
    68f6:	8c 93       	st	X, r24
	}

	return Local_enuErrorState;
    68f8:	89 81       	ldd	r24, Y+1	; 0x01
}
    68fa:	0f 90       	pop	r0
    68fc:	0f 90       	pop	r0
    68fe:	cf 91       	pop	r28
    6900:	df 91       	pop	r29
    6902:	08 95       	ret

00006904 <Timer1_enuSetCounter>:


ES_t Timer1_enuSetCounter(u16 Copy_u16Counter)
{
    6904:	df 93       	push	r29
    6906:	cf 93       	push	r28
    6908:	00 d0       	rcall	.+0      	; 0x690a <Timer1_enuSetCounter+0x6>
    690a:	0f 92       	push	r0
    690c:	cd b7       	in	r28, 0x3d	; 61
    690e:	de b7       	in	r29, 0x3e	; 62
    6910:	9b 83       	std	Y+3, r25	; 0x03
    6912:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    6914:	81 e0       	ldi	r24, 0x01	; 1
    6916:	89 83       	std	Y+1, r24	; 0x01

	TCNT1 = Copy_u16Counter;
    6918:	ec e4       	ldi	r30, 0x4C	; 76
    691a:	f0 e0       	ldi	r31, 0x00	; 0
    691c:	8a 81       	ldd	r24, Y+2	; 0x02
    691e:	9b 81       	ldd	r25, Y+3	; 0x03
    6920:	91 83       	std	Z+1, r25	; 0x01
    6922:	80 83       	st	Z, r24
	Local_enuErrorState = ES_OK;
    6924:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    6926:	89 81       	ldd	r24, Y+1	; 0x01
}
    6928:	0f 90       	pop	r0
    692a:	0f 90       	pop	r0
    692c:	0f 90       	pop	r0
    692e:	cf 91       	pop	r28
    6930:	df 91       	pop	r29
    6932:	08 95       	ret

00006934 <Timer1_enuGetCounter>:

ES_t Timer1_enuGetCounter(u16 *Copy_u16Counter)
{
    6934:	df 93       	push	r29
    6936:	cf 93       	push	r28
    6938:	00 d0       	rcall	.+0      	; 0x693a <Timer1_enuGetCounter+0x6>
    693a:	0f 92       	push	r0
    693c:	cd b7       	in	r28, 0x3d	; 61
    693e:	de b7       	in	r29, 0x3e	; 62
    6940:	9b 83       	std	Y+3, r25	; 0x03
    6942:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    6944:	81 e0       	ldi	r24, 0x01	; 1
    6946:	89 83       	std	Y+1, r24	; 0x01

	*Copy_u16Counter = TCNT1 ;
    6948:	ec e4       	ldi	r30, 0x4C	; 76
    694a:	f0 e0       	ldi	r31, 0x00	; 0
    694c:	80 81       	ld	r24, Z
    694e:	91 81       	ldd	r25, Z+1	; 0x01
    6950:	ea 81       	ldd	r30, Y+2	; 0x02
    6952:	fb 81       	ldd	r31, Y+3	; 0x03
    6954:	91 83       	std	Z+1, r25	; 0x01
    6956:	80 83       	st	Z, r24
	Local_enuErrorState = ES_OK;
    6958:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    695a:	89 81       	ldd	r24, Y+1	; 0x01
}
    695c:	0f 90       	pop	r0
    695e:	0f 90       	pop	r0
    6960:	0f 90       	pop	r0
    6962:	cf 91       	pop	r28
    6964:	df 91       	pop	r29
    6966:	08 95       	ret

00006968 <Timer1_enuSetCmpareMatchRegA>:


ES_t Timer1_enuSetCmpareMatchRegA(u16 Copy_u16CompareMatchValue)
{
    6968:	df 93       	push	r29
    696a:	cf 93       	push	r28
    696c:	00 d0       	rcall	.+0      	; 0x696e <Timer1_enuSetCmpareMatchRegA+0x6>
    696e:	0f 92       	push	r0
    6970:	cd b7       	in	r28, 0x3d	; 61
    6972:	de b7       	in	r29, 0x3e	; 62
    6974:	9b 83       	std	Y+3, r25	; 0x03
    6976:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    6978:	81 e0       	ldi	r24, 0x01	; 1
    697a:	89 83       	std	Y+1, r24	; 0x01

	OCR1A = Copy_u16CompareMatchValue;
    697c:	ea e4       	ldi	r30, 0x4A	; 74
    697e:	f0 e0       	ldi	r31, 0x00	; 0
    6980:	8a 81       	ldd	r24, Y+2	; 0x02
    6982:	9b 81       	ldd	r25, Y+3	; 0x03
    6984:	91 83       	std	Z+1, r25	; 0x01
    6986:	80 83       	st	Z, r24
	Local_enuErrorState = ES_OK;
    6988:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    698a:	89 81       	ldd	r24, Y+1	; 0x01
}
    698c:	0f 90       	pop	r0
    698e:	0f 90       	pop	r0
    6990:	0f 90       	pop	r0
    6992:	cf 91       	pop	r28
    6994:	df 91       	pop	r29
    6996:	08 95       	ret

00006998 <Timer1_enuSetCmpareMatchRegB>:

ES_t Timer1_enuSetCmpareMatchRegB(u16 Copy_u16CompareMatchValue)
{
    6998:	df 93       	push	r29
    699a:	cf 93       	push	r28
    699c:	00 d0       	rcall	.+0      	; 0x699e <Timer1_enuSetCmpareMatchRegB+0x6>
    699e:	0f 92       	push	r0
    69a0:	cd b7       	in	r28, 0x3d	; 61
    69a2:	de b7       	in	r29, 0x3e	; 62
    69a4:	9b 83       	std	Y+3, r25	; 0x03
    69a6:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    69a8:	81 e0       	ldi	r24, 0x01	; 1
    69aa:	89 83       	std	Y+1, r24	; 0x01

	OCR1B = Copy_u16CompareMatchValue;
    69ac:	e8 e4       	ldi	r30, 0x48	; 72
    69ae:	f0 e0       	ldi	r31, 0x00	; 0
    69b0:	8a 81       	ldd	r24, Y+2	; 0x02
    69b2:	9b 81       	ldd	r25, Y+3	; 0x03
    69b4:	91 83       	std	Z+1, r25	; 0x01
    69b6:	80 83       	st	Z, r24
	Local_enuErrorState = ES_OK;
    69b8:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    69ba:	89 81       	ldd	r24, Y+1	; 0x01
}
    69bc:	0f 90       	pop	r0
    69be:	0f 90       	pop	r0
    69c0:	0f 90       	pop	r0
    69c2:	cf 91       	pop	r28
    69c4:	df 91       	pop	r29
    69c6:	08 95       	ret

000069c8 <Timer1_enuSetInputCapReg>:


ES_t Timer1_enuSetInputCapReg(u16 Copy_u16InputCapRegValue)
{
    69c8:	df 93       	push	r29
    69ca:	cf 93       	push	r28
    69cc:	00 d0       	rcall	.+0      	; 0x69ce <Timer1_enuSetInputCapReg+0x6>
    69ce:	0f 92       	push	r0
    69d0:	cd b7       	in	r28, 0x3d	; 61
    69d2:	de b7       	in	r29, 0x3e	; 62
    69d4:	9b 83       	std	Y+3, r25	; 0x03
    69d6:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    69d8:	81 e0       	ldi	r24, 0x01	; 1
    69da:	89 83       	std	Y+1, r24	; 0x01

	ICR1  = Copy_u16InputCapRegValue;
    69dc:	e6 e4       	ldi	r30, 0x46	; 70
    69de:	f0 e0       	ldi	r31, 0x00	; 0
    69e0:	8a 81       	ldd	r24, Y+2	; 0x02
    69e2:	9b 81       	ldd	r25, Y+3	; 0x03
    69e4:	91 83       	std	Z+1, r25	; 0x01
    69e6:	80 83       	st	Z, r24
	Local_enuErrorState = ES_OK;
    69e8:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    69ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    69ec:	0f 90       	pop	r0
    69ee:	0f 90       	pop	r0
    69f0:	0f 90       	pop	r0
    69f2:	cf 91       	pop	r28
    69f4:	df 91       	pop	r29
    69f6:	08 95       	ret

000069f8 <Timer1_enuSet_OC1A_Action>:

ES_t Timer1_enuSet_OC1A_Action(TIMERS_OutputPinAction_t Copy_enuTime1OC1AAct)
{
    69f8:	df 93       	push	r29
    69fa:	cf 93       	push	r28
    69fc:	00 d0       	rcall	.+0      	; 0x69fe <Timer1_enuSet_OC1A_Action+0x6>
    69fe:	00 d0       	rcall	.+0      	; 0x6a00 <Timer1_enuSet_OC1A_Action+0x8>
    6a00:	cd b7       	in	r28, 0x3d	; 61
    6a02:	de b7       	in	r29, 0x3e	; 62
    6a04:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    6a06:	81 e0       	ldi	r24, 0x01	; 1
    6a08:	89 83       	std	Y+1, r24	; 0x01

	/*OC1A Action*/

	switch(Copy_enuTime1OC1AAct)
    6a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    6a0c:	28 2f       	mov	r18, r24
    6a0e:	30 e0       	ldi	r19, 0x00	; 0
    6a10:	3c 83       	std	Y+4, r19	; 0x04
    6a12:	2b 83       	std	Y+3, r18	; 0x03
    6a14:	8b 81       	ldd	r24, Y+3	; 0x03
    6a16:	9c 81       	ldd	r25, Y+4	; 0x04
    6a18:	82 30       	cpi	r24, 0x02	; 2
    6a1a:	91 05       	cpc	r25, r1
    6a1c:	09 f4       	brne	.+2      	; 0x6a20 <Timer1_enuSet_OC1A_Action+0x28>
    6a1e:	41 c0       	rjmp	.+130    	; 0x6aa2 <Timer1_enuSet_OC1A_Action+0xaa>
    6a20:	2b 81       	ldd	r18, Y+3	; 0x03
    6a22:	3c 81       	ldd	r19, Y+4	; 0x04
    6a24:	23 30       	cpi	r18, 0x03	; 3
    6a26:	31 05       	cpc	r19, r1
    6a28:	54 f4       	brge	.+20     	; 0x6a3e <Timer1_enuSet_OC1A_Action+0x46>
    6a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    6a2e:	00 97       	sbiw	r24, 0x00	; 0
    6a30:	c1 f0       	breq	.+48     	; 0x6a62 <Timer1_enuSet_OC1A_Action+0x6a>
    6a32:	2b 81       	ldd	r18, Y+3	; 0x03
    6a34:	3c 81       	ldd	r19, Y+4	; 0x04
    6a36:	21 30       	cpi	r18, 0x01	; 1
    6a38:	31 05       	cpc	r19, r1
    6a3a:	19 f1       	breq	.+70     	; 0x6a82 <Timer1_enuSet_OC1A_Action+0x8a>
    6a3c:	72 c0       	rjmp	.+228    	; 0x6b22 <Timer1_enuSet_OC1A_Action+0x12a>
    6a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a40:	9c 81       	ldd	r25, Y+4	; 0x04
    6a42:	84 30       	cpi	r24, 0x04	; 4
    6a44:	91 05       	cpc	r25, r1
    6a46:	e9 f1       	breq	.+122    	; 0x6ac2 <Timer1_enuSet_OC1A_Action+0xca>
    6a48:	2b 81       	ldd	r18, Y+3	; 0x03
    6a4a:	3c 81       	ldd	r19, Y+4	; 0x04
    6a4c:	24 30       	cpi	r18, 0x04	; 4
    6a4e:	31 05       	cpc	r19, r1
    6a50:	0c f4       	brge	.+2      	; 0x6a54 <Timer1_enuSet_OC1A_Action+0x5c>
    6a52:	47 c0       	rjmp	.+142    	; 0x6ae2 <Timer1_enuSet_OC1A_Action+0xea>
    6a54:	8b 81       	ldd	r24, Y+3	; 0x03
    6a56:	9c 81       	ldd	r25, Y+4	; 0x04
    6a58:	85 30       	cpi	r24, 0x05	; 5
    6a5a:	91 05       	cpc	r25, r1
    6a5c:	09 f4       	brne	.+2      	; 0x6a60 <Timer1_enuSet_OC1A_Action+0x68>
    6a5e:	51 c0       	rjmp	.+162    	; 0x6b02 <Timer1_enuSet_OC1A_Action+0x10a>
    6a60:	60 c0       	rjmp	.+192    	; 0x6b22 <Timer1_enuSet_OC1A_Action+0x12a>
	{
	case Disconnect:
		TCCR1A&=~(1<<COM1A0);
    6a62:	af e4       	ldi	r26, 0x4F	; 79
    6a64:	b0 e0       	ldi	r27, 0x00	; 0
    6a66:	ef e4       	ldi	r30, 0x4F	; 79
    6a68:	f0 e0       	ldi	r31, 0x00	; 0
    6a6a:	80 81       	ld	r24, Z
    6a6c:	8f 7b       	andi	r24, 0xBF	; 191
    6a6e:	8c 93       	st	X, r24
		TCCR1A&=~(1<<COM1A1);
    6a70:	af e4       	ldi	r26, 0x4F	; 79
    6a72:	b0 e0       	ldi	r27, 0x00	; 0
    6a74:	ef e4       	ldi	r30, 0x4F	; 79
    6a76:	f0 e0       	ldi	r31, 0x00	; 0
    6a78:	80 81       	ld	r24, Z
    6a7a:	8f 77       	andi	r24, 0x7F	; 127
    6a7c:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6a7e:	19 82       	std	Y+1, r1	; 0x01
    6a80:	52 c0       	rjmp	.+164    	; 0x6b26 <Timer1_enuSet_OC1A_Action+0x12e>
		break;
	case ToggleOnCompare:
		TCCR1A|=(1<<COM1A0);
    6a82:	af e4       	ldi	r26, 0x4F	; 79
    6a84:	b0 e0       	ldi	r27, 0x00	; 0
    6a86:	ef e4       	ldi	r30, 0x4F	; 79
    6a88:	f0 e0       	ldi	r31, 0x00	; 0
    6a8a:	80 81       	ld	r24, Z
    6a8c:	80 64       	ori	r24, 0x40	; 64
    6a8e:	8c 93       	st	X, r24
		TCCR1A&=~(1<<COM1A1);
    6a90:	af e4       	ldi	r26, 0x4F	; 79
    6a92:	b0 e0       	ldi	r27, 0x00	; 0
    6a94:	ef e4       	ldi	r30, 0x4F	; 79
    6a96:	f0 e0       	ldi	r31, 0x00	; 0
    6a98:	80 81       	ld	r24, Z
    6a9a:	8f 77       	andi	r24, 0x7F	; 127
    6a9c:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6a9e:	19 82       	std	Y+1, r1	; 0x01
    6aa0:	42 c0       	rjmp	.+132    	; 0x6b26 <Timer1_enuSet_OC1A_Action+0x12e>
		break;
	case ClearOnCompare:
		TCCR1A&=~(1<<COM1A0);
    6aa2:	af e4       	ldi	r26, 0x4F	; 79
    6aa4:	b0 e0       	ldi	r27, 0x00	; 0
    6aa6:	ef e4       	ldi	r30, 0x4F	; 79
    6aa8:	f0 e0       	ldi	r31, 0x00	; 0
    6aaa:	80 81       	ld	r24, Z
    6aac:	8f 7b       	andi	r24, 0xBF	; 191
    6aae:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1A1);
    6ab0:	af e4       	ldi	r26, 0x4F	; 79
    6ab2:	b0 e0       	ldi	r27, 0x00	; 0
    6ab4:	ef e4       	ldi	r30, 0x4F	; 79
    6ab6:	f0 e0       	ldi	r31, 0x00	; 0
    6ab8:	80 81       	ld	r24, Z
    6aba:	80 68       	ori	r24, 0x80	; 128
    6abc:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6abe:	19 82       	std	Y+1, r1	; 0x01
    6ac0:	32 c0       	rjmp	.+100    	; 0x6b26 <Timer1_enuSet_OC1A_Action+0x12e>
		break;
	case PWM_NonInverted:
		TCCR1A&=~(1<<COM1A0);
    6ac2:	af e4       	ldi	r26, 0x4F	; 79
    6ac4:	b0 e0       	ldi	r27, 0x00	; 0
    6ac6:	ef e4       	ldi	r30, 0x4F	; 79
    6ac8:	f0 e0       	ldi	r31, 0x00	; 0
    6aca:	80 81       	ld	r24, Z
    6acc:	8f 7b       	andi	r24, 0xBF	; 191
    6ace:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1A1);
    6ad0:	af e4       	ldi	r26, 0x4F	; 79
    6ad2:	b0 e0       	ldi	r27, 0x00	; 0
    6ad4:	ef e4       	ldi	r30, 0x4F	; 79
    6ad6:	f0 e0       	ldi	r31, 0x00	; 0
    6ad8:	80 81       	ld	r24, Z
    6ada:	80 68       	ori	r24, 0x80	; 128
    6adc:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6ade:	19 82       	std	Y+1, r1	; 0x01
    6ae0:	22 c0       	rjmp	.+68     	; 0x6b26 <Timer1_enuSet_OC1A_Action+0x12e>
		break;
	case SetOnCompare:
		TCCR1A|=(1<<COM1A0);
    6ae2:	af e4       	ldi	r26, 0x4F	; 79
    6ae4:	b0 e0       	ldi	r27, 0x00	; 0
    6ae6:	ef e4       	ldi	r30, 0x4F	; 79
    6ae8:	f0 e0       	ldi	r31, 0x00	; 0
    6aea:	80 81       	ld	r24, Z
    6aec:	80 64       	ori	r24, 0x40	; 64
    6aee:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1A1);
    6af0:	af e4       	ldi	r26, 0x4F	; 79
    6af2:	b0 e0       	ldi	r27, 0x00	; 0
    6af4:	ef e4       	ldi	r30, 0x4F	; 79
    6af6:	f0 e0       	ldi	r31, 0x00	; 0
    6af8:	80 81       	ld	r24, Z
    6afa:	80 68       	ori	r24, 0x80	; 128
    6afc:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6afe:	19 82       	std	Y+1, r1	; 0x01
    6b00:	12 c0       	rjmp	.+36     	; 0x6b26 <Timer1_enuSet_OC1A_Action+0x12e>
		break;
	case PWM_Inverted:
		TCCR1A|=(1<<COM1A0);
    6b02:	af e4       	ldi	r26, 0x4F	; 79
    6b04:	b0 e0       	ldi	r27, 0x00	; 0
    6b06:	ef e4       	ldi	r30, 0x4F	; 79
    6b08:	f0 e0       	ldi	r31, 0x00	; 0
    6b0a:	80 81       	ld	r24, Z
    6b0c:	80 64       	ori	r24, 0x40	; 64
    6b0e:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1A1);
    6b10:	af e4       	ldi	r26, 0x4F	; 79
    6b12:	b0 e0       	ldi	r27, 0x00	; 0
    6b14:	ef e4       	ldi	r30, 0x4F	; 79
    6b16:	f0 e0       	ldi	r31, 0x00	; 0
    6b18:	80 81       	ld	r24, Z
    6b1a:	80 68       	ori	r24, 0x80	; 128
    6b1c:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6b1e:	19 82       	std	Y+1, r1	; 0x01
    6b20:	02 c0       	rjmp	.+4      	; 0x6b26 <Timer1_enuSet_OC1A_Action+0x12e>
		break;
	default:
		Local_enuErrorState = ES_OUT_OF_RANGE;
    6b22:	83 e0       	ldi	r24, 0x03	; 3
    6b24:	89 83       	std	Y+1, r24	; 0x01
		break;
	}


	return Local_enuErrorState;
    6b26:	89 81       	ldd	r24, Y+1	; 0x01
}
    6b28:	0f 90       	pop	r0
    6b2a:	0f 90       	pop	r0
    6b2c:	0f 90       	pop	r0
    6b2e:	0f 90       	pop	r0
    6b30:	cf 91       	pop	r28
    6b32:	df 91       	pop	r29
    6b34:	08 95       	ret

00006b36 <Timer1_enuSet_OC1B_Action>:


ES_t Timer1_enuSet_OC1B_Action(TIMERS_OutputPinAction_t Copy_enuTime1OC1BAct)
{
    6b36:	df 93       	push	r29
    6b38:	cf 93       	push	r28
    6b3a:	00 d0       	rcall	.+0      	; 0x6b3c <Timer1_enuSet_OC1B_Action+0x6>
    6b3c:	00 d0       	rcall	.+0      	; 0x6b3e <Timer1_enuSet_OC1B_Action+0x8>
    6b3e:	cd b7       	in	r28, 0x3d	; 61
    6b40:	de b7       	in	r29, 0x3e	; 62
    6b42:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    6b44:	81 e0       	ldi	r24, 0x01	; 1
    6b46:	89 83       	std	Y+1, r24	; 0x01

	/*OC1B Action*/

	switch(Copy_enuTime1OC1BAct)
    6b48:	8a 81       	ldd	r24, Y+2	; 0x02
    6b4a:	28 2f       	mov	r18, r24
    6b4c:	30 e0       	ldi	r19, 0x00	; 0
    6b4e:	3c 83       	std	Y+4, r19	; 0x04
    6b50:	2b 83       	std	Y+3, r18	; 0x03
    6b52:	8b 81       	ldd	r24, Y+3	; 0x03
    6b54:	9c 81       	ldd	r25, Y+4	; 0x04
    6b56:	82 30       	cpi	r24, 0x02	; 2
    6b58:	91 05       	cpc	r25, r1
    6b5a:	09 f4       	brne	.+2      	; 0x6b5e <Timer1_enuSet_OC1B_Action+0x28>
    6b5c:	41 c0       	rjmp	.+130    	; 0x6be0 <Timer1_enuSet_OC1B_Action+0xaa>
    6b5e:	2b 81       	ldd	r18, Y+3	; 0x03
    6b60:	3c 81       	ldd	r19, Y+4	; 0x04
    6b62:	23 30       	cpi	r18, 0x03	; 3
    6b64:	31 05       	cpc	r19, r1
    6b66:	54 f4       	brge	.+20     	; 0x6b7c <Timer1_enuSet_OC1B_Action+0x46>
    6b68:	8b 81       	ldd	r24, Y+3	; 0x03
    6b6a:	9c 81       	ldd	r25, Y+4	; 0x04
    6b6c:	00 97       	sbiw	r24, 0x00	; 0
    6b6e:	c1 f0       	breq	.+48     	; 0x6ba0 <Timer1_enuSet_OC1B_Action+0x6a>
    6b70:	2b 81       	ldd	r18, Y+3	; 0x03
    6b72:	3c 81       	ldd	r19, Y+4	; 0x04
    6b74:	21 30       	cpi	r18, 0x01	; 1
    6b76:	31 05       	cpc	r19, r1
    6b78:	19 f1       	breq	.+70     	; 0x6bc0 <Timer1_enuSet_OC1B_Action+0x8a>
    6b7a:	72 c0       	rjmp	.+228    	; 0x6c60 <Timer1_enuSet_OC1B_Action+0x12a>
    6b7c:	8b 81       	ldd	r24, Y+3	; 0x03
    6b7e:	9c 81       	ldd	r25, Y+4	; 0x04
    6b80:	84 30       	cpi	r24, 0x04	; 4
    6b82:	91 05       	cpc	r25, r1
    6b84:	e9 f1       	breq	.+122    	; 0x6c00 <Timer1_enuSet_OC1B_Action+0xca>
    6b86:	2b 81       	ldd	r18, Y+3	; 0x03
    6b88:	3c 81       	ldd	r19, Y+4	; 0x04
    6b8a:	24 30       	cpi	r18, 0x04	; 4
    6b8c:	31 05       	cpc	r19, r1
    6b8e:	0c f4       	brge	.+2      	; 0x6b92 <Timer1_enuSet_OC1B_Action+0x5c>
    6b90:	47 c0       	rjmp	.+142    	; 0x6c20 <Timer1_enuSet_OC1B_Action+0xea>
    6b92:	8b 81       	ldd	r24, Y+3	; 0x03
    6b94:	9c 81       	ldd	r25, Y+4	; 0x04
    6b96:	85 30       	cpi	r24, 0x05	; 5
    6b98:	91 05       	cpc	r25, r1
    6b9a:	09 f4       	brne	.+2      	; 0x6b9e <Timer1_enuSet_OC1B_Action+0x68>
    6b9c:	51 c0       	rjmp	.+162    	; 0x6c40 <Timer1_enuSet_OC1B_Action+0x10a>
    6b9e:	60 c0       	rjmp	.+192    	; 0x6c60 <Timer1_enuSet_OC1B_Action+0x12a>
	{
	case Disconnect:
		TCCR1A&=~(1<<COM1B0);
    6ba0:	af e4       	ldi	r26, 0x4F	; 79
    6ba2:	b0 e0       	ldi	r27, 0x00	; 0
    6ba4:	ef e4       	ldi	r30, 0x4F	; 79
    6ba6:	f0 e0       	ldi	r31, 0x00	; 0
    6ba8:	80 81       	ld	r24, Z
    6baa:	8f 7e       	andi	r24, 0xEF	; 239
    6bac:	8c 93       	st	X, r24
		TCCR1A&=~(1<<COM1B1);
    6bae:	af e4       	ldi	r26, 0x4F	; 79
    6bb0:	b0 e0       	ldi	r27, 0x00	; 0
    6bb2:	ef e4       	ldi	r30, 0x4F	; 79
    6bb4:	f0 e0       	ldi	r31, 0x00	; 0
    6bb6:	80 81       	ld	r24, Z
    6bb8:	8f 7d       	andi	r24, 0xDF	; 223
    6bba:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6bbc:	19 82       	std	Y+1, r1	; 0x01
    6bbe:	52 c0       	rjmp	.+164    	; 0x6c64 <Timer1_enuSet_OC1B_Action+0x12e>
		break;
	case ToggleOnCompare:
		TCCR1A|=(1<<COM1B0);
    6bc0:	af e4       	ldi	r26, 0x4F	; 79
    6bc2:	b0 e0       	ldi	r27, 0x00	; 0
    6bc4:	ef e4       	ldi	r30, 0x4F	; 79
    6bc6:	f0 e0       	ldi	r31, 0x00	; 0
    6bc8:	80 81       	ld	r24, Z
    6bca:	80 61       	ori	r24, 0x10	; 16
    6bcc:	8c 93       	st	X, r24
		TCCR1A&=~(1<<COM1B1);
    6bce:	af e4       	ldi	r26, 0x4F	; 79
    6bd0:	b0 e0       	ldi	r27, 0x00	; 0
    6bd2:	ef e4       	ldi	r30, 0x4F	; 79
    6bd4:	f0 e0       	ldi	r31, 0x00	; 0
    6bd6:	80 81       	ld	r24, Z
    6bd8:	8f 7d       	andi	r24, 0xDF	; 223
    6bda:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6bdc:	19 82       	std	Y+1, r1	; 0x01
    6bde:	42 c0       	rjmp	.+132    	; 0x6c64 <Timer1_enuSet_OC1B_Action+0x12e>
		break;
	case ClearOnCompare:
		TCCR1A&=~(1<<COM1B0);
    6be0:	af e4       	ldi	r26, 0x4F	; 79
    6be2:	b0 e0       	ldi	r27, 0x00	; 0
    6be4:	ef e4       	ldi	r30, 0x4F	; 79
    6be6:	f0 e0       	ldi	r31, 0x00	; 0
    6be8:	80 81       	ld	r24, Z
    6bea:	8f 7e       	andi	r24, 0xEF	; 239
    6bec:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1B1);
    6bee:	af e4       	ldi	r26, 0x4F	; 79
    6bf0:	b0 e0       	ldi	r27, 0x00	; 0
    6bf2:	ef e4       	ldi	r30, 0x4F	; 79
    6bf4:	f0 e0       	ldi	r31, 0x00	; 0
    6bf6:	80 81       	ld	r24, Z
    6bf8:	80 62       	ori	r24, 0x20	; 32
    6bfa:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6bfc:	19 82       	std	Y+1, r1	; 0x01
    6bfe:	32 c0       	rjmp	.+100    	; 0x6c64 <Timer1_enuSet_OC1B_Action+0x12e>
		break;
	case PWM_NonInverted:
		TCCR1A&=~(1<<COM1B0);
    6c00:	af e4       	ldi	r26, 0x4F	; 79
    6c02:	b0 e0       	ldi	r27, 0x00	; 0
    6c04:	ef e4       	ldi	r30, 0x4F	; 79
    6c06:	f0 e0       	ldi	r31, 0x00	; 0
    6c08:	80 81       	ld	r24, Z
    6c0a:	8f 7e       	andi	r24, 0xEF	; 239
    6c0c:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1B1);
    6c0e:	af e4       	ldi	r26, 0x4F	; 79
    6c10:	b0 e0       	ldi	r27, 0x00	; 0
    6c12:	ef e4       	ldi	r30, 0x4F	; 79
    6c14:	f0 e0       	ldi	r31, 0x00	; 0
    6c16:	80 81       	ld	r24, Z
    6c18:	80 62       	ori	r24, 0x20	; 32
    6c1a:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6c1c:	19 82       	std	Y+1, r1	; 0x01
    6c1e:	22 c0       	rjmp	.+68     	; 0x6c64 <Timer1_enuSet_OC1B_Action+0x12e>
		break;
	case SetOnCompare:
		TCCR1A|=(1<<COM1B0);
    6c20:	af e4       	ldi	r26, 0x4F	; 79
    6c22:	b0 e0       	ldi	r27, 0x00	; 0
    6c24:	ef e4       	ldi	r30, 0x4F	; 79
    6c26:	f0 e0       	ldi	r31, 0x00	; 0
    6c28:	80 81       	ld	r24, Z
    6c2a:	80 61       	ori	r24, 0x10	; 16
    6c2c:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1B1);
    6c2e:	af e4       	ldi	r26, 0x4F	; 79
    6c30:	b0 e0       	ldi	r27, 0x00	; 0
    6c32:	ef e4       	ldi	r30, 0x4F	; 79
    6c34:	f0 e0       	ldi	r31, 0x00	; 0
    6c36:	80 81       	ld	r24, Z
    6c38:	80 62       	ori	r24, 0x20	; 32
    6c3a:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6c3c:	19 82       	std	Y+1, r1	; 0x01
    6c3e:	12 c0       	rjmp	.+36     	; 0x6c64 <Timer1_enuSet_OC1B_Action+0x12e>
		break;
	case PWM_Inverted:
		TCCR1A|=(1<<COM1B0);
    6c40:	af e4       	ldi	r26, 0x4F	; 79
    6c42:	b0 e0       	ldi	r27, 0x00	; 0
    6c44:	ef e4       	ldi	r30, 0x4F	; 79
    6c46:	f0 e0       	ldi	r31, 0x00	; 0
    6c48:	80 81       	ld	r24, Z
    6c4a:	80 61       	ori	r24, 0x10	; 16
    6c4c:	8c 93       	st	X, r24
		TCCR1A|=(1<<COM1B1);
    6c4e:	af e4       	ldi	r26, 0x4F	; 79
    6c50:	b0 e0       	ldi	r27, 0x00	; 0
    6c52:	ef e4       	ldi	r30, 0x4F	; 79
    6c54:	f0 e0       	ldi	r31, 0x00	; 0
    6c56:	80 81       	ld	r24, Z
    6c58:	80 62       	ori	r24, 0x20	; 32
    6c5a:	8c 93       	st	X, r24
		Local_enuErrorState = ES_OK;
    6c5c:	19 82       	std	Y+1, r1	; 0x01
    6c5e:	02 c0       	rjmp	.+4      	; 0x6c64 <Timer1_enuSet_OC1B_Action+0x12e>
		break;
	default:
		Local_enuErrorState = ES_OUT_OF_RANGE;
    6c60:	83 e0       	ldi	r24, 0x03	; 3
    6c62:	89 83       	std	Y+1, r24	; 0x01
		break;
	}

	return Local_enuErrorState;
    6c64:	89 81       	ldd	r24, Y+1	; 0x01
}
    6c66:	0f 90       	pop	r0
    6c68:	0f 90       	pop	r0
    6c6a:	0f 90       	pop	r0
    6c6c:	0f 90       	pop	r0
    6c6e:	cf 91       	pop	r28
    6c70:	df 91       	pop	r29
    6c72:	08 95       	ret

00006c74 <Timer1_enuOverFlowINT_Enable>:


ES_t Timer1_enuOverFlowINT_Enable()
{
    6c74:	df 93       	push	r29
    6c76:	cf 93       	push	r28
    6c78:	0f 92       	push	r0
    6c7a:	cd b7       	in	r28, 0x3d	; 61
    6c7c:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState = ES_NOK;
    6c7e:	81 e0       	ldi	r24, 0x01	; 1
    6c80:	89 83       	std	Y+1, r24	; 0x01

	//Overflow Interrupt Enable
	TIMSK|=(1<<TOIE1);
    6c82:	a9 e5       	ldi	r26, 0x59	; 89
    6c84:	b0 e0       	ldi	r27, 0x00	; 0
    6c86:	e9 e5       	ldi	r30, 0x59	; 89
    6c88:	f0 e0       	ldi	r31, 0x00	; 0
    6c8a:	80 81       	ld	r24, Z
    6c8c:	84 60       	ori	r24, 0x04	; 4
    6c8e:	8c 93       	st	X, r24
	Local_enuErrorState = ES_OK;
    6c90:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    6c92:	89 81       	ldd	r24, Y+1	; 0x01
}
    6c94:	0f 90       	pop	r0
    6c96:	cf 91       	pop	r28
    6c98:	df 91       	pop	r29
    6c9a:	08 95       	ret

00006c9c <Timer1_enuOverFlowINT_Disable>:

ES_t Timer1_enuOverFlowINT_Disable()
{
    6c9c:	df 93       	push	r29
    6c9e:	cf 93       	push	r28
    6ca0:	0f 92       	push	r0
    6ca2:	cd b7       	in	r28, 0x3d	; 61
    6ca4:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState = ES_NOK;
    6ca6:	81 e0       	ldi	r24, 0x01	; 1
    6ca8:	89 83       	std	Y+1, r24	; 0x01

	//Overflow Interrupt Disable
	TIMSK&=~(1<<TOIE1);
    6caa:	a9 e5       	ldi	r26, 0x59	; 89
    6cac:	b0 e0       	ldi	r27, 0x00	; 0
    6cae:	e9 e5       	ldi	r30, 0x59	; 89
    6cb0:	f0 e0       	ldi	r31, 0x00	; 0
    6cb2:	80 81       	ld	r24, Z
    6cb4:	8b 7f       	andi	r24, 0xFB	; 251
    6cb6:	8c 93       	st	X, r24
	Local_enuErrorState = ES_OK;
    6cb8:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    6cba:	89 81       	ldd	r24, Y+1	; 0x01
}
    6cbc:	0f 90       	pop	r0
    6cbe:	cf 91       	pop	r28
    6cc0:	df 91       	pop	r29
    6cc2:	08 95       	ret

00006cc4 <Timer1_enuCTCA_INT_Enable>:

ES_t Timer1_enuCTCA_INT_Enable()
{
    6cc4:	df 93       	push	r29
    6cc6:	cf 93       	push	r28
    6cc8:	0f 92       	push	r0
    6cca:	cd b7       	in	r28, 0x3d	; 61
    6ccc:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState = ES_NOK;
    6cce:	81 e0       	ldi	r24, 0x01	; 1
    6cd0:	89 83       	std	Y+1, r24	; 0x01
	TIMSK|=(1<<OCIE1A);
    6cd2:	a9 e5       	ldi	r26, 0x59	; 89
    6cd4:	b0 e0       	ldi	r27, 0x00	; 0
    6cd6:	e9 e5       	ldi	r30, 0x59	; 89
    6cd8:	f0 e0       	ldi	r31, 0x00	; 0
    6cda:	80 81       	ld	r24, Z
    6cdc:	80 61       	ori	r24, 0x10	; 16
    6cde:	8c 93       	st	X, r24

	return Local_enuErrorState;
    6ce0:	89 81       	ldd	r24, Y+1	; 0x01
}
    6ce2:	0f 90       	pop	r0
    6ce4:	cf 91       	pop	r28
    6ce6:	df 91       	pop	r29
    6ce8:	08 95       	ret

00006cea <Timer1_enuCTCB_INT_Enable>:

ES_t Timer1_enuCTCB_INT_Enable()
{
    6cea:	df 93       	push	r29
    6cec:	cf 93       	push	r28
    6cee:	0f 92       	push	r0
    6cf0:	cd b7       	in	r28, 0x3d	; 61
    6cf2:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState = ES_NOK;
    6cf4:	81 e0       	ldi	r24, 0x01	; 1
    6cf6:	89 83       	std	Y+1, r24	; 0x01

	TIMSK|=(1<<OCIE1B);
    6cf8:	a9 e5       	ldi	r26, 0x59	; 89
    6cfa:	b0 e0       	ldi	r27, 0x00	; 0
    6cfc:	e9 e5       	ldi	r30, 0x59	; 89
    6cfe:	f0 e0       	ldi	r31, 0x00	; 0
    6d00:	80 81       	ld	r24, Z
    6d02:	88 60       	ori	r24, 0x08	; 8
    6d04:	8c 93       	st	X, r24
	Local_enuErrorState = ES_OK;
    6d06:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    6d08:	89 81       	ldd	r24, Y+1	; 0x01
}
    6d0a:	0f 90       	pop	r0
    6d0c:	cf 91       	pop	r28
    6d0e:	df 91       	pop	r29
    6d10:	08 95       	ret

00006d12 <Timer1_enuCTCA_INT_Disable>:


ES_t Timer1_enuCTCA_INT_Disable()
{
    6d12:	df 93       	push	r29
    6d14:	cf 93       	push	r28
    6d16:	0f 92       	push	r0
    6d18:	cd b7       	in	r28, 0x3d	; 61
    6d1a:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState = ES_NOK;
    6d1c:	81 e0       	ldi	r24, 0x01	; 1
    6d1e:	89 83       	std	Y+1, r24	; 0x01

	TIMSK&=~(1<<OCIE1A);
    6d20:	a9 e5       	ldi	r26, 0x59	; 89
    6d22:	b0 e0       	ldi	r27, 0x00	; 0
    6d24:	e9 e5       	ldi	r30, 0x59	; 89
    6d26:	f0 e0       	ldi	r31, 0x00	; 0
    6d28:	80 81       	ld	r24, Z
    6d2a:	8f 7e       	andi	r24, 0xEF	; 239
    6d2c:	8c 93       	st	X, r24
	Local_enuErrorState = ES_OK;
    6d2e:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    6d30:	89 81       	ldd	r24, Y+1	; 0x01
}
    6d32:	0f 90       	pop	r0
    6d34:	cf 91       	pop	r28
    6d36:	df 91       	pop	r29
    6d38:	08 95       	ret

00006d3a <Timer1_enuCTCB_INT_Disable>:

ES_t Timer1_enuCTCB_INT_Disable()
{
    6d3a:	df 93       	push	r29
    6d3c:	cf 93       	push	r28
    6d3e:	0f 92       	push	r0
    6d40:	cd b7       	in	r28, 0x3d	; 61
    6d42:	de b7       	in	r29, 0x3e	; 62
	ES_t Local_enuErrorState = ES_NOK;
    6d44:	81 e0       	ldi	r24, 0x01	; 1
    6d46:	89 83       	std	Y+1, r24	; 0x01

	TIMSK&=~(1<<OCIE1B);
    6d48:	a9 e5       	ldi	r26, 0x59	; 89
    6d4a:	b0 e0       	ldi	r27, 0x00	; 0
    6d4c:	e9 e5       	ldi	r30, 0x59	; 89
    6d4e:	f0 e0       	ldi	r31, 0x00	; 0
    6d50:	80 81       	ld	r24, Z
    6d52:	87 7f       	andi	r24, 0xF7	; 247
    6d54:	8c 93       	st	X, r24
	Local_enuErrorState = ES_OK;
    6d56:	19 82       	std	Y+1, r1	; 0x01

	return Local_enuErrorState;
    6d58:	89 81       	ldd	r24, Y+1	; 0x01
}
    6d5a:	0f 90       	pop	r0
    6d5c:	cf 91       	pop	r28
    6d5e:	df 91       	pop	r29
    6d60:	08 95       	ret

00006d62 <Timer1_enuCallBackOVF>:

ES_t Timer1_enuCallBackOVF(void(*Copy_pfunTimer1func)(void))
{
    6d62:	df 93       	push	r29
    6d64:	cf 93       	push	r28
    6d66:	00 d0       	rcall	.+0      	; 0x6d68 <Timer1_enuCallBackOVF+0x6>
    6d68:	0f 92       	push	r0
    6d6a:	cd b7       	in	r28, 0x3d	; 61
    6d6c:	de b7       	in	r29, 0x3e	; 62
    6d6e:	9b 83       	std	Y+3, r25	; 0x03
    6d70:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    6d72:	81 e0       	ldi	r24, 0x01	; 1
    6d74:	89 83       	std	Y+1, r24	; 0x01

	if(Copy_pfunTimer1func == NULL)
    6d76:	8a 81       	ldd	r24, Y+2	; 0x02
    6d78:	9b 81       	ldd	r25, Y+3	; 0x03
    6d7a:	00 97       	sbiw	r24, 0x00	; 0
    6d7c:	19 f4       	brne	.+6      	; 0x6d84 <Timer1_enuCallBackOVF+0x22>
	{
		Local_enuErrorState=ES_NULL_POINTER;
    6d7e:	82 e0       	ldi	r24, 0x02	; 2
    6d80:	89 83       	std	Y+1, r24	; 0x01
    6d82:	07 c0       	rjmp	.+14     	; 0x6d92 <Timer1_enuCallBackOVF+0x30>
	}
	else
	{

		Timer1_pfuncTimer1_OVF_Func = Copy_pfunTimer1func;
    6d84:	8a 81       	ldd	r24, Y+2	; 0x02
    6d86:	9b 81       	ldd	r25, Y+3	; 0x03
    6d88:	90 93 c3 06 	sts	0x06C3, r25
    6d8c:	80 93 c2 06 	sts	0x06C2, r24
		Local_enuErrorState=ES_OK;
    6d90:	19 82       	std	Y+1, r1	; 0x01

	}

	return Local_enuErrorState;
    6d92:	89 81       	ldd	r24, Y+1	; 0x01
}
    6d94:	0f 90       	pop	r0
    6d96:	0f 90       	pop	r0
    6d98:	0f 90       	pop	r0
    6d9a:	cf 91       	pop	r28
    6d9c:	df 91       	pop	r29
    6d9e:	08 95       	ret

00006da0 <Timer1_enuCallBackCTCA>:


ES_t Timer1_enuCallBackCTCA(void(*Copy_pfunTimer1func)(void))
{
    6da0:	df 93       	push	r29
    6da2:	cf 93       	push	r28
    6da4:	00 d0       	rcall	.+0      	; 0x6da6 <Timer1_enuCallBackCTCA+0x6>
    6da6:	0f 92       	push	r0
    6da8:	cd b7       	in	r28, 0x3d	; 61
    6daa:	de b7       	in	r29, 0x3e	; 62
    6dac:	9b 83       	std	Y+3, r25	; 0x03
    6dae:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    6db0:	81 e0       	ldi	r24, 0x01	; 1
    6db2:	89 83       	std	Y+1, r24	; 0x01

	if(Copy_pfunTimer1func == NULL)
    6db4:	8a 81       	ldd	r24, Y+2	; 0x02
    6db6:	9b 81       	ldd	r25, Y+3	; 0x03
    6db8:	00 97       	sbiw	r24, 0x00	; 0
    6dba:	19 f4       	brne	.+6      	; 0x6dc2 <Timer1_enuCallBackCTCA+0x22>
	{
		Local_enuErrorState=ES_NULL_POINTER;
    6dbc:	82 e0       	ldi	r24, 0x02	; 2
    6dbe:	89 83       	std	Y+1, r24	; 0x01
    6dc0:	07 c0       	rjmp	.+14     	; 0x6dd0 <Timer1_enuCallBackCTCA+0x30>
	}
	else
	{
		Timer1_pfuncTimer1_CTCA_Func = Copy_pfunTimer1func;
    6dc2:	8a 81       	ldd	r24, Y+2	; 0x02
    6dc4:	9b 81       	ldd	r25, Y+3	; 0x03
    6dc6:	90 93 c5 06 	sts	0x06C5, r25
    6dca:	80 93 c4 06 	sts	0x06C4, r24
		Local_enuErrorState=ES_OK;
    6dce:	19 82       	std	Y+1, r1	; 0x01
	}

	return Local_enuErrorState;
    6dd0:	89 81       	ldd	r24, Y+1	; 0x01
}
    6dd2:	0f 90       	pop	r0
    6dd4:	0f 90       	pop	r0
    6dd6:	0f 90       	pop	r0
    6dd8:	cf 91       	pop	r28
    6dda:	df 91       	pop	r29
    6ddc:	08 95       	ret

00006dde <Timer1_enuCallBackCTCB>:

ES_t Timer1_enuCallBackCTCB(void(*Copy_pfunTimer1func)(void))
{
    6dde:	df 93       	push	r29
    6de0:	cf 93       	push	r28
    6de2:	00 d0       	rcall	.+0      	; 0x6de4 <Timer1_enuCallBackCTCB+0x6>
    6de4:	0f 92       	push	r0
    6de6:	cd b7       	in	r28, 0x3d	; 61
    6de8:	de b7       	in	r29, 0x3e	; 62
    6dea:	9b 83       	std	Y+3, r25	; 0x03
    6dec:	8a 83       	std	Y+2, r24	; 0x02
	ES_t Local_enuErrorState = ES_NOK;
    6dee:	81 e0       	ldi	r24, 0x01	; 1
    6df0:	89 83       	std	Y+1, r24	; 0x01

	if(Copy_pfunTimer1func == NULL)
    6df2:	8a 81       	ldd	r24, Y+2	; 0x02
    6df4:	9b 81       	ldd	r25, Y+3	; 0x03
    6df6:	00 97       	sbiw	r24, 0x00	; 0
    6df8:	19 f4       	brne	.+6      	; 0x6e00 <Timer1_enuCallBackCTCB+0x22>
	{
		Local_enuErrorState=ES_NULL_POINTER;
    6dfa:	82 e0       	ldi	r24, 0x02	; 2
    6dfc:	89 83       	std	Y+1, r24	; 0x01
    6dfe:	07 c0       	rjmp	.+14     	; 0x6e0e <Timer1_enuCallBackCTCB+0x30>
	}
	else
	{
		Timer1_pfuncTimer1_CTCB_Func = Copy_pfunTimer1func;
    6e00:	8a 81       	ldd	r24, Y+2	; 0x02
    6e02:	9b 81       	ldd	r25, Y+3	; 0x03
    6e04:	90 93 c7 06 	sts	0x06C7, r25
    6e08:	80 93 c6 06 	sts	0x06C6, r24
		Local_enuErrorState=ES_OK;
    6e0c:	19 82       	std	Y+1, r1	; 0x01
	}

	return Local_enuErrorState;
    6e0e:	89 81       	ldd	r24, Y+1	; 0x01
}
    6e10:	0f 90       	pop	r0
    6e12:	0f 90       	pop	r0
    6e14:	0f 90       	pop	r0
    6e16:	cf 91       	pop	r28
    6e18:	df 91       	pop	r29
    6e1a:	08 95       	ret

00006e1c <__vector_8>:


//Timer/Counter1 Compare Match B
void __vector_8(void) __attribute__((signal));
void __vector_8 (void)
{
    6e1c:	1f 92       	push	r1
    6e1e:	0f 92       	push	r0
    6e20:	0f b6       	in	r0, 0x3f	; 63
    6e22:	0f 92       	push	r0
    6e24:	11 24       	eor	r1, r1
    6e26:	2f 93       	push	r18
    6e28:	3f 93       	push	r19
    6e2a:	4f 93       	push	r20
    6e2c:	5f 93       	push	r21
    6e2e:	6f 93       	push	r22
    6e30:	7f 93       	push	r23
    6e32:	8f 93       	push	r24
    6e34:	9f 93       	push	r25
    6e36:	af 93       	push	r26
    6e38:	bf 93       	push	r27
    6e3a:	ef 93       	push	r30
    6e3c:	ff 93       	push	r31
    6e3e:	df 93       	push	r29
    6e40:	cf 93       	push	r28
    6e42:	cd b7       	in	r28, 0x3d	; 61
    6e44:	de b7       	in	r29, 0x3e	; 62
	if(Timer1_pfuncTimer1_CTCB_Func != NULL)
    6e46:	80 91 c6 06 	lds	r24, 0x06C6
    6e4a:	90 91 c7 06 	lds	r25, 0x06C7
    6e4e:	00 97       	sbiw	r24, 0x00	; 0
    6e50:	29 f0       	breq	.+10     	; 0x6e5c <__vector_8+0x40>
	{
		Timer1_pfuncTimer1_CTCB_Func();
    6e52:	e0 91 c6 06 	lds	r30, 0x06C6
    6e56:	f0 91 c7 06 	lds	r31, 0x06C7
    6e5a:	09 95       	icall
	}


}
    6e5c:	cf 91       	pop	r28
    6e5e:	df 91       	pop	r29
    6e60:	ff 91       	pop	r31
    6e62:	ef 91       	pop	r30
    6e64:	bf 91       	pop	r27
    6e66:	af 91       	pop	r26
    6e68:	9f 91       	pop	r25
    6e6a:	8f 91       	pop	r24
    6e6c:	7f 91       	pop	r23
    6e6e:	6f 91       	pop	r22
    6e70:	5f 91       	pop	r21
    6e72:	4f 91       	pop	r20
    6e74:	3f 91       	pop	r19
    6e76:	2f 91       	pop	r18
    6e78:	0f 90       	pop	r0
    6e7a:	0f be       	out	0x3f, r0	; 63
    6e7c:	0f 90       	pop	r0
    6e7e:	1f 90       	pop	r1
    6e80:	18 95       	reti

00006e82 <__vector_9>:
//Timer/Counter1 Overflow
void __vector_9(void) __attribute__((signal));
void __vector_9 (void)
{
    6e82:	1f 92       	push	r1
    6e84:	0f 92       	push	r0
    6e86:	0f b6       	in	r0, 0x3f	; 63
    6e88:	0f 92       	push	r0
    6e8a:	11 24       	eor	r1, r1
    6e8c:	2f 93       	push	r18
    6e8e:	3f 93       	push	r19
    6e90:	4f 93       	push	r20
    6e92:	5f 93       	push	r21
    6e94:	6f 93       	push	r22
    6e96:	7f 93       	push	r23
    6e98:	8f 93       	push	r24
    6e9a:	9f 93       	push	r25
    6e9c:	af 93       	push	r26
    6e9e:	bf 93       	push	r27
    6ea0:	ef 93       	push	r30
    6ea2:	ff 93       	push	r31
    6ea4:	df 93       	push	r29
    6ea6:	cf 93       	push	r28
    6ea8:	cd b7       	in	r28, 0x3d	; 61
    6eaa:	de b7       	in	r29, 0x3e	; 62
	if(Timer1_pfuncTimer1_OVF_Func != NULL)
    6eac:	80 91 c2 06 	lds	r24, 0x06C2
    6eb0:	90 91 c3 06 	lds	r25, 0x06C3
    6eb4:	00 97       	sbiw	r24, 0x00	; 0
    6eb6:	29 f0       	breq	.+10     	; 0x6ec2 <__vector_9+0x40>
	{
		Timer1_pfuncTimer1_OVF_Func();
    6eb8:	e0 91 c2 06 	lds	r30, 0x06C2
    6ebc:	f0 91 c3 06 	lds	r31, 0x06C3
    6ec0:	09 95       	icall
	}
}
    6ec2:	cf 91       	pop	r28
    6ec4:	df 91       	pop	r29
    6ec6:	ff 91       	pop	r31
    6ec8:	ef 91       	pop	r30
    6eca:	bf 91       	pop	r27
    6ecc:	af 91       	pop	r26
    6ece:	9f 91       	pop	r25
    6ed0:	8f 91       	pop	r24
    6ed2:	7f 91       	pop	r23
    6ed4:	6f 91       	pop	r22
    6ed6:	5f 91       	pop	r21
    6ed8:	4f 91       	pop	r20
    6eda:	3f 91       	pop	r19
    6edc:	2f 91       	pop	r18
    6ede:	0f 90       	pop	r0
    6ee0:	0f be       	out	0x3f, r0	; 63
    6ee2:	0f 90       	pop	r0
    6ee4:	1f 90       	pop	r1
    6ee6:	18 95       	reti

00006ee8 <__udivmodhi4>:
    6ee8:	aa 1b       	sub	r26, r26
    6eea:	bb 1b       	sub	r27, r27
    6eec:	51 e1       	ldi	r21, 0x11	; 17
    6eee:	07 c0       	rjmp	.+14     	; 0x6efe <__udivmodhi4_ep>

00006ef0 <__udivmodhi4_loop>:
    6ef0:	aa 1f       	adc	r26, r26
    6ef2:	bb 1f       	adc	r27, r27
    6ef4:	a6 17       	cp	r26, r22
    6ef6:	b7 07       	cpc	r27, r23
    6ef8:	10 f0       	brcs	.+4      	; 0x6efe <__udivmodhi4_ep>
    6efa:	a6 1b       	sub	r26, r22
    6efc:	b7 0b       	sbc	r27, r23

00006efe <__udivmodhi4_ep>:
    6efe:	88 1f       	adc	r24, r24
    6f00:	99 1f       	adc	r25, r25
    6f02:	5a 95       	dec	r21
    6f04:	a9 f7       	brne	.-22     	; 0x6ef0 <__udivmodhi4_loop>
    6f06:	80 95       	com	r24
    6f08:	90 95       	com	r25
    6f0a:	bc 01       	movw	r22, r24
    6f0c:	cd 01       	movw	r24, r26
    6f0e:	08 95       	ret

00006f10 <memcpy>:
    6f10:	fb 01       	movw	r30, r22
    6f12:	dc 01       	movw	r26, r24
    6f14:	02 c0       	rjmp	.+4      	; 0x6f1a <memcpy+0xa>
    6f16:	01 90       	ld	r0, Z+
    6f18:	0d 92       	st	X+, r0
    6f1a:	41 50       	subi	r20, 0x01	; 1
    6f1c:	50 40       	sbci	r21, 0x00	; 0
    6f1e:	d8 f7       	brcc	.-10     	; 0x6f16 <memcpy+0x6>
    6f20:	08 95       	ret

00006f22 <memset>:
    6f22:	dc 01       	movw	r26, r24
    6f24:	01 c0       	rjmp	.+2      	; 0x6f28 <memset+0x6>
    6f26:	6d 93       	st	X+, r22
    6f28:	41 50       	subi	r20, 0x01	; 1
    6f2a:	50 40       	sbci	r21, 0x00	; 0
    6f2c:	e0 f7       	brcc	.-8      	; 0x6f26 <memset+0x4>
    6f2e:	08 95       	ret

00006f30 <_exit>:
    6f30:	f8 94       	cli

00006f32 <__stop_program>:
    6f32:	ff cf       	rjmp	.-2      	; 0x6f32 <__stop_program>
